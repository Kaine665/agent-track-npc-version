# 07-开发设计思想（V1）

**文档版本**：v1.0.0  
**最后更新**：2025-11-22  
**相关文档**：[系统架构](./06-系统架构.md) | [API设计](./04-API设计.md)

---

## 1. 核心设计思想：前后端分开开发

### 1.1 设计理念

**前后端分开设计思想**（不是前后端分离架构）

V1 版本采用"前后端分开开发"的设计思想，这是一种开发方法论，而非架构模式。核心思想是：

- **前后端可以独立开发**：前端和后端可以完全独立地进行开发和测试
- **前端可以用假数据尝试不同展现形式**：前端可以使用 Mock 数据，快速尝试不同的 UI 设计和交互方式
- **后端可以不接前端，设想功能并实现**：后端可以独立实现功能，通过测试验证效果，不需要等待前端完成
- **API 适配层作为桥梁**：通过 API 适配层实现前后端的解耦和切换

### 1.2 与前后端分离架构的区别

| 对比项 | 前后端分离架构 | 前后端分开开发思想 |
|--------|----------------|-------------------|
| **关注点** | 架构模式（部署、通信） | 开发方法论（开发流程） |
| **核心价值** | 解耦部署、独立扩展 | 独立开发、快速迭代 |
| **实现方式** | RESTful API、微服务 | API 适配层、Mock 数据 |
| **适用场景** | 生产环境部署 | 开发阶段 |

**说明**：
- 前后端分离架构关注的是**如何部署和通信**
- 前后端分开开发思想关注的是**如何开发和测试**

---

## 2. API 适配层设计

### 2.1 架构设计

```
业务代码（前端组件）
    ↓
统一 API 接口（api/index.js）
    ↓
API 适配器（Adapter Pattern）
    ├── Mock 适配器（mockAdapter.js）
    │   └── 返回假数据
    └── HTTP 适配器（httpAdapter.js）
        └── 调用后端 API
```

### 2.2 适配器接口定义

**统一接口规范**（`adapter.js`）：

```javascript
class ApiAdapter {
  agents = {
    create: async (data) => { throw new Error('Not implemented'); },
    getList: async (userId) => { throw new Error('Not implemented'); },
    getById: async (agentId, userId) => { throw new Error('Not implemented'); },
  };
  
  messages = {
    send: async (data) => { throw new Error('Not implemented'); },
  };
  
  history = {
    get: async (userId, agentId) => { throw new Error('Not implemented'); },
  };
  
  sessions = {
    getList: async (userId) => { throw new Error('Not implemented'); },
  };
  
  users = {
    login: async (userId, password) => { throw new Error('Not implemented'); },
    register: async (userId, username, password) => { throw new Error('Not implemented'); },
  };
}
```

### 2.3 Mock 适配器工作原理

**Mock 适配器**（`mockAdapter.js`）：

```javascript
class MockAdapter extends ApiAdapter {
  agents = {
    create: async (data) => {
      // 截获 API 请求，返回假数据
      await delay(1000); // 模拟网络延迟
      
      // 模拟业务逻辑（名称重复检查等）
      const isDuplicate = mockAgents.some(
        agent => agent.userId === data.userId && 
                 agent.name.toLowerCase() === data.name.toLowerCase()
      );
      
      if (isDuplicate) {
        return {
          success: false,
          error: { code: 'DUPLICATE_NAME', message: '该名称已存在' }
        };
      }
      
      // 返回假数据
      return {
        success: true,
        data: { id: `agent_${Date.now()}`, ...data },
        timestamp: Date.now()
      };
    },
    // ... 其他方法
  };
}
```

**工作原理**：

1. **截获 API 请求**：Mock 适配器截获前端业务代码对 API 的调用
2. **返回假数据**：根据请求参数，返回预设的假数据
3. **模拟业务逻辑**：可以模拟简单的业务逻辑（如名称重复检查）
4. **模拟网络延迟**：通过 `delay()` 函数模拟网络延迟，更接近真实场景

**优势**：

- 前端可以独立开发，不依赖后端
- 可以快速尝试不同的 UI 设计和交互方式
- 可以模拟各种场景（成功、失败、延迟等）

### 2.4 HTTP 适配器工作原理

**HTTP 适配器**（`httpAdapter.js`）：

```javascript
class HttpAdapter extends ApiAdapter {
  baseURL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';
  
  agents = {
    create: async (data) => {
      // 调用后端 API
      const response = await fetch(`${this.baseURL}/api/v1/agents`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      const result = await response.json();
      
      // 适配数据格式（如果需要）
      return {
        success: result.success,
        data: result.data,
        timestamp: result.timestamp
      };
    },
    // ... 其他方法
  };
}
```

**工作原理**：

1. **调用后端 API**：HTTP 适配器调用真实的后端 HTTP API
2. **适配数据格式**：将后端返回的数据格式适配为前端 API 统一格式
3. **处理错误**：统一处理错误响应，转换为前端 API 错误格式

**优势**：

- 前后端通过 HTTP API 通信，解耦部署
- 数据格式适配层，后端可以灵活调整 API 格式
- 统一的错误处理，前端无需关心后端错误格式

### 2.5 自动检测后端可用性

**自动切换机制**（`index.js`）：

```javascript
async function checkBackendAvailable(baseURL) {
  try {
    const response = await fetch(`${baseURL}/api/v1/health`, {
      signal: AbortSignal.timeout(2000) // 2秒超时
    });
    return response.ok && (await response.json()).success === true;
  } catch (error) {
    return false; // 网络错误、超时等，返回 false
  }
}

async function createApi(mode = null) {
  const apiMode = mode || import.meta.env.VITE_API_MODE || 'auto';
  
  if (apiMode === 'mock') {
    return new MockAdapter(); // 强制使用 Mock
  }
  
  if (apiMode === 'http') {
    return new HttpAdapter(); // 强制使用 HTTP
  }
  
  // 自动检测模式
  const isBackendAvailable = await checkBackendAvailable(baseURL);
  
  if (isBackendAvailable) {
    return new HttpAdapter(); // 后端可用，使用 HTTP
  } else {
    return new MockAdapter(); // 后端不可用，使用 Mock
  }
}
```

**工作原理**：

1. **环境变量控制**：通过 `VITE_API_MODE` 环境变量控制模式（`mock`、`http`、`auto`）
2. **自动检测**：如果模式为 `auto`，自动检测后端健康检查端点
3. **自动切换**：后端可用时使用 HTTP 适配器，不可用时使用 Mock 适配器
4. **延迟检测**：如果立即检测失败，等待 10 秒后再检测一次（给后端启动时间）

**优势**：

- 开发环境自动切换，无需手动配置
- 后端未启动时自动使用 Mock 数据，不影响前端开发
- 后端启动后自动切换到真实 API，无需重启前端

---

## 3. 开发流程

### 3.1 前端开发流程

**使用 Mock 数据开发**：

1. **前端独立开发**：前端开发者使用 Mock 适配器，不依赖后端
2. **快速迭代 UI**：可以快速尝试不同的 UI 设计和交互方式
3. **模拟各种场景**：可以模拟成功、失败、延迟等各种场景
4. **后端完成后切换**：后端完成后，自动切换到 HTTP 适配器

**示例**：

```javascript
// 前端组件代码（不关心使用 Mock 还是 HTTP）
import api from '@/api';

const AgentList = () => {
  const [agents, setAgents] = useState([]);
  
  useEffect(() => {
    // 统一 API 接口，自动使用 Mock 或 HTTP
    api.agents.getList('user_123').then(result => {
      if (result.success) {
        setAgents(result.data.agents);
      }
    });
  }, []);
  
  return <div>{/* 渲染 NPC 列表 */}</div>;
};
```

### 3.2 后端开发流程

**独立实现功能**：

1. **设想功能**：后端开发者根据需求文档，设想功能实现
2. **实现功能**：独立实现功能，不依赖前端
3. **编写测试**：编写单元测试和集成测试，验证功能正确性
4. **前端集成**：前端通过 HTTP 适配器调用后端 API

**示例**：

```javascript
// 后端服务代码（不关心前端实现）
class AgentService {
  async createAgent(agentData) {
    // 1. 验证数据
    // 2. 检查名称是否重复
    // 3. 保存到数据库
    // 4. 返回创建的 Agent
  }
}

// 编写测试验证功能
describe('AgentService', () => {
  it('should create agent successfully', async () => {
    const agent = await agentService.createAgent({
      userId: 'user_123',
      name: '学习教练',
      type: 'special',
      model: 'gpt-4.1'
    });
    
    expect(agent.id).toBeDefined();
    expect(agent.name).toBe('学习教练');
  });
});
```

### 3.3 集成测试流程

**前后端集成**：

1. **后端启动**：后端服务启动，提供 HTTP API
2. **前端自动切换**：前端自动检测后端可用性，切换到 HTTP 适配器
3. **端到端测试**：进行端到端测试，验证前后端集成
4. **问题修复**：发现问题后，前后端独立修复，通过适配层集成

---

## 4. 设计优势

### 4.1 开发效率提升

- **并行开发**：前后端可以并行开发，不互相阻塞
- **快速迭代**：前端可以快速尝试不同的 UI 设计，无需等待后端
- **独立测试**：前后端可以独立测试，提高测试效率

### 4.2 开发灵活性

- **UI 快速迭代**：前端可以使用 Mock 数据，快速尝试不同的 UI 设计
- **功能独立实现**：后端可以独立实现功能，通过测试验证效果
- **易于切换**：通过适配层，可以轻松切换 Mock 和 HTTP 模式

### 4.3 代码质量提升

- **接口规范**：统一的 API 接口规范，确保前后端接口一致
- **错误处理**：统一的错误处理，提高代码健壮性
- **类型安全**：通过适配层，可以统一数据类型，提高类型安全

### 4.4 团队协作

- **职责清晰**：前后端职责清晰，减少沟通成本
- **独立开发**：前后端可以独立开发，减少依赖
- **快速集成**：通过适配层，可以快速集成前后端

---

## 5. 实现细节

### 5.1 文件结构

```
npc-frontend/src/api/
├── index.js          # API 入口，自动检测和切换适配器
├── adapter.js        # 适配器接口定义
├── mockAdapter.js    # Mock 适配器实现
├── httpAdapter.js    # HTTP 适配器实现
└── README.md         # API 适配层文档
```

### 5.2 环境变量配置

```bash
# .env.development
VITE_API_MODE=auto          # mock | http | auto（默认 auto）
VITE_API_BASE_URL=http://localhost:8000  # 后端 API 基础路径
```

### 5.3 使用示例

**业务代码使用统一 API**：

```javascript
import api from '@/api';

// 获取 NPC 列表
const result = await api.agents.getList('user_123');

// 创建 NPC
const newAgent = await api.agents.create({
  userId: 'user_123',
  name: '学习教练',
  type: 'special',
  model: 'gpt-4.1'
});

// 发送消息
const reply = await api.messages.send({
  userId: 'user_123',
  agentId: 'agent_456',
  content: '你好'
});

// 查看当前模式
console.log(api.mode); // 'mock' 或 'http'
```

---

## 6. 注意事项

### 6.1 Mock 数据维护

- **保持一致性**：Mock 数据应与后端 API 返回格式保持一致
- **及时更新**：后端 API 变更时，及时更新 Mock 数据
- **覆盖场景**：Mock 数据应覆盖各种场景（成功、失败、边界情况）

### 6.2 适配层维护

- **接口规范**：保持统一的 API 接口规范，确保前后端一致
- **错误处理**：统一的错误处理，确保错误信息一致
- **数据格式**：统一的数据格式，确保前后端数据一致

### 6.3 测试策略

- **单元测试**：前后端分别编写单元测试
- **集成测试**：通过适配层进行集成测试
- **端到端测试**：进行端到端测试，验证完整流程

---

## 7. 相关文档

- [系统架构](./06-系统架构.md) - 系统架构设计（包含 API 适配层架构）
- [API设计](./04-API设计.md) - API 接口设计
- [功能需求](./03-功能需求.md) - 功能需求说明

---

**文档维护**：设计思想变更时，需同步更新本文档和相关架构文档。

