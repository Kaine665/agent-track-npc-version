# 06-系统架构（V1）

**文档版本**：v1.0.0  
**最后更新**：2025-11-22  
**相关文档**：[功能需求](./03-功能需求.md) | [API 设计](./04-API设计.md) | [数据模型](./05-数据模型.md) | [开发设计思想](./07-开发设计思想.md)

---

## 1. 架构总览

### 1.1 架构原则

- **前后端分开开发**：前端和后端可以独立开发和测试（详见[开发设计思想](./07-开发设计思想.md)）
- **RESTful API**：使用 RESTful 风格设计 API
- **事件驱动**：基于事件记录系统，便于扩展
- **可扩展性**：为未来功能扩展预留接口
- **简单优先**：V1 版本优先简单实现，避免过度设计

### 1.2 技术选型（V1 实际使用）

#### 前端技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| React | 18.3.1 | UI 框架 |
| Vite | 5.4.2 | 构建工具和开发服务器 |
| Ant Design | 5.29.1 | UI 组件库 |
| React Router | 7.9.6 | 路由管理 |
| React Markdown | 10.1.0 | Markdown 渲染 |
| React Syntax Highlighter | 16.1.0 | 代码高亮 |

#### 后端技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| Node.js | 18+ | 运行时环境 |
| Express.js | 5.1.0 | Web 框架 |
| MySQL | 8.0 | 关系型数据库 |
| mysql2 | 3.15.3 | MySQL 客户端（原生 SQL，不使用 ORM） |
| OpenRouter | - | LLM API 统一入口（V1 版本统一使用 OpenRouter） |

#### 基础设施

| 技术 | 说明 |
|------|------|
| Docker | 容器化部署 |
| Docker Compose | 容器编排 |
| Nginx | 反向代理和静态资源服务 |
| Git | 版本控制 |

---

## 2. 系统架构图

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                      用户浏览器                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  NPC 列表页  │  │  对话页面   │  │  创建 NPC 页  │  │
│  │  (React)     │  │  (React)    │  │  (React)     │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└───────────────────────┬─────────────────────────────────┘
                        │ HTTP/HTTPS
                        │
┌───────────────────────▼─────────────────────────────────┐
│                    Nginx 反向代理                        │
│  - 路由 /api/* → 后端服务                                │
│  - 路由 /* → 前端静态资源                                │
└───────────────────────┬─────────────────────────────────┘
                        │
        ┌───────────────┴───────────────┐
        │                               │
┌───────▼────────┐            ┌─────────▼────────┐
│   前端容器     │            │   后端容器       │
│  (Nginx)      │            │  (Node.js)       │
│  - React SPA  │            │  - Express.js    │
│  - 静态资源   │            │  - API 路由      │
└───────────────┘            └─────────┬─────────┘
                                      │
                              ┌───────▼────────┐
                              │   MySQL 数据库  │
                              │  - users       │
                              │  - agents      │
                              │  - sessions    │
                              │  - events      │
                              └─────────────────┘
                                      │
                              ┌───────▼────────┐
                              │  OpenRouter    │
                              │  (LLM API)     │
                              └─────────────────┘
```

### 2.2 前端架构

```
前端应用（React + Vite）
├── 页面层（Pages）
│   ├── AgentList.jsx      # NPC 列表页面
│   ├── ChatPage.jsx       # 对话页面
│   ├── CreateAgent.jsx    # 创建 NPC 页面
│   └── Register.jsx       # 注册页面
│
├── 组件层（Components）
│   ├── AgentCard.jsx      # NPC 卡片组件
│   ├── MessageList.jsx    # 消息列表组件
│   ├── MessageInput.jsx   # 消息输入组件
│   └── MarkdownRenderer.jsx # Markdown 渲染组件
│
├── API 适配层（API Adapter Layer）
│   ├── index.js           # API 入口（自动检测和切换）
│   ├── adapter.js         # 适配器接口定义
│   ├── mockAdapter.js     # Mock 适配器（假数据）
│   └── httpAdapter.js     # HTTP 适配器（真实 API）
│
└── 工具层（Utils）
    ├── auth.js            # 认证工具
    └── constants.js       # 常量定义
```

**API 适配层设计**（核心设计思想）：

- **统一接口**：业务代码通过统一接口调用 API，不关心使用 Mock 还是 HTTP
- **自动切换**：自动检测后端可用性，后端可用时使用 HTTP，不可用时使用 Mock
- **独立开发**：前端可以使用 Mock 数据独立开发，不依赖后端
- 详细说明请参考：[开发设计思想](./07-开发设计思想.md)

### 2.3 后端架构

```
后端服务（Node.js + Express.js）
├── API 路由层（Routes）
│   ├── agents.js          # NPC 管理路由
│   ├── messages.js        # 消息路由
│   ├── history.js         # 历史记录路由
│   ├── sessions.js        # 会话路由
│   └── users.js           # 用户认证路由
│
├── 服务层（Services）
│   ├── AgentService.js    # NPC 管理服务
│   ├── MessageService.js  # 消息服务（异步处理）
│   ├── EventService.js    # 事件服务
│   ├── SessionService.js  # 会话服务
│   ├── UserService.js     # 用户服务
│   └── LLMService.js      # LLM API 调用服务
│
├── 数据访问层（Repositories）
│   ├── AgentRepository.js # NPC 数据访问
│   ├── EventRepository.js # 事件数据访问
│   ├── SessionRepository.js # 会话数据访问
│   └── UserRepository.js  # 用户数据访问
│
├── 中间件（Middleware）
│   ├── errorHandler.js    # 统一错误处理
│   └── requestLogger.js   # 请求日志
│
└── 工具层（Utils）
    ├── database.js        # 数据库连接
    ├── logger.js          # 日志工具
    └── configLoader.js    # 配置加载
```

---

## 3. 核心模块设计

### 3.1 前端 API 适配层

#### 3.1.1 架构设计

**适配器模式（Adapter Pattern）**：

```
业务代码（前端组件）
    ↓
统一 API 接口（api/index.js）
    ↓
API 适配器（Adapter Pattern）
    ├── Mock 适配器（mockAdapter.js）
    │   └── 返回假数据（截获 API 请求）
    └── HTTP 适配器（httpAdapter.js）
        └── 调用后端 API（适配数据格式）
```

#### 3.1.2 自动检测机制

**工作原理**：

1. **环境变量控制**：通过 `VITE_API_MODE` 控制模式（`mock`、`http`、`auto`）
2. **自动检测**：如果模式为 `auto`，自动检测后端健康检查端点
3. **自动切换**：后端可用时使用 HTTP 适配器，不可用时使用 Mock 适配器
4. **延迟检测**：如果立即检测失败，等待 10 秒后再检测一次（给后端启动时间）

**代码示例**：

```javascript
// api/index.js
async function checkBackendAvailable(baseURL) {
  try {
    const response = await fetch(`${baseURL}/api/v1/health`, {
      signal: AbortSignal.timeout(2000) // 2秒超时
    });
    return response.ok && (await response.json()).success === true;
  } catch (error) {
    return false;
  }
}

// 自动检测并切换适配器
const isBackendAvailable = await checkBackendAvailable(baseURL);
const adapter = isBackendAvailable ? new HttpAdapter() : new MockAdapter();
```

#### 3.1.3 Mock 适配器工作原理

**截获 API 请求，返回假数据**：

```javascript
// api/mockAdapter.js
class MockAdapter extends ApiAdapter {
  agents = {
    create: async (data) => {
      // 截获 API 请求
      await delay(1000); // 模拟网络延迟
      
      // 模拟业务逻辑（名称重复检查等）
      const isDuplicate = mockAgents.some(
        agent => agent.userId === data.userId && 
                 agent.name.toLowerCase() === data.name.toLowerCase()
      );
      
      if (isDuplicate) {
        return { success: false, error: { code: 'DUPLICATE_NAME' } };
      }
      
      // 返回假数据
      return { success: true, data: { id: `agent_${Date.now()}`, ...data } };
    },
  };
}
```

**优势**：
- 前端可以独立开发，不依赖后端
- 可以快速尝试不同的 UI 设计
- 可以模拟各种场景（成功、失败、延迟等）

#### 3.1.4 HTTP 适配器工作原理

**调用后端 API，适配数据格式**：

```javascript
// api/httpAdapter.js
class HttpAdapter extends ApiAdapter {
  baseURL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';
  
  agents = {
    create: async (data) => {
      // 调用后端 API
      const response = await fetch(`${this.baseURL}/api/v1/agents`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      const result = await response.json();
      
      // 适配数据格式（如果需要）
      return {
        success: result.success,
        data: result.data,
        timestamp: result.timestamp
      };
    },
  };
}
```

**优势**：
- 前后端通过 HTTP API 通信，解耦部署
- 数据格式适配层，后端可以灵活调整 API 格式
- 统一的错误处理

详细说明请参考：[开发设计思想](./07-开发设计思想.md)

---

### 3.2 后端消息处理模块

#### 3.2.1 异步处理架构（V1 实现：短轮询方案）

**处理流程**：

```
用户发送消息
  ↓
POST /api/v1/messages（立即返回）
  ├─ 1. 验证参数
  ├─ 2. 创建用户消息 Event（同步）
  └─ 3. 返回用户消息 Event ID
  ↓
前端开始轮询检查新消息
  ├─ GET /api/v1/messages/check（每 5 秒）
  └─ 最多轮询 60 次（5 分钟）
  ↓
后端异步处理（后台）
  ├─ 4. 读取 Agent 配置
  ├─ 5. 获取历史事件（上下文）
  ├─ 6. 构建 LLM Prompt
  ├─ 7. 调用 LLM API（异步）
  └─ 8. 创建 NPC 回复 Event（同步）
  ↓
前端轮询检测到新消息
  └─ 显示 NPC 回复
```

**设计说明**：

- **立即返回**：用户消息立即返回，不等待 LLM 回复
- **异步处理**：LLM API 调用在后台异步处理
- **短轮询**：前端通过短轮询检查新消息（每 5 秒）
- **超时处理**：最多轮询 5 分钟，超时后提示错误

#### 3.2.2 LLM 服务模块

**多提供商支持**（V1 版本统一使用 OpenRouter）：

```javascript
// services/LLMService.js
class LLMService {
  /**
   * 调用 LLM API 生成回复
   * @param {Object} options - 调用选项
   * @param {string} options.model - 模型名称（如 'anthropic/claude-sonnet-4.5'）
   * @param {string} options.systemPrompt - System prompt（可选）
   * @param {Array} options.messages - 对话消息列表
   * @returns {Promise<string>} 回复内容
   */
  async generateReply(options) {
    // V1 版本统一使用 OpenRouter
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': process.env.OPENROUTER_REFERER,
        'X-Title': process.env.OPENROUTER_TITLE
      },
      body: JSON.stringify({
        model: options.model,
        messages: [
          ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
          ...options.messages
        ]
      })
    });
    
    const data = await response.json();
    return data.choices[0].message.content;
  }
}
```

**重试机制**：

```javascript
async generateReply(options) {
  const maxRetries = 2;
  const retryDelay = 1000; // 1 秒
  
  for (let attempt = 1; attempt <= maxRetries + 1; attempt++) {
    try {
      const response = await this.callLLMAPI(options);
      return response.content;
    } catch (error) {
      if (attempt > maxRetries) {
        throw error;
      }
      await this.sleep(retryDelay * attempt); // 指数退避：1s, 2s
    }
  }
}
```

---

### 3.3 数据访问层

#### 3.3.1 Repository 模式

**设计原则**：

- **数据访问抽象**：Repository 封装数据访问逻辑，Service 层不直接操作数据库
- **SQL 原生查询**：V1 版本使用原生 SQL，不使用 ORM（简化实现）
- **连接池管理**：使用 mysql2 连接池管理数据库连接

**示例**：

```javascript
// repositories/AgentRepository.js
class AgentRepository {
  /**
   * 创建 Agent
   * @param {Object} agentData - Agent 数据
   * @returns {Promise<Agent>}
   */
  async create(agentData) {
    const query = `
      INSERT INTO agents (id, user_id, name, type, model, system_prompt, avatar_url, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
    
    const [result] = await db.execute(query, [
      agentData.id,
      agentData.userId,
      agentData.name,
      agentData.type,
      agentData.model,
      agentData.systemPrompt || null,
      agentData.avatarUrl || null,
      Date.now(),
      Date.now()
    ]);
    
    return this.findById(agentData.id);
  }
  
  /**
   * 根据用户 ID 查询 Agent 列表
   * @param {string} userId - 用户 ID
   * @returns {Promise<Agent[]>}
   */
  async findByUserId(userId) {
    const query = `
      SELECT * FROM agents
      WHERE user_id = ?
      ORDER BY created_at DESC
    `;
    
    const [rows] = await db.execute(query, [userId]);
    return rows;
  }
}
```

---

## 4. 数据流设计

### 4.1 创建 NPC 数据流

```
前端表单
  ↓ POST /api/v1/agents
API 路由层（routes/agents.js）
  ↓ 验证请求参数
AgentService
  ↓ 验证业务规则（名称重复检查）
AgentRepository
  ↓ INSERT INTO agents
MySQL 数据库
  ↓ 返回创建的记录
AgentRepository
  ↓ 返回 Agent 对象
AgentService
  ↓ 返回 Agent 对象
API 路由层
  ↓ 返回 JSON 响应
前端（通过 HTTP 适配器）
```

### 4.2 发送消息数据流（V1 异步处理）

```
前端输入框
  ↓ POST /api/v1/messages
API 路由层（routes/messages.js）
  ↓ 验证请求参数
MessageService.sendMessage（立即返回）
  ├─→ EventService.createEvent (用户发言，同步)
  └─→ 返回用户消息 Event ID
  ↓
前端接收响应，立即显示用户消息
  ↓
前端开始轮询（每 5 秒）
  GET /api/v1/messages/check?sessionId=xxx&lastEventId=yyy
  ↓
后端异步处理（后台）
  ├─→ AgentService.getAgentById (获取 NPC 配置)
  ├─→ EventService.getRecentEvents (获取上下文)
  ├─→ LLMService.generateReply (调用 LLM API，异步)
  └─→ EventService.createEvent (NPC 回复，同步)
  ↓
前端轮询检测到新消息
  ↓
前端显示 NPC 回复
```

---

## 5. 数据库设计

### 5.1 表结构

详见 [05-数据模型.md](./05-数据模型.md)

### 5.2 索引策略

- **agents 表**：
  - `user_id` 索引：快速查询用户的 NPC 列表
  - `created_at` 索引：排序使用

- **events 表**：
  - `session_id` 索引：快速查询会话事件
  - `timestamp` 索引：排序和范围查询
  - `(session_id, timestamp)` 复合索引：优化会话历史查询
  - `(user_id, agent_id, timestamp)` 复合索引：优化用户与 NPC 的对话历史查询

- **sessions 表**：
  - `user_id` 和 `agent_id` 索引：快速查询会话
  - `last_active_at` 索引：排序使用

### 5.3 数据保留策略

**产品核心承诺**：永久保留用户数据，除非用户主动删除

- **事件记录**：永久保存，不自动删除
- **NPC 配置**：永久保存，不自动删除
- **会话记录**：永久保存，不自动删除
- **数据备份**：定期备份数据，确保数据安全不丢失

详细说明请参考：[08-产品承诺与原则.md](./08-产品承诺与原则.md)

---

## 6. API 设计

### 6.1 RESTful 规范

- **资源命名**：使用名词，复数形式（如 `/agents`, `/events`）
- **HTTP 方法**：
  - GET：查询资源
  - POST：创建资源

### 6.2 统一响应格式

详见 [04-API设计.md](./04-API设计.md)

---

## 7. 错误处理

### 7.1 错误分类

1. **客户端错误**（4xx）：
   - 参数验证失败（400）
   - 资源不存在（404）
   - 名称重复（409）

2. **服务器错误**（5xx）：
   - 系统内部错误（500）
   - LLM API 错误（502）
   - LLM API 超时（504）

### 7.2 错误处理流程

```
错误发生
  ↓
捕获错误（try-catch）
  ↓
记录日志（logger）
  ↓
转换为统一错误格式
  ↓
返回错误响应
```

### 7.3 错误日志

- 记录错误堆栈
- 记录请求上下文（userId, agentId, 请求参数等）
- 记录错误发生时间
- 区分错误级别（ERROR, WARN, INFO）

---

## 8. 安全设计

### 8.1 数据验证

- **输入验证**：所有用户输入都进行验证
- **SQL 注入防护**：使用参数化查询（mysql2）
- **XSS 防护**：前端和后端都进行内容转义

### 8.2 权限控制

- **V1**：简单的 userId 验证
- **数据隔离**：确保用户只能访问自己的数据

### 8.3 API 安全

- **HTTPS**：生产环境使用 HTTPS
- **CORS**：配置正确的 CORS 策略

---

## 9. 性能优化

### 9.1 数据库优化

- **索引优化**：在常用查询字段上建立索引
- **查询优化**：避免全表扫描，使用合适的 WHERE 条件
- **连接池**：使用 mysql2 连接池管理连接

### 9.2 前端优化

- **代码分割**：Vite 自动代码分割
- **静态资源缓存**：Nginx 配置静态资源缓存
- **SPA 路由优化**：Nginx 配置支持 SPA 路由

### 9.3 异步处理

- **消息异步处理**：LLM API 调用异步处理，不阻塞用户请求
- **日志记录**：异步记录日志，不阻塞主流程

---

## 10. 部署架构

### 10.1 开发环境

```
前端 (localhost:3000, Vite Dev Server)
  ↓
后端 (localhost:8000, Node.js)
  ↓
数据库 (localhost:3306, MySQL)
```

### 10.2 生产环境（Docker）

```
┌─────────────┐
│   Nginx      │ (反向代理)
└─────┬───────┘
      │
      ├──────────┬──────────┐
      │          │          │
┌─────▼──┐  ┌────▼────┐  ┌─▼─────┐
│ 前端   │  │ 后端    │  │ MySQL │
│容器    │  │容器     │  │容器   │
└────────┘  └─────────┘  └───────┘
```

**Docker Compose 配置**：

```yaml
services:
  frontend:
    build: ./npc-frontend
    ports:
      - "80:80"
  
  backend:
    build: ./npc-backend
    ports:
      - "8000:8000"
    environment:
      - DB_HOST=mysql
      - DB_USER=root
      - DB_PASSWORD=${DB_PASSWORD}
  
  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}
      - MYSQL_DATABASE=npc_db
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
```

### 10.3 SPA 路由支持

**前端容器 Nginx 配置**（`npc-frontend/nginx.conf`）：

```nginx
server {
    listen 80;
    root /usr/share/nginx/html;
    index index.html;

    # SPA 路由支持：所有请求都重定向到 index.html
    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

**主 Nginx 反向代理配置**（`nginx/conf.d/default.conf`）：

```nginx
# API 请求转发到后端
location /api/ {
    proxy_pass http://backend:8000;
}

# 其他请求转发到前端
location / {
    proxy_pass http://frontend;
    proxy_no_cache $http_upgrade;  # 禁用 HTML 缓存
}
```

---

## 11. 监控和日志

### 11.1 日志系统

- **日志级别**：ERROR, WARN, INFO, DEBUG
- **日志格式**：JSON 格式，便于解析
- **日志内容**：
  - 请求日志：请求路径、方法、参数、响应时间
  - 错误日志：错误堆栈、上下文信息
  - 业务日志：关键业务操作记录

### 11.2 健康检查

- **健康检查端点**：`GET /api/v1/health`
- **用途**：前端自动检测后端可用性、部署监控、负载均衡器健康检查

---

## 12. 扩展性设计

### 12.1 水平扩展

- **无状态设计**：后端服务无状态，可以水平扩展
- **数据库扩展**：支持读写分离（未来版本）

### 12.2 功能扩展

- **插件化设计**：LLM 服务支持插件化，便于添加新的 LLM 提供商
- **事件驱动**：基于事件记录系统，便于添加新功能（如记忆系统、工具调用）

### 12.3 架构演进

- **V1**：单体架构，简单实现
- **V2**：引入缓存、消息队列（如需要）
- **V3**：微服务架构（如需要）

---

## 13. 相关文档

- [功能需求](./03-功能需求.md) - 功能需求详细说明
- [API 设计](./04-API设计.md) - API 接口设计
- [数据模型](./05-数据模型.md) - 数据结构设计
- [开发设计思想](./07-开发设计思想.md) - 前后端分开设计思想
- [产品承诺与原则](./08-产品承诺与原则.md) - 产品核心承诺

---

**文档维护**：架构变更时，需同步更新本文档和相关技术文档。

