# 对话交互增强实现方案

**文档版本**：v1.0  
**最后更新**：2025-01-XX  
**相关文档**：[V1.5 版本规划](./README.md)

---

## 功能概述

实现对话交互的基础增强功能，提升用户使用效率和体验。主要包括：一键复制整段回答、复制代码块、重新生成回答、编辑问题并重新生成。

---

## 功能列表

### 1. 一键复制整段回答

**功能描述**：
- 用户可以一键复制AI生成的整段回答内容
- 快速复制，提升使用效率
- 显示复制成功提示

**技术实现**：

**前端实现**：
- 在每条AI消息下方添加"复制"按钮
- 使用 `navigator.clipboard.writeText()` API 复制文本
- 降级方案：如果 Clipboard API 不可用，使用 `document.execCommand('copy')`
- 显示复制成功提示（Toast 或临时文本提示）

**代码示例**：
```javascript
// 复制功能实现
async function copyToClipboard(text) {
  try {
    // 优先使用 Clipboard API
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // 降级方案：使用 document.execCommand
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      const success = document.execCommand('copy');
      document.body.removeChild(textArea);
      return success;
    }
  } catch (error) {
    console.error('复制失败:', error);
    return false;
  }
}
```

**UI设计**：
- 复制按钮位置：消息气泡右下角或操作栏
- 按钮样式：图标按钮（复制图标）
- 提示方式：复制成功后显示"已复制"提示（2秒后消失）

**优先级**：P0（必备）

---

### 2. 复制代码块（单独复制按钮）

**功能描述**：
- 代码块提供单独的复制按钮
- 方便单独复制代码，不影响整段回答的复制
- 代码块使用代码高亮组件（react-syntax-highlighter）

**技术实现**：

**前端实现**：
- 使用 `react-syntax-highlighter` 组件（已集成）
- 在代码块右上角添加复制按钮
- 复制按钮仅在鼠标悬停时显示（提升UI整洁度）
- 复制代码块内容（不包含代码块标记）

**代码示例**：
```jsx
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';

function CodeBlock({ code, language }) {
  const handleCopy = async () => {
    await copyToClipboard(code);
    // 显示复制成功提示
  };

  return (
    <div className="code-block-container">
      <div className="code-block-header">
        <span className="language-label">{language}</span>
        <button className="copy-button" onClick={handleCopy}>
          复制
        </button>
      </div>
      <SyntaxHighlighter language={language} style={vscDarkPlus}>
        {code}
      </SyntaxHighlighter>
    </div>
  );
}
```

**UI设计**：
- 代码块容器：相对定位
- 复制按钮：绝对定位在右上角
- 悬停显示：使用 CSS `:hover` 伪类
- 按钮样式：小图标按钮，不遮挡代码

**优先级**：P0（必备）

---

### 3. 重新生成回答

**功能描述**：
- 用户对当前回答不满意时，可以重新生成回答
- 使用相同的问题重新调用API
- 可以替换原回答或并排显示多个版本

**技术实现**：

**前端实现**：
- 在每条AI消息下方添加"重新生成"按钮
- 点击后使用相同的问题重新调用消息发送API
- 显示新的回答（默认替换原回答，可选并排显示）
- 显示加载状态（"正在重新生成..."）

**代码示例**：
```jsx
function MessageBubble({ message, onRegenerate }) {
  const [isRegenerating, setIsRegenerating] = useState(false);

  const handleRegenerate = async () => {
    setIsRegenerating(true);
    try {
      // 使用相同的问题重新发送
      const newMessage = await sendMessage({
        userId: message.userId,
        agentId: message.agentId,
        content: message.originalQuestion, // 原始问题
        regenerate: true // 标记为重新生成
      });
      // 替换原消息或添加新消息
      onRegenerate(message.id, newMessage);
    } catch (error) {
      console.error('重新生成失败:', error);
    } finally {
      setIsRegenerating(false);
    }
  };

  return (
    <div className="message-bubble">
      <div className="message-content">{message.content}</div>
      <div className="message-actions">
        <button 
          onClick={handleRegenerate} 
          disabled={isRegenerating}
        >
          {isRegenerating ? '正在重新生成...' : '重新生成'}
        </button>
      </div>
    </div>
  );
}
```

**后端实现**：
- 无需后端改动，复用现有的消息发送API
- 可选：记录重新生成的次数（用于分析）

**UI设计**：
- 重新生成按钮：在消息操作栏中
- 加载状态：显示加载动画或文本提示
- 新回答显示：默认替换原回答，可选并排显示（通过设置切换）

**用户体验**：
- 点击"重新生成"后，原回答显示"正在重新生成..."状态
- 新回答生成后，替换原回答
- 用户可以多次重新生成，直到满意

**优先级**：P0（必备）

---

### 4. 编辑问题并重新生成

**功能描述**：
- 用户可以修改已发送的提问
- 修改后自动重新发送并生成回答
- 可以显示编辑历史（可选）

**技术实现**：

**前端实现**：
- 在用户消息上添加"编辑"按钮
- 点击后允许用户修改消息内容（内联编辑或弹窗编辑）
- 修改后自动重新发送并生成回答
- 可选：显示编辑历史（记录每次编辑）

**代码示例**：
```jsx
function UserMessage({ message, onEdit }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editedContent, setEditedContent] = useState(message.content);

  const handleEdit = () => {
    setIsEditing(true);
  };

  const handleSave = async () => {
    // 更新消息内容
    await updateMessage(message.id, { content: editedContent });
    // 重新发送并生成回答
    await sendMessage({
      userId: message.userId,
      agentId: message.agentId,
      content: editedContent,
      editMessageId: message.id // 标记为编辑
    });
    setIsEditing(false);
  };

  const handleCancel = () => {
    setEditedContent(message.content);
    setIsEditing(false);
  };

  if (isEditing) {
    return (
      <div className="user-message editing">
        <textarea
          value={editedContent}
          onChange={(e) => setEditedContent(e.target.value)}
        />
        <div className="edit-actions">
          <button onClick={handleSave}>保存并重新生成</button>
          <button onClick={handleCancel}>取消</button>
        </div>
      </div>
    );
  }

  return (
    <div className="user-message">
      <div className="message-content">{message.content}</div>
      <button className="edit-button" onClick={handleEdit}>
        编辑
      </button>
    </div>
  );
}
```

**后端实现**（可选）：
- 支持更新已发送的消息内容
- API：`PUT /api/v1/messages/:id` - 更新消息内容
- 记录编辑历史（可选）：在消息表中添加 `edit_history` 字段（JSON数组）

**数据库设计**（可选）：
```sql
-- 如果需要在数据库中记录编辑历史
ALTER TABLE events 
ADD COLUMN edit_history JSON NULL COMMENT '编辑历史（JSON数组）';

-- edit_history 格式示例：
-- [
--   {
--     "content": "原始内容",
--     "editedAt": 1703001234567
--   },
--   {
--     "content": "第一次编辑后的内容",
--     "editedAt": 1703001234568
--   }
-- ]
```

**UI设计**：
- 编辑按钮：在用户消息右上角或操作栏
- 编辑模式：内联编辑（推荐）或弹窗编辑
- 保存按钮：显示"保存并重新生成"
- 取消按钮：恢复原内容

**用户体验**：
- 用户点击"编辑"，消息变为可编辑状态
- 用户修改内容后，点击"保存并重新生成"
- 系统自动重新发送并生成回答
- 可选：显示编辑历史，用户可以查看之前的版本

**优先级**：P0（必备）

---

## 技术架构

### 前端组件结构

```
npc-frontend/src/
├── components/
│   ├── MessageBubble/
│   │   ├── MessageBubble.jsx          # 消息气泡组件
│   │   ├── MessageBubble.module.css  # 样式文件
│   │   └── MessageActions.jsx         # 消息操作栏（复制、重新生成等）
│   ├── CodeBlock/
│   │   ├── CodeBlock.jsx              # 代码块组件（带复制按钮）
│   │   └── CodeBlock.module.css       # 样式文件
│   └── EditMessage/
│       ├── EditMessage.jsx            # 编辑消息组件
│       └── EditMessage.module.css     # 样式文件
└── utils/
    └── clipboard.js                   # 复制工具函数
```

### 工具函数

**clipboard.js**：
```javascript
/**
 * 复制文本到剪贴板
 * @param {string} text - 要复制的文本
 * @returns {Promise<boolean>} 是否成功
 */
export async function copyToClipboard(text) {
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // 降级方案
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      const success = document.execCommand('copy');
      document.body.removeChild(textArea);
      return success;
    }
  } catch (error) {
    console.error('复制失败:', error);
    return false;
  }
}
```

---

## 实现步骤

### 阶段一：复制功能（1-2天）

1. **实现一键复制整段回答**
   - 在 MessageBubble 组件中添加复制按钮
   - 实现复制工具函数
   - 添加复制成功提示
   - 测试各种浏览器兼容性

2. **实现代码块单独复制**
   - 在 CodeBlock 组件中添加复制按钮
   - 实现代码块复制功能
   - 优化UI（悬停显示）
   - 测试代码块复制功能

### 阶段二：重新生成功能（1-2天）

1. **实现重新生成回答**
   - 在 MessageBubble 组件中添加"重新生成"按钮
   - 实现重新生成逻辑
   - 添加加载状态
   - 测试重新生成功能

### 阶段三：编辑问题功能（1-2天）

1. **实现编辑问题**
   - 在 UserMessage 组件中添加"编辑"按钮
   - 实现内联编辑功能
   - 实现保存并重新生成逻辑
   - 测试编辑功能

2. **优化用户体验**
   - 添加编辑历史（可选）
   - 优化UI交互
   - 添加错误处理

**总计**：约 3-5 天

---

## 测试要点

1. **复制功能测试**：
   - 测试复制整段回答（各种长度）
   - 测试复制代码块（各种语言）
   - 测试浏览器兼容性（Chrome、Firefox、Safari、Edge）
   - 测试移动端（iOS、Android）

2. **重新生成功能测试**：
   - 测试重新生成回答
   - 测试多次重新生成
   - 测试加载状态显示
   - 测试错误处理

3. **编辑问题功能测试**：
   - 测试编辑消息内容
   - 测试保存并重新生成
   - 测试取消编辑
   - 测试编辑历史（如果实现）

---

## 注意事项

1. **浏览器兼容性**：
   - Clipboard API 在较新的浏览器中支持良好
   - 需要提供降级方案（document.execCommand）
   - 移动端可能需要特殊处理

2. **用户体验**：
   - 复制成功后要有明确的视觉反馈
   - 重新生成时显示加载状态
   - 编辑功能要简单易用

3. **性能考虑**：
   - 复制功能是同步操作，不会影响性能
   - 重新生成需要调用API，注意错误处理
   - 编辑功能需要实时更新UI

4. **安全性**：
   - 复制功能是前端操作，无需后端验证
   - 重新生成和编辑需要验证用户权限（如果实现后端支持）

---

## 相关文档

- [V1.5 版本规划](./README.md)
- [未来版本规划](../未来版本规划.md)
- [V1 功能需求](../v1/03-功能需求.md)

---

**文档维护**：功能实现时，需同步更新本文档和代码注释。

