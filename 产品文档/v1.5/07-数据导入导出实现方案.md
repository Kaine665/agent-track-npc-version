# 数据导入导出功能实现方案

**文档版本**：v1.0  
**最后更新**：2025-01-XX  
**相关文档**：[V1.5 版本规划](./README.md)

---

## 功能概述

支持导出对话历史和 NPC 配置，支持导入对话历史（包含 prompt、模型信息），并处理模型兼容性问题。

---

## 技术方案

### 导出格式

- **JSON**：完整数据结构，便于程序处理
- **TXT**：纯文本格式，便于阅读
- **Markdown**：格式化文本，便于分享

### 导入格式

- **JSON**：支持导入对话历史和 NPC 配置
- 模型兼容性处理：如果模型不存在，提供替代方案

---

## 实现步骤

#### 1. 导出服务

**文件**：`npc-backend/services/ExportService.js`

```javascript
/**
 * ============================================
 * 导出服务 (ExportService.js)
 * ============================================
 */

const eventRepository = require('../repositories/EventRepository');
const agentRepository = require('../repositories/AgentRepository');
const sessionRepository = require('../repositories/SessionRepository');

/**
 * 导出对话历史（JSON 格式）
 */
async function exportConversationsJSON(userId, options = {}) {
  const { agentId, sessionId, startTime, endTime } = options;

  // 查询对话事件
  let events;
  if (sessionId) {
    // 导出指定会话
    events = await eventRepository.findBySessionId(sessionId);
  } else if (agentId) {
    // 导出指定 NPC 的所有对话
    events = await eventRepository.findByAgentId(agentId, {
      startTime,
      endTime,
    });
  } else {
    // 导出用户的所有对话
    events = await eventRepository.findByUserId(userId, {
      startTime,
      endTime,
    });
  }

  // 获取 NPC 信息
  const agentIds = [...new Set(events.map(e => e.agentId))];
  const agents = await Promise.all(
    agentIds.map(id => agentRepository.findById(id))
  );

  // 构建导出数据
  const exportData = {
    version: '1.0',
    exportTime: new Date().toISOString(),
    userId,
    agents: agents.filter(Boolean).map(agent => ({
      id: agent.id,
      name: agent.name,
      description: agent.description,
      systemPrompt: agent.systemPrompt,
      model: agent.model,
      provider: agent.provider,
    })),
    conversations: events.map(event => ({
      id: event.id,
      sessionId: event.sessionId,
      agentId: event.agentId,
      type: event.type,
      content: event.content,
      metadata: event.metadata ? JSON.parse(event.metadata) : null,
      createdAt: event.createdAt,
    })),
  };

  return JSON.stringify(exportData, null, 2);
}

/**
 * 导出对话历史（TXT 格式）
 */
async function exportConversationsTXT(userId, options = {}) {
  const jsonData = await exportConversationsJSON(userId, options);
  const data = JSON.parse(jsonData);

  let text = `对话历史导出\n`;
  text += `导出时间：${data.exportTime}\n`;
  text += `用户ID：${data.userId}\n`;
  text += `\n${'='.repeat(50)}\n\n`;

  // 按会话分组
  const sessions = {};
  data.conversations.forEach(conv => {
    if (!sessions[conv.sessionId]) {
      sessions[conv.sessionId] = [];
    }
    sessions[conv.sessionId].push(conv);
  });

  // 输出每个会话
  Object.entries(sessions).forEach(([sessionId, conversations]) => {
    const agent = data.agents.find(a => 
      conversations.some(c => c.agentId === a.id)
    );
    
    text += `会话：${sessionId}\n`;
    text += `NPC：${agent?.name || '未知'}\n`;
    text += `\n${'-'.repeat(50)}\n\n`;

    conversations
      .sort((a, b) => a.createdAt - b.createdAt)
      .forEach(conv => {
        const role = conv.type === 'user_message' ? '用户' : 'NPC';
        const time = new Date(conv.createdAt).toLocaleString();
        text += `[${time}] ${role}：\n${conv.content}\n\n`;
      });

    text += `\n${'='.repeat(50)}\n\n`;
  });

  return text;
}

/**
 * 导出对话历史（Markdown 格式）
 */
async function exportConversationsMarkdown(userId, options = {}) {
  const jsonData = await exportConversationsJSON(userId, options);
  const data = JSON.parse(jsonData);

  let markdown = `# 对话历史导出\n\n`;
  markdown += `**导出时间**：${data.exportTime}\n`;
  markdown += `**用户ID**：${data.userId}\n\n`;
  markdown += `---\n\n`;

  // 按会话分组
  const sessions = {};
  data.conversations.forEach(conv => {
    if (!sessions[conv.sessionId]) {
      sessions[conv.sessionId] = [];
    }
    sessions[conv.sessionId].push(conv);
  });

  // 输出每个会话
  Object.entries(sessions).forEach(([sessionId, conversations], index) => {
    const agent = data.agents.find(a => 
      conversations.some(c => c.agentId === a.id)
    );
    
    markdown += `## 会话 ${index + 1}：${agent?.name || '未知'}\n\n`;
    markdown += `**会话ID**：\`${sessionId}\`\n\n`;

    conversations
      .sort((a, b) => a.createdAt - b.createdAt)
      .forEach(conv => {
        const role = conv.type === 'user_message' ? '**用户**' : '**NPC**';
        const time = new Date(conv.createdAt).toLocaleString();
        markdown += `### ${role} - ${time}\n\n`;
        markdown += `${conv.content}\n\n`;
        markdown += `---\n\n`;
      });
  });

  return markdown;
}

/**
 * 导出 NPC 配置
 */
async function exportAgents(userId, agentIds = []) {
  let agents;
  if (agentIds.length > 0) {
    agents = await Promise.all(
      agentIds.map(id => agentRepository.findById(id))
    );
  } else {
    agents = await agentRepository.findByUserId(userId);
  }

  // 过滤掉已删除的
  agents = agents.filter(agent => agent && !agent.deleted);

  const exportData = {
    version: '1.0',
    exportTime: new Date().toISOString(),
    userId,
    agents: agents.map(agent => ({
      id: agent.id,
      name: agent.name,
      description: agent.description,
      systemPrompt: agent.systemPrompt,
      model: agent.model,
      provider: agent.provider,
      createdAt: agent.createdAt,
    })),
  };

  return JSON.stringify(exportData, null, 2);
}

module.exports = {
  exportConversationsJSON,
  exportConversationsTXT,
  exportConversationsMarkdown,
  exportAgents,
};
```

#### 2. 导入服务

**文件**：`npc-backend/services/ImportService.js`

```javascript
/**
 * ============================================
 * 导入服务 (ImportService.js)
 * ============================================
 */

const eventRepository = require('../repositories/EventRepository');
const agentRepository = require('../repositories/AgentRepository');
const sessionRepository = require('../repositories/SessionRepository');
const llmService = require('../services/LLMService');

/**
 * 获取可用模型列表
 */
async function getAvailableModels() {
  // 从 LLMService 获取可用模型
  const models = await llmService.getAvailableModels();
  return models;
}

/**
 * 查找替代模型
 *
 * @param {string} originalModel - 原始模型
 * @param {string} provider - 提供商
 * @returns {Object} { model, provider, reason }
 */
async function findAlternativeModel(originalModel, provider) {
  const availableModels = await getAvailableModels();

  // 1. 尝试找到相同名称的模型
  const exactMatch = availableModels.find(
    m => m.id === originalModel && m.provider === provider
  );
  if (exactMatch) {
    return {
      model: exactMatch.id,
      provider: exactMatch.provider,
      reason: '模型可用',
      originalModel,
      originalProvider: provider,
    };
  }

  // 2. 尝试找到相同提供商的类似模型
  const sameProviderModels = availableModels.filter(
    m => m.provider === provider
  );
  if (sameProviderModels.length > 0) {
    // 选择第一个可用模型
    const alternative = sameProviderModels[0];
    return {
      model: alternative.id,
      provider: alternative.provider,
      reason: `原模型 ${originalModel} 不可用，已替换为 ${alternative.id}`,
      originalModel,
      originalProvider: provider,
    };
  }

  // 3. 使用默认模型
  const defaultModel = availableModels[0];
  return {
    model: defaultModel.id,
    provider: defaultModel.provider,
    reason: `原模型 ${originalModel} (${provider}) 不可用，已替换为默认模型 ${defaultModel.id}`,
    originalModel,
    originalProvider: provider,
  };
}

/**
 * 导入对话历史
 *
 * @param {string} userId - 用户ID
 * @param {Object} importData - 导入数据
 * @param {Object} options - 导入选项
 * @returns {Promise<Object>} 导入结果
 */
async function importConversations(userId, importData, options = {}) {
  const { createNewAgents = false, modelMapping = {} } = options;

  // 验证导入数据格式
  if (!importData.conversations || !Array.isArray(importData.conversations)) {
    const error = new Error('无效的导入数据格式');
    error.code = 'INVALID_FORMAT';
    throw error;
  }

  const results = {
    imported: 0,
    skipped: 0,
    errors: [],
    modelMappings: [],
  };

  // 处理 NPC 配置
  const agentMap = {}; // 原始ID -> 新ID映射
  if (importData.agents && Array.isArray(importData.agents)) {
    for (const agentData of importData.agents) {
      try {
        // 检查模型是否可用
        let modelInfo = {
          model: agentData.model,
          provider: agentData.provider,
        };

        // 检查模型映射
        const mappingKey = `${agentData.provider}:${agentData.model}`;
        if (modelMapping[mappingKey]) {
          modelInfo = {
            model: modelMapping[mappingKey].model,
            provider: modelMapping[mappingKey].provider,
            reason: '使用用户指定的模型映射',
          };
        } else {
          // 自动查找替代模型
          modelInfo = await findAlternativeModel(
            agentData.model,
            agentData.provider
          );
        }

        // 记录模型映射
        if (modelInfo.originalModel) {
          results.modelMappings.push(modelInfo);
        }

        // 创建或查找 NPC
        let agent;
        if (createNewAgents) {
          // 创建新 NPC
          agent = await agentRepository.create({
            id: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            userId,
            name: agentData.name,
            description: agentData.description,
            systemPrompt: agentData.systemPrompt,
            model: modelInfo.model,
            provider: modelInfo.provider,
            createdAt: Date.now(),
          });
        } else {
          // 查找现有 NPC（根据名称匹配）
          const existingAgents = await agentRepository.findByUserId(userId);
          agent = existingAgents.find(a => a.name === agentData.name);
          
          if (!agent) {
            // 如果不存在，创建新 NPC
            agent = await agentRepository.create({
              id: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              userId,
              name: agentData.name,
              description: agentData.description,
              systemPrompt: agentData.systemPrompt,
              model: modelInfo.model,
              provider: modelInfo.provider,
              createdAt: Date.now(),
            });
          }
        }

        agentMap[agentData.id] = agent.id;
      } catch (error) {
        results.errors.push({
          type: 'agent',
          id: agentData.id,
          error: error.message,
        });
      }
    }
  }

  // 处理对话历史
  for (const conv of importData.conversations) {
    try {
      // 查找或创建会话
      let session = await sessionRepository.findBySessionId(conv.sessionId);
      if (!session) {
        const agentId = agentMap[conv.agentId] || conv.agentId;
        session = await sessionRepository.create({
          id: conv.sessionId,
          userId,
          agentId,
          createdAt: conv.createdAt || Date.now(),
        });
      }

      // 创建事件
      await eventRepository.create({
        id: conv.id || `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        sessionId: session.id,
        userId,
        agentId: session.agentId,
        type: conv.type,
        content: conv.content,
        metadata: conv.metadata ? JSON.stringify(conv.metadata) : null,
        createdAt: conv.createdAt || Date.now(),
      });

      results.imported++;
    } catch (error) {
      results.skipped++;
      results.errors.push({
        type: 'conversation',
        id: conv.id,
        error: error.message,
      });
    }
  }

  return results;
}

module.exports = {
  importConversations,
  findAlternativeModel,
  getAvailableModels,
};
```

#### 3. 路由

**文件**：`npc-backend/routes/export.js`

```javascript
const express = require('express');
const router = express.Router();
const exportService = require('../services/ExportService');
const importService = require('../services/ImportService');
const { authenticate } = require('../middleware/auth');

router.use(authenticate);

/**
 * 导出对话历史
 * GET /api/v1/export/conversations?format=json&agentId=xxx&sessionId=xxx
 */
router.get('/conversations', async (req, res) => {
  try {
    const userId = req.user.userId;
    const { format = 'json', agentId, sessionId, startTime, endTime } = req.query;

    let content;
    let contentType;
    let filename;

    switch (format) {
      case 'json':
        content = await exportService.exportConversationsJSON(userId, {
          agentId,
          sessionId,
          startTime: startTime ? parseInt(startTime) : undefined,
          endTime: endTime ? parseInt(endTime) : undefined,
        });
        contentType = 'application/json';
        filename = `conversations_${Date.now()}.json`;
        break;
      case 'txt':
        content = await exportService.exportConversationsTXT(userId, {
          agentId,
          sessionId,
          startTime: startTime ? parseInt(startTime) : undefined,
          endTime: endTime ? parseInt(endTime) : undefined,
        });
        contentType = 'text/plain';
        filename = `conversations_${Date.now()}.txt`;
        break;
      case 'markdown':
        content = await exportService.exportConversationsMarkdown(userId, {
          agentId,
          sessionId,
          startTime: startTime ? parseInt(startTime) : undefined,
          endTime: endTime ? parseInt(endTime) : undefined,
        });
        contentType = 'text/markdown';
        filename = `conversations_${Date.now()}.md`;
        break;
      default:
        return res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_FORMAT',
            message: '不支持的导出格式',
          },
        });
    }

    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(content);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'SYSTEM_ERROR',
        message: error.message,
      },
    });
  }
});

/**
 * 导出 NPC 配置
 * GET /api/v1/export/agents?agentIds=id1,id2,id3
 */
router.get('/agents', async (req, res) => {
  try {
    const userId = req.user.userId;
    const { agentIds } = req.query;

    const ids = agentIds ? agentIds.split(',') : [];
    const content = await exportService.exportAgents(userId, ids);

    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', `attachment; filename="agents_${Date.now()}.json"`);
    res.send(content);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'SYSTEM_ERROR',
        message: error.message,
      },
    });
  }
});

/**
 * 导入对话历史
 * POST /api/v1/export/import
 */
router.post('/import', async (req, res) => {
  try {
    const userId = req.user.userId;
    const { data, options = {} } = req.body;

    const result = await importService.importConversations(userId, data, options);

    res.json({
      success: true,
      data: result,
    });
  } catch (error) {
    const code = error.code || 'SYSTEM_ERROR';
    const status = code === 'INVALID_FORMAT' ? 400 : 500;
    
    res.status(status).json({
      success: false,
      error: {
        code,
        message: error.message,
      },
    });
  }
});

module.exports = router;
```

---

## 前端适配

### 1. 导出功能

**文件**：`npc-frontend/src/components/ExportButton/ExportButton.jsx`

```javascript
import { Button, Dropdown, Menu } from 'antd';
import { DownloadOutlined } from '@ant-design/icons';
import api from '../../api';

const ExportButton = ({ agentId, sessionId }) => {
  const handleExport = async (format) => {
    try {
      const params = new URLSearchParams({
        format,
        ...(agentId && { agentId }),
        ...(sessionId && { sessionId }),
      });

      const response = await fetch(
        `${api.baseURL}/export/conversations?${params}`,
        {
          headers: {
            'Authorization': `Bearer ${api.token}`,
          },
        }
      );

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `conversations_${Date.now()}.${format}`;
      a.click();
      window.URL.revokeObjectURL(url);
    } catch (error) {
      message.error('导出失败');
    }
  };

  const menu = (
    <Menu onClick={({ key }) => handleExport(key)}>
      <Menu.Item key="json">导出为 JSON</Menu.Item>
      <Menu.Item key="txt">导出为 TXT</Menu.Item>
      <Menu.Item key="markdown">导出为 Markdown</Menu.Item>
    </Menu>
  );

  return (
    <Dropdown overlay={menu}>
      <Button icon={<DownloadOutlined />}>
        导出
      </Button>
    </Dropdown>
  );
};
```

### 2. 导入功能

**文件**：`npc-frontend/src/components/ImportModal/ImportModal.jsx`

```javascript
import { Modal, Upload, message, Alert } from 'antd';
import { InboxOutlined } from '@ant-design/icons';
import api from '../../api';

const ImportModal = ({ visible, onCancel, onSuccess }) => {
  const [loading, setLoading] = useState(false);
  const [modelMappings, setModelMappings] = useState([]);

  const handleImport = async (file) => {
    try {
      setLoading(true);
      const text = await file.text();
      const data = JSON.parse(text);

      const response = await api.export.import(data, {
        createNewAgents: true,
      });

      if (response.success) {
        setModelMappings(response.data.modelMappings);
        message.success(
          `导入成功：${response.data.imported} 条对话，${response.data.skipped} 条跳过`
        );
        onSuccess();
      }
    } catch (error) {
      message.error('导入失败：' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal
      title="导入对话历史"
      visible={visible}
      onCancel={onCancel}
      footer={null}
    >
      {modelMappings.length > 0 && (
        <Alert
          type="info"
          message="模型映射"
          description={
            <ul>
              {modelMappings.map((mapping, index) => (
                <li key={index}>
                  {mapping.originalModel} ({mapping.originalProvider}) →{' '}
                  {mapping.model} ({mapping.provider})
                  <br />
                  <small>{mapping.reason}</small>
                </li>
              ))}
            </ul>
          }
          style={{ marginBottom: 16 }}
        />
      )}

      <Upload.Dragger
        accept=".json"
        beforeUpload={(file) => {
          handleImport(file);
          return false; // 阻止自动上传
        }}
        loading={loading}
      >
        <p className="ant-upload-drag-icon">
          <InboxOutlined />
        </p>
        <p className="ant-upload-text">点击或拖拽文件到此区域上传</p>
        <p className="ant-upload-hint">支持 JSON 格式的对话历史文件</p>
      </Upload.Dragger>
    </Modal>
  );
};
```

---

## 测试要点

1. **导出功能**：验证不同格式的导出是否正确
2. **导入功能**：验证对话历史是否正确导入
3. **模型兼容性**：验证模型不存在时的替代方案
4. **数据完整性**：验证导入后的数据是否完整
5. **错误处理**：验证无效格式、缺失字段等错误处理

---

## 注意事项

1. **文件大小**：
   - 大量对话历史可能导致文件很大
   - 考虑添加分页导出或流式导出

2. **模型映射**：
   - 模型映射信息应该保存，便于后续查询
   - 可以添加模型映射配置界面

3. **数据验证**：
   - 导入前应该验证数据格式
   - 验证必填字段和数据完整性

4. **性能优化**：
   - 大量数据导入可能较慢，考虑异步处理
   - 可以添加导入进度提示

