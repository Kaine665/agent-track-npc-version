# 数据备份实现方案

**文档版本**：v1.0  
**最后更新**：2025-01-XX  
**相关文档**：[V1.5 版本规划](./README.md)

---

## 功能概述

实现定期数据备份机制，保护用户数据安全。

---

## 技术方案

### 实现策略

- **备份工具**：MySQL `mysqldump`（原生工具，零成本）
- **备份频率**：每日全量备份
- **备份保留**：保留最近 7 天
- **备份验证**：文件大小和完整性检查

---

## 实现步骤

#### 1. 备份脚本

**文件**：`npc-backend/scripts/backup-database.js`

```javascript
/**
 * ============================================
 * 数据库备份脚本 (backup-database.js)
 * ============================================
 *
 * 【文件职责】
 * 执行数据库备份，使用 mysqldump
 *
 * 【主要功能】
 * 1. 执行全量备份
 * 2. 备份文件验证
 * 3. 清理旧备份
 *
 * 【使用方法】
 * node scripts/backup-database.js
 * 或通过 cron 定时执行
 */

const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const { logger } = require('../utils/logger');

// 确保配置已加载
require('dotenv').config();

const BACKUP_DIR = path.join(__dirname, '../backups');
const DB_CONFIG = {
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 3306,
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'npc_db',
};

// 确保备份目录存在
if (!fs.existsSync(BACKUP_DIR)) {
  fs.mkdirSync(BACKUP_DIR, { recursive: true });
}

/**
 * 执行数据库备份
 *
 * @returns {Promise<string>} 备份文件路径
 */
function backupDatabase() {
  return new Promise((resolve, reject) => {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFile = path.join(BACKUP_DIR, `npc_db_${timestamp}.sql`);

    // 构建 mysqldump 命令
    // 注意：密码直接写在命令中（mysqldump 不支持环境变量）
    // 生产环境建议使用配置文件或 .my.cnf
    const command = `mysqldump -h ${DB_CONFIG.host} -P ${DB_CONFIG.port} -u ${DB_CONFIG.user} -p${DB_CONFIG.password} ${DB_CONFIG.database} > "${backupFile}"`;

    logger.info('Starting database backup', {
      host: DB_CONFIG.host,
      database: DB_CONFIG.database,
      backupFile,
    });

    exec(command, (error, stdout, stderr) => {
      if (error) {
        logger.error('Backup failed', {
          error: error.message,
          stderr,
        });
        return reject(error);
      }

      // 验证备份文件
      try {
        const stats = fs.statSync(backupFile);
        
        if (stats.size < 1000) {
          // 备份文件太小，可能失败
          logger.error('Backup file too small', {
            size: stats.size,
            backupFile,
          });
          fs.unlinkSync(backupFile); // 删除无效备份
          return reject(new Error('Backup file invalid (too small)'));
        }

        // 验证备份文件内容（检查是否包含 SQL 语句）
        const content = fs.readFileSync(backupFile, 'utf8');
        if (!content.includes('CREATE TABLE') && !content.includes('INSERT INTO')) {
          logger.error('Backup file invalid (no SQL content)', {
            backupFile,
          });
          fs.unlinkSync(backupFile);
          return reject(new Error('Backup file invalid (no SQL content)'));
        }

        logger.info('Backup completed successfully', {
          backupFile,
          size: stats.size,
          sizeMB: (stats.size / 1024 / 1024).toFixed(2),
        });

        resolve(backupFile);
      } catch (fileError) {
        logger.error('Failed to verify backup file', {
          error: fileError.message,
          backupFile,
        });
        reject(fileError);
      }
    });
  });
}

/**
 * 清理旧备份（保留最近 N 天）
 *
 * @param {number} daysToKeep - 保留天数（默认 7 天）
 */
function cleanOldBackups(daysToKeep = 7) {
  try {
    const files = fs.readdirSync(BACKUP_DIR);
    const cutoffTime = Date.now() - daysToKeep * 24 * 60 * 60 * 1000;

    let deletedCount = 0;
    let totalSize = 0;

    files.forEach(file => {
      const filePath = path.join(BACKUP_DIR, file);
      const stats = fs.statSync(filePath);

      if (stats.mtimeMs < cutoffTime) {
        totalSize += stats.size;
        fs.unlinkSync(filePath);
        deletedCount++;
        logger.info('Deleted old backup', {
          file,
          age: Math.floor((Date.now() - stats.mtimeMs) / (24 * 60 * 60 * 1000)) + ' days',
        });
      }
    });

    if (deletedCount > 0) {
      logger.info('Old backups cleaned', {
        deletedCount,
        freedSpaceMB: (totalSize / 1024 / 1024).toFixed(2),
      });
    }
  } catch (error) {
    logger.error('Failed to clean old backups', {
      error: error.message,
    });
  }
}

/**
 * 主函数
 */
async function main() {
  try {
    // 执行备份
    const backupFile = await backupDatabase();

    // 清理旧备份
    cleanOldBackups(7);

    console.log('✅ Backup completed:', backupFile);
    process.exit(0);
  } catch (error) {
    console.error('❌ Backup failed:', error.message);
    process.exit(1);
  }
}

// 如果直接运行此脚本，执行主函数
if (require.main === module) {
  main();
}

module.exports = {
  backupDatabase,
  cleanOldBackups,
};
```

#### 2. 定时任务配置

**方式一：使用 Node.js 定时任务（推荐）**

**文件**：`npc-backend/scripts/setup-backup-scheduler.js`

```javascript
/**
 * 设置备份定时任务（使用 node-cron）
 */

const cron = require('node-cron');
const { backupDatabase, cleanOldBackups } = require('./backup-database');
const { logger } = require('../utils/logger');

// 每天凌晨 2 点执行备份
cron.schedule('0 2 * * *', async () => {
  logger.info('Scheduled backup started');
  try {
    await backupDatabase();
    cleanOldBackups(7);
    logger.info('Scheduled backup completed');
  } catch (error) {
    logger.error('Scheduled backup failed', {
      error: error.message,
    });
  }
});

logger.info('Backup scheduler started (daily at 2:00 AM)');
```

**方式二：使用系统 cron（Linux/Mac）**

```bash
# 编辑 crontab
crontab -e

# 添加以下行（每天凌晨 2 点执行）
0 2 * * * cd /path/to/npc-backend && node scripts/backup-database.js >> logs/backup.log 2>&1
```

**方式三：使用 Windows 任务计划程序（Windows）**

创建 PowerShell 脚本：`scripts/backup-database.ps1`

```powershell
# 切换到项目目录
cd C:\path\to\npc-backend

# 执行备份
node scripts/backup-database.js
```

然后在 Windows 任务计划程序中设置定时执行。

#### 3. 备份恢复脚本（可选）

**文件**：`npc-backend/scripts/restore-database.js`

```javascript
/**
 * ============================================
 * 数据库恢复脚本 (restore-database.js)
 * ============================================
 *
 * 【使用方法】
 * node scripts/restore-database.js <backup-file>
 */

const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const { logger } = require('../utils/logger');

require('dotenv').config();

const DB_CONFIG = {
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 3306,
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'npc_db',
};

function restoreDatabase(backupFile) {
  return new Promise((resolve, reject) => {
    if (!fs.existsSync(backupFile)) {
      return reject(new Error(`Backup file not found: ${backupFile}`));
    }

    logger.warn('Restoring database', {
      backupFile,
      database: DB_CONFIG.database,
    });

    // 构建恢复命令
    const command = `mysql -h ${DB_CONFIG.host} -P ${DB_CONFIG.port} -u ${DB_CONFIG.user} -p${DB_CONFIG.password} ${DB_CONFIG.database} < "${backupFile}"`;

    exec(command, (error, stdout, stderr) => {
      if (error) {
        logger.error('Restore failed', {
          error: error.message,
          stderr,
        });
        return reject(error);
      }

      logger.info('Database restored successfully', {
        backupFile,
      });

      resolve();
    });
  });
}

// 主函数
async function main() {
  const backupFile = process.argv[2];

  if (!backupFile) {
    console.error('Usage: node restore-database.js <backup-file>');
    process.exit(1);
  }

  try {
    await restoreDatabase(backupFile);
    console.log('✅ Database restored successfully');
    process.exit(0);
  } catch (error) {
    console.error('❌ Restore failed:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = {
  restoreDatabase,
};
```

#### 4. package.json 脚本

**文件**：`npc-backend/package.json`

```json
{
  "scripts": {
    "backup": "node scripts/backup-database.js",
    "backup:schedule": "node scripts/setup-backup-scheduler.js",
    "restore": "node scripts/restore-database.js"
  }
}
```

---

## 备份文件管理

### 备份文件命名规则

```
npc_db_2025-01-15T02-00-00-000Z.sql
```

格式：`数据库名_时间戳.sql`

### 备份文件结构

```
backups/
├── npc_db_2025-01-08T02-00-00-000Z.sql
├── npc_db_2025-01-09T02-00-00-000Z.sql
├── ...
└── npc_db_2025-01-15T02-00-00-000Z.sql
```

---

## 扩展性设计

### 未来接入云存储（可选）

```javascript
const AWS = require('aws-sdk');
const s3 = new AWS.S3();

async function uploadToS3(backupFile) {
  const fileContent = fs.readFileSync(backupFile);
  const fileName = path.basename(backupFile);

  await s3.putObject({
    Bucket: process.env.S3_BACKUP_BUCKET,
    Key: `backups/${fileName}`,
    Body: fileContent,
  }).promise();

  logger.info('Backup uploaded to S3', { fileName });
}
```

### 未来增量备份（可选）

使用 MySQL binlog 实现增量备份：

```javascript
// 启用 binlog
// 在 MySQL 配置文件中添加：
// log-bin=mysql-bin
// binlog-format=ROW

// 定期备份 binlog 文件
```

---

## 测试要点

1. **备份功能**：验证备份是否正确执行
2. **备份验证**：验证备份文件是否有效
3. **清理功能**：验证旧备份是否正确清理
4. **恢复功能**：验证备份是否可以正确恢复
5. **定时任务**：验证定时任务是否正常执行

---

## 注意事项

1. **密码安全**：
   - mysqldump 命令中包含密码，注意保护脚本文件权限
   - 生产环境建议使用配置文件（.my.cnf）

2. **磁盘空间**：
   - 定期检查备份目录磁盘空间
   - 设置合理的备份保留天数

3. **备份验证**：
   - 定期测试备份恢复功能
   - 确保备份文件完整可用

4. **备份频率**：
   - 当前版本：每日全量备份
   - 未来可以根据数据量调整频率

5. **监控告警**（可选）：
   - 可以添加备份失败告警
   - 监控备份文件大小异常

6. **跨平台兼容**：
   - Windows 和 Linux 的 mysqldump 命令相同
   - 注意路径分隔符的差异

