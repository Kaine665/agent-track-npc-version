# 错误日志和监控实现方案

**文档版本**：v1.0  
**最后更新**：2025-01-XX  
**相关文档**：[V1.5 版本规划](./README.md)

---

## 功能概述

实现结构化日志记录和错误追踪，便于问题排查和系统监控。

---

## 技术方案

### 依赖库

```json
{
  "winston": "^3.11.0"
}
```

### 实现策略

- **当前版本**：文件 + 控制台输出（简单、零成本）
- **未来扩展**：可接入 ELK、Sentry、Grafana（日志格式已统一）

---

## 实现步骤

#### 1. 日志工具类

**文件**：`npc-backend/utils/logger.js`

```javascript
/**
 * ============================================
 * 日志工具 (logger.js)
 * ============================================
 *
 * 【文件职责】
 * 提供结构化日志记录功能
 *
 * 【主要功能】
 * 1. 结构化日志（JSON 格式）
 * 2. 文件输出 + 控制台输出
 * 3. 日志级别管理
 * 4. 日志轮转（可选）
 *
 * 【扩展性】
 * - 当前：文件 + 控制台（winston）
 * - 未来：可接入 ELK、Sentry、Grafana，日志格式已统一
 */

const winston = require('winston');
const path = require('path');
const fs = require('fs');

// 确保日志目录存在
const logDir = path.join(__dirname, '../logs');
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

/**
 * 创建 Winston Logger 实例
 */
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info', // 日志级别
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.errors({ stack: true }), // 记录错误堆栈
    winston.format.json() // JSON 格式，便于后续解析
  ),
  defaultMeta: {
    service: 'npc-backend',
    environment: process.env.NODE_ENV || 'development',
  },
  transports: [
    // 错误日志单独文件
    new winston.transports.File({
      filename: path.join(logDir, 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5, // 保留5个文件
    }),
    // 所有日志
    new winston.transports.File({
      filename: path.join(logDir, 'combined.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5, // 保留5个文件
    }),
  ],
});

// 开发环境添加控制台输出
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    ),
  }));
}

/**
 * API 调用日志记录
 *
 * @param {Object} req - Express 请求对象
 * @param {Object} res - Express 响应对象
 * @param {number} responseTime - 响应时间（毫秒）
 */
function logAPICall(req, res, responseTime) {
  const logData = {
    type: 'api_call',
    method: req.method,
    path: req.path,
    statusCode: res.statusCode,
    responseTime,
    userId: req.user?.userId,
    ip: req.ip || req.connection.remoteAddress,
    userAgent: req.headers['user-agent'],
  };

  // 根据状态码选择日志级别
  if (res.statusCode >= 500) {
    logger.error('API Error', logData);
  } else if (res.statusCode >= 400) {
    logger.warn('API Warning', logData);
  } else {
    logger.info('API Call', logData);
  }
}

/**
 * 错误日志记录
 *
 * @param {Error} error - 错误对象
 * @param {Object} context - 上下文信息
 */
function logError(error, context = {}) {
  logger.error('Error occurred', {
    type: 'error',
    message: error.message,
    stack: error.stack,
    code: error.code,
    ...context,
  });
}

/**
 * LLM API 调用日志
 *
 * @param {Object} data - LLM 调用数据
 */
function logLLMCall(data) {
  logger.info('LLM API Call', {
    type: 'llm_call',
    ...data,
  });
}

/**
 * 数据库操作日志
 *
 * @param {Object} data - 数据库操作数据
 */
function logDatabaseOperation(data) {
  logger.debug('Database Operation', {
    type: 'database',
    ...data,
  });
}

module.exports = {
  logger,
  logAPICall,
  logError,
  logLLMCall,
  logDatabaseOperation,
};
```

#### 2. 日志中间件

**文件**：`npc-backend/middleware/logger.js`

```javascript
/**
 * ============================================
 * 日志中间件 (logger.js)
 * ============================================
 *
 * 【文件职责】
 * 记录 API 请求和响应日志
 */

const { logAPICall } = require('../utils/logger');

/**
 * API 请求日志中间件
 *
 * 【工作流程】
 * 1. 记录请求开始时间
 * 2. 监听响应完成事件
 * 3. 计算响应时间
 * 4. 记录日志
 */
function requestLogger(req, res, next) {
  const startTime = Date.now();

  // 监听响应完成事件
  res.on('finish', () => {
    const responseTime = Date.now() - startTime;
    logAPICall(req, res, responseTime);
  });

  next();
}

module.exports = {
  requestLogger,
};
```

#### 3. 错误处理中间件（更新）

**文件**：`npc-backend/middleware/errorHandler.js`

```javascript
const { logError } = require('../utils/logger');

function errorHandler(err, req, res, next) {
  // 记录错误日志
  logError(err, {
    method: req.method,
    path: req.path,
    userId: req.user?.userId,
    ip: req.ip,
    body: req.body,
    query: req.query,
  });

  // 返回错误响应
  const code = err.code || 'SYSTEM_ERROR';
  const status = err.status || 500;
  const message = err.message || 'Internal Server Error';

  res.status(status).json({
    success: false,
    error: {
      code,
      message: process.env.NODE_ENV === 'production' 
        ? '服务器错误' 
        : message,
    },
    timestamp: Date.now(),
  });
}
```

#### 4. 应用到服务器

**文件**：`npc-backend/server.js`

```javascript
const { requestLogger } = require('./middleware/logger');
const errorHandler = require('./middleware/errorHandler');

// 应用日志中间件（在所有路由之前）
app.use(requestLogger);

// ... 路由配置 ...

// 错误处理中间件（在所有路由之后）
app.use(errorHandler);
```

#### 5. LLM 服务日志

**文件**：`npc-backend/services/LLMService.js`

```javascript
const { logLLMCall, logError } = require('../utils/logger');

async function callLLMAPI(provider, model, systemPrompt, messages, timeout = 30000) {
  const startTime = Date.now();
  
  try {
    // ... LLM 调用逻辑 ...

    const responseTime = Date.now() - startTime;
    
    // 记录成功日志
    logLLMCall({
      provider,
      model,
      success: true,
      responseTime,
      tokensUsed: response.usage?.total_tokens,
    });

    return response;
  } catch (error) {
    const responseTime = Date.now() - startTime;
    
    // 记录失败日志
    logLLMCall({
      provider,
      model,
      success: false,
      responseTime,
      error: error.message,
      errorCode: error.code,
    });

    logError(error, {
      provider,
      model,
      responseTime,
    });

    throw error;
  }
}
```

---

## 日志文件管理

### 日志轮转（可选）

可以使用 `winston-daily-rotate-file` 实现日志轮转：

```javascript
const DailyRotateFile = require('winston-daily-rotate-file');

const logger = winston.createLogger({
  transports: [
    new DailyRotateFile({
      filename: path.join(logDir, 'error-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d', // 保留14天
      level: 'error',
    }),
    new DailyRotateFile({
      filename: path.join(logDir, 'combined-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d',
    }),
  ],
});
```

### 日志清理脚本（可选）

**文件**：`npc-backend/scripts/clean-logs.js`

```javascript
const fs = require('fs');
const path = require('path');

const logDir = path.join(__dirname, '../logs');
const maxAge = 7 * 24 * 60 * 60 * 1000; // 7天

function cleanOldLogs() {
  const files = fs.readdirSync(logDir);
  const now = Date.now();

  files.forEach(file => {
    const filePath = path.join(logDir, file);
    const stats = fs.statSync(filePath);
    
    if (now - stats.mtimeMs > maxAge) {
      fs.unlinkSync(filePath);
      console.log(`Deleted old log: ${file}`);
    }
  });
}

cleanOldLogs();
```

---

## 扩展性设计

### 未来接入 ELK（可选）

```javascript
const { ElasticsearchTransport } = require('winston-elasticsearch');

const esTransport = new ElasticsearchTransport({
  level: 'info',
  clientOpts: {
    node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200',
  },
});

logger.add(esTransport);
```

### 未来接入 Sentry（可选）

```javascript
const Sentry = require('@sentry/node');

// 在 logger 中添加 Sentry transport
logger.add(new winston.transports.Console({
  format: winston.format((info) => {
    if (info.level === 'error') {
      Sentry.captureException(new Error(info.message), {
        extra: info,
      });
    }
    return info;
  })(),
}));
```

---

## 测试要点

1. **日志记录**：验证日志是否正确记录到文件
2. **日志级别**：验证不同级别的日志是否正确分类
3. **API 日志**：验证 API 调用日志是否正确记录
4. **错误日志**：验证错误日志是否包含堆栈信息
5. **日志轮转**：验证日志轮转是否正常工作（如果实现）

---

## 注意事项

1. **日志文件大小**：
   - 设置合理的文件大小限制
   - 定期清理旧日志文件

2. **日志级别**：
   - 生产环境使用 `info` 或 `warn`
   - 开发环境可以使用 `debug`

3. **敏感信息**：
   - 不要在日志中记录密码、Token 等敏感信息
   - 可以添加日志脱敏功能

4. **性能影响**：
   - 日志记录是异步的，不会阻塞请求
   - 但大量日志可能影响磁盘 I/O

5. **日志分析**（可选）：
   - 可以添加日志分析脚本
   - 统计错误率、API 调用次数等

