# 未来版本规划

**文档版本**：v1.2  
**最后更新**：2025-01-XX
**相关文档**：[V1 产品文档](./v1/README.md)

---

## 说明

本文档描述的是**潜在的功能演进路线图**，而非严格的版本划分。功能之间可能存在依赖关系，某些功能是其他功能的前置条件。路线图可能产生多个分支，根据实际需求、优先级和资源情况灵活选择开发路径。

**核心原则**：
- 功能是**连续谱**，而非离散版本
- 功能之间存在**依赖关系**和**前置条件**
- 路线图可能产生**多个分支**，可以并行开发
- 根据实际需求**灵活选择**开发路径

当前已完成的基础功能请参考 [V1 产品文档](./v1/README.md)。  
**V1.5 版本规划**请参考 [V1.5 版本规划](./v1.5/README.md)。

---

## 功能保密等级说明

### 保密等级分类

| 等级 | 说明 | 是否可以对外分享 | 示例 |
|------|------|----------------|------|
| **公开（Public）** | 可以公开分享的功能，不涉及核心创意 | ✅ 可以 | 基础CRUD、搜索、数据导出等 |
| **内部（Internal）** | 可以内部讨论，但不对外公开 | ⚠️ 仅内部 | 部分优化功能、技术实现细节 |
| **保密（Confidential）** | 核心创意功能，需要保密 | ❌ 不能 | 记忆系统、多NPC世界等核心差异化功能 |
| **机密（Secret）** | 最高级别保密，绝对不能泄露 | ❌ 绝对不能 | 核心算法、独特创新点 |

### 重要性分类

| 等级 | 说明 | 对产品的影响 |
|------|------|------------|
| **核心（Core）** | 核心功能，产品差异化关键 | 直接影响产品竞争力 |
| **重要（Important）** | 重要功能，但不是核心差异化 | 提升用户体验，但不是唯一性 |
| **次要（Secondary）** | 次要功能，可以公开 | 锦上添花，不影响核心价值 |

### 功能保密等级表格

| 功能名称 | 重要性 | 保密等级 | 是否可以对外分享 | 保密原因 |
|---------|--------|---------|----------------|---------|
| **安全与认证分支** |
| JWT Token 认证 | 重要 | 公开 | ✅ 可以 | 标准技术实现，无创新点 |
| 密码加密（bcrypt） | 重要 | 公开 | ✅ 可以 | 标准技术实现，无创新点 |
| API 限流 | 重要 | 公开 | ✅ 可以 | 标准技术实现，无创新点 |
| 版本更新提醒和用户信息补全功能 | 重要 | 公开 | ✅ 可以 | 标准功能，版本迁移和用户引导 |
| 用户标识分离功能（userId与账号分离） | 重要 | 公开 | ✅ 可以 | 标准账号系统设计，userId仅作后端标识 |
| 账号找回功能 | 重要 | 公开 | ✅ 可以 | 标准功能，账号恢复 |
| 会员用户数据保护功能 | 核心 | 内部 | ⚠️ 仅内部 | 涉及数据隐私策略，可内部讨论 |
| 内容审核系统 | 重要 | 公开 | ✅ 可以 | 标准功能，无创新点 |
| **数据管理分支** |
| NPC 编辑和删除 | 次要 | 公开 | ✅ 可以 | 基础CRUD功能 |
| 自动生成头像功能 | 次要 | 公开 | ✅ 可以 | 标准功能，无创新点 |
| 相似名称提醒机制 | 次要 | 公开 | ✅ 可以 | 用户体验优化 |
| 对话搜索功能 | 重要 | 公开 | ✅ 可以 | 标准搜索功能 |
| 对话筛选功能 | 重要 | 公开 | ✅ 可以 | 标准筛选功能 |
| 对话管理增强（选中文字开启新对话、对话分支） | 重要 | 内部 | ⚠️ 仅内部 | 涉及交互创新，但可内部讨论 |
| 聊天历史展示优化（微信式展示） | 重要 | 公开 | ✅ 可以 | 参考微信实现，无创新点 |
| 数据导入导出功能 | 重要 | 公开 | ✅ 可以 | 标准数据管理功能 |
| 知识库/内容管理功能 | 重要 | 公开 | ✅ 可以 | 标准知识管理功能 |
| **记忆系统分支** |
| 短期记忆系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：记忆系统的实现方式 |
| 中期记忆系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：记忆分层和提取策略 |
| 长期记忆系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：长期记忆的构建和管理 |
| 记忆可解释性系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：记忆提取过程的可解释性 |
| 记忆快速索引系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：基于记忆的智能检索 |
| 记忆管理AI系统（永久聊天核心） | 核心 | 机密 | ❌ 绝对不能 | **最高机密**：AI自动管理记忆的核心算法 |
| **多 NPC 世界分支** |
| 多 NPC 世界场景 | 核心 | 保密 | ❌ 不能 | **核心创意**：多NPC世界的架构设计 |
| NPC 互相对话 | 核心 | 保密 | ❌ 不能 | **核心创意**：NPC之间的对话机制 |
| NPC 关系网络 | 核心 | 保密 | ❌ 不能 | **核心创意**：NPC关系网络的构建 |
| **工具与扩展分支** |
| 工具调用能力 | 重要 | 公开 | ✅ 可以 | 标准Function Calling实现 |
| 工作流 Agent 生成器（规则+样例自动生成Agent） | 核心 | 保密 | ❌ 不能 | **核心创意**：工作流 Agent 生成的核心算法和实现方式 |
| 用户自定义 API Key 功能 | 重要 | 公开 | ✅ 可以 | 标准功能，用户配置自己的 API Key |
| API 使用情况监控功能 | 重要 | 公开 | ✅ 可以 | 标准监控功能 |
| 后续行动系统（想法转化为实际任务） | 重要 | 内部 | ⚠️ 仅内部 | 涉及工作流创新，可内部讨论 |
| Git 操作工具（对话内容自动保存到 Git） | 重要 | 内部 | ⚠️ 仅内部 | 涉及工作流创新，可内部讨论 |
| 事件总线架构 | 重要 | 公开 | ✅ 可以 | 标准事件驱动架构 |
| **数据统计分支** |
| 基础数据统计 | 次要 | 公开 | ✅ 可以 | 标准统计功能 |
| 高级数据分析 | 次要 | 公开 | ✅ 可以 | 标准数据分析功能 |
| **对话交互增强分支** |
| 对话交互增强（连续发送、AI打断） | 重要 | 内部 | ⚠️ 仅内部 | 涉及交互创新，可内部讨论 |
| **用户反馈分支** |
| 用户反馈功能 | 重要 | 公开 | ✅ 可以 | 标准反馈功能 |
| **社交与分享分支** |
| 对话分享功能 | 重要 | 公开 | ✅ 可以 | 标准分享功能 |
| 对话精炼分享 | 重要 | 公开 | ✅ 可以 | 标准内容处理功能 |
| Agent分享功能（分享给朋友） | 重要 | 公开 | ✅ 可以 | 标准分享功能 |
| Agent分享功能（分享到社区） | 重要 | 公开 | ✅ 可以 | 标准社区功能 |
| 智能生命社区功能 | 核心 | 保密 | ❌ 不能 | **核心创意**：社区的概念和架构 |
| 好友功能 | 重要 | 公开 | ✅ 可以 | 标准社交功能 |
| 群功能 | 重要 | 公开 | ✅ 可以 | 标准群组功能 |
| 群体会话功能 | 重要 | 内部 | ⚠️ 仅内部 | 涉及会话架构创新，可内部讨论 |
| 智能生命社区 - 用户同位体功能 | 核心 | 机密 | ❌ 绝对不能 | **最高机密**：用户同位体的核心概念和实现 |
| **知识管理分支** |
| AI技术知识库（公司内部） | 次要 | 内部 | ⚠️ 仅内部 | 内部工具，不对外 |
| **运维支持分支** |
| 错误日志和监控 | 重要 | 公开 | ✅ 可以 | 标准监控功能 |
| 数据备份机制 | 重要 | 公开 | ✅ 可以 | 标准备份功能 |

### 保密原则

1. **核心创意保护**：
   - 记忆系统相关的所有功能都是核心创意，需要严格保密
   - 多NPC世界相关的功能是核心差异化，需要保密
   - 用户同位体功能是最高机密，绝对不能泄露

2. **可以公开的功能**：
   - 基础CRUD功能（编辑、删除、搜索等）
   - 标准技术实现（JWT、密码加密、API限流等）
   - 标准功能（分享、统计、监控等）

3. **内部讨论的功能**：
   - 涉及交互创新的功能（对话管理增强、连续发送等）
   - 涉及工作流创新的功能（后续行动系统）
   - 涉及架构创新的功能（群体会话）

4. **分享建议**：
   - **对外分享时**：只分享"公开"等级的功能
   - **内部讨论时**：可以讨论"内部"和"公开"等级的功能
   - **保密功能**：只在核心团队内部讨论，不对外泄露
   - **机密功能**：只在极少数核心人员中讨论，严格保密

---

## 0. 已知问题和漏洞

### ISSUE-001：NPC 类型与 System Prompt 的关联逻辑问题

**发现时间**：2025-01-XX  
**问题类型**：功能逻辑漏洞  
**优先级**：P1  
**状态**：待修复

**问题描述**：
- 当前实现中，无论是选择"通用"（general）还是"特定"（special）类型，systemPrompt 字段都是可选的
- 但实际上，"通用"类型应该不需要输入 systemPrompt，只有"特定"类型才需要输入 systemPrompt
- 这导致用户体验不一致：通用助手应该使用默认行为，不需要自定义人设

**影响范围**：
- 前端：`npc-frontend/src/pages/CreateAgent/CreateAgent.jsx` - 表单验证逻辑
- 后端：`npc-backend/services/AgentService.js` - 数据验证逻辑
- 产品文档：需要明确说明通用类型和特定类型的区别

**预期行为**：
- **通用类型（general）**：
  - systemPrompt 字段应该隐藏或禁用
  - 使用系统默认的通用助手 prompt
  - 用户只需要填写名称和模型即可
  
- **特定类型（special）**：
  - systemPrompt 字段必填
  - 用户必须输入自定义人设描述
  - 用于创建特定功能的 NPC（如学习教练、心理导师等）

**修复方案**：
1. 前端：根据选择的类型动态显示/隐藏 systemPrompt 字段
2. 后端：根据类型验证 systemPrompt 是否必填
3. 文档：更新产品文档，明确说明两种类型的区别和使用场景

**相关文档**：
- [V1 功能需求 - NPC 创建](./v1/03-功能需求.md)
- [V1 用户场景与用例 - 创建 NPC](./v1/02-用户场景与用例.md)

---

### ISSUE-002：用户名唯一性约束将在后续版本中移除

**发现时间**：2025-01-XX  
**问题类型**：设计变更  
**优先级**：P1  
**状态**：已规划

**问题描述**：
- 当前 V1 版本中，用户名（username）字段设置了唯一性约束（UNIQUE INDEX）
- 但实际上，用户名代表用户自己的名字，类似于现实世界中多人可以叫同一个名字
- 用户名唯一性约束限制了用户使用自己喜欢的名字，影响用户体验

**影响范围**：
- 数据库：`users` 表的 `username` 字段唯一索引需要移除
- 后端：`npc-backend/services/UserService.js` - 用户名重复检查逻辑需要移除
- 前端：`npc-frontend/src/pages/Register/Register.jsx` - 用户名重复验证需要移除
- API：`POST /api/v1/users/register` - 移除 `DUPLICATE_USERNAME` 错误返回

**预期行为**：
- **后续版本**：
  - 用户名（username）可以重复，多个用户可以使用相同的用户名
  - 用户名仅用于前端展示，不用于登录或身份识别
  - 登录和身份识别使用账号（account）和 userId
  - 移除用户名的唯一性约束和重复检查逻辑

**修复方案**：
1. 数据库：移除 `users` 表的 `username` 字段唯一索引
2. 后端：移除用户名重复检查逻辑，移除 `DUPLICATE_USERNAME` 错误码
3. 前端：移除用户名重复验证，允许用户使用任意用户名
4. 文档：更新相关文档，说明用户名可重复的设计理念

**相关文档**：
- [V1 数据模型 - User](./v1/05-数据模型.md)
- [V1 API 设计 - 用户注册](./v1/04-API设计.md)
- [V1 功能需求 - 用户注册](./v1/03-功能需求.md)
- [未来版本规划 - 用户标识分离功能](#2212-用户标识分离功能未来)

---


## 1. 功能路线图总览

### 1.1 潜在功能路线图

本文档描述的是一个**连续的功能演进谱系**，而非严格的版本划分。功能之间可能存在依赖关系，某些功能是其他功能的前置条件。路线图可能产生多个分支，根据实际需求和优先级灵活选择开发路径。

```
【已实现基础】✅
  ├─ NPC 创建、对话、历史记录
  ├─ 事件记录系统
  ├─ 基础登录/注册
  └─ API 适配层设计

【安全与认证分支】→ 前置条件：基础登录/注册
  ├─ JWT Token 认证 ✅ V1.5
  │   └─ 依赖：用户认证增强
  ├─ 密码加密（bcrypt）✅ V1.5
  │   └─ 依赖：用户认证增强
  ├─ Token 刷新机制（可选）
  │   └─ 依赖：JWT Token 认证
  ├─ API 限流和安全增强 ✅ V1.5（简单版）
  │   └─ 依赖：JWT Token 认证
  ├─ 版本更新提醒和用户信息补全功能（未来）
  │   ├─ 版本更新检测
  │   ├─ 用户信息补全提醒
  │   ├─ 账号找回功能
  │   └─ 依赖：用户认证增强
  ├─ 用户标识分离功能（未来）
  │   ├─ userId 与用户名/账号分离
  │   ├─ 独立账号系统（邮箱/手机号/用户名）
  │   ├─ 旧用户迁移功能
  │   └─ 依赖：用户认证增强、版本更新提醒功能
  ├─ 会员用户数据保护功能（未来）
  │   ├─ 会员用户数据隔离和保护
  │   ├─ 数据使用策略管理
  │   ├─ 数据使用审计和合规
  │   └─ 依赖：会员/付费功能、用户认证增强
  └─ 内容审核系统（未来）
      ├─ AI内容判定机制（违规内容检测）
      ├─ 用户封号功能
      ├─ 多国家/地区内容策略
      ├─ 内容认证和权限管理
      └─ 依赖：对话系统、用户认证增强

【数据管理分支】→ 前置条件：基础功能
  ├─ NPC 编辑和删除 ✅ V1.5
  │   └─ 依赖：基础 NPC 创建
  ├─ 自动生成头像功能（未来）
  │   └─ 依赖：基础 NPC 创建
  ├─ 相似名称提醒机制（未来）
  │   └─ 依赖：基础 NPC 创建、名称唯一性检查
  ├─ 对话搜索功能 ✅ V1.5（不做筛选）
  │   └─ 依赖：对话历史记录
  ├─ 对话筛选功能（未来）
  │   └─ 依赖：对话搜索功能
  ├─ 对话管理增强（未来）
  │   ├─ 选中文字开启新对话
  │   ├─ 对话分支管理（从某段对话继续）
  │   ├─ 对话精炼和摘要生成
  │   └─ 依赖：对话历史记录、记忆快速索引系统
  ├─ 聊天历史展示优化（未来）
  │   ├─ 微信式聊天历史展示（上滑查看）
  │   ├─ 基于记忆的上下文展示
  │   └─ 依赖：对话历史记录、记忆快速索引系统
  └─ 数据导入导出功能 ✅ V1.5
      └─ 依赖：对话历史记录、NPC 数据

【记忆系统分支】→ 前置条件：对话系统
  ├─ 短期记忆系统
  │   └─ 依赖：对话历史记录、事件记录系统
  ├─ 中期记忆系统
  │   └─ 依赖：短期记忆系统、事件记录系统
  ├─ 长期记忆系统
  │   └─ 依赖：中期记忆系统、关系网络
  ├─ 记忆可解释性系统（未来）
  │   ├─ 记忆提取过程记录和对比
  │   ├─ 记忆提取方式对比分析
  │   └─ 依赖：短期/中期/长期记忆系统
  ├─ 记忆快速索引系统（未来）
  │   ├─ 基于记忆的对话历史检索
  │   ├─ 自然语言查询历史（"咱们上次聊过什么"）
  │   └─ 依赖：中期/长期记忆系统、对话历史记录
  └─ 记忆管理AI系统（未来）
      ├─ 使用AI管理记忆提取和优化
      ├─ 记忆提取策略自动优化
      └─ 依赖：记忆可解释性系统、长期记忆系统

【多 NPC 世界分支】→ 前置条件：单个 NPC 系统、记忆系统
  ├─ 多 NPC 世界场景
  │   └─ 依赖：NPC 创建、场景管理
  ├─ NPC 互相对话
  │   └─ 依赖：多 NPC 世界场景、短期记忆系统、事件总线
  └─ NPC 关系网络
      └─ 依赖：NPC 互相对话、长期记忆系统

【工具与扩展分支】→ 前置条件：对话系统、认证系统
  ├─ 工具调用能力
  │   └─ 依赖：LLM Function Calling、权限系统
  ├─ API 使用情况监控功能（未来）
  │   ├─ API Key 状态监控（正常使用/已禁用）
  │   ├─ API Key 使用量统计（调用次数、成功次数、失败次数）
  │   ├─ API Key 管理界面（查看、启用/禁用）
  │   ├─ 使用量可视化（图表展示）
  │   └─ 依赖：多 API Key 故障转移功能、LLM API 调用功能
  ├─ 后续行动系统（未来）
  │   ├─ 想法转化为实际任务（软件、项目、书籍等）
  │   ├─ 对话成果的后续发展（打印、导出、执行）
  │   ├─ 实时反馈和进度跟踪
  │   └─ 依赖：工具调用能力、对话历史记录
  └─ 事件总线架构
      └─ 依赖：事件记录系统、消息队列

【数据统计分支】→ 前置条件：基础功能、数据管理
  ├─ 基础数据统计（未来）
  │   └─ 依赖：对话历史记录、NPC 数据
  └─ 高级数据分析（未来）
      └─ 依赖：基础数据统计、数据导出功能

【对话交互增强分支】→ 前置条件：对话系统
  ├─ 基础交互功能（未来）
  │   ├─ 一键复制整段回答（必备）
  │   ├─ 复制代码块（单独复制按钮）（必备）
  │   ├─ 重新生成回答（必备）
  │   ├─ 编辑问题并重新生成（必备）
  │   ├─ 点赞/点踩反馈（推荐）
  │   ├─ 继续生成（回答被截断时）（推荐）
  │   ├─ 朗读回答（TTS文字转语音）（可选）
  │   └─ 依赖：对话系统、消息展示
  ├─ 代码相关功能（未来）
  │   ├─ 代码高亮显示（推荐）
  │   ├─ 运行代码（部分产品）（可选）
  │   ├─ 插入代码到编辑器（可选）
  │   └─ 依赖：对话系统、代码识别
  ├─ 内容管理功能（未来）
  │   ├─ 收藏/书签对话（可选）
  │   ├─ 搜索历史对话（已规划，见对话搜索功能）
  │   └─ 依赖：对话历史记录、收藏系统
  └─ 对话交互增强：支持用户连续发送和AI打断（未来）
      ├─ 支持用户连续发送多条消息
      ├─ 支持AI打断用户（AI回复过程中用户可继续发送）
      ├─ 消息队列管理
      └─ 依赖：对话系统、事件记录系统

【用户反馈分支】→ 前置条件：基础功能
  └─ 用户反馈功能 ✅ V1.5

【社交与分享分支】→ 前置条件：对话系统
  ├─ 对话分享功能（未来）
  │   ├─ 分享完整对话记录
  │   ├─ 分享对话精炼版本
  │   └─ 依赖：对话历史记录、对话管理增强
  ├─ 对话精炼分享（未来）
  │   ├─ AI自动生成对话摘要
  │   ├─ 自定义分享内容范围
  │   └─ 依赖：对话分享功能、记忆系统
  ├─ Agent分享功能（未来）
  │   ├─ 分享给朋友（链接分享，可独立实现）
  │   ├─ 分享到社区（需要社区功能支持）
  │   ├─ 完整分享（模型、提示词、对话记录、记忆）
  │   ├─ 部分分享（不含记忆）
  │   ├─ 自定义记忆分享
  │   └─ 依赖：NPC创建、对话历史记录、记忆系统（分享到社区需要社区功能）
  ├─ 智能生命社区功能（未来）
  │   ├─ 社区首页（展示分享的Agent）
  │   ├─ Agent搜索和筛选
  │   ├─ Agent详情页和导入功能
  │   └─ 依赖：NPC创建、Agent分享（分享给朋友）
  ├─ 好友功能（未来）
  │   ├─ 添加好友、好友列表管理
  │   ├─ 好友请求和确认机制
  │   └─ 依赖：用户认证
  ├─ 群功能（未来）
  │   ├─ 创建群组、群成员管理
  │   ├─ 用户和Agent都可以加入群
  │   └─ 依赖：用户认证、NPC创建、好友功能（可选）
  ├─ 群体会话功能（未来）
  │   ├─ 群组内多人对话
  │   ├─ 参与者可变（与固定会话不同）
  │   ├─ 固定Session ID（绑定群组）
  │   └─ 依赖：群功能、对话系统
  └─ 智能生命社区 - 用户同位体功能（未来）
      ├─ 用户创建自己的同位体（Avatar Agent）
      ├─ 社区中放置和展示同位体
      ├─ 用户与社区中其他用户的同位体对话
      ├─ 同位体之间自动交互（AI驱动）
      └─ 依赖：NPC创建、记忆系统、Agent分享、智能生命社区功能、多NPC世界

【知识管理分支】→ 前置条件：基础功能
  ├─ 知识库/内容管理功能（未来）
  │   ├─ 文档、数据库、图表等产出物存储
  │   ├─ RAG素材管理
  │   ├─ 内容与对话关联
  │   └─ 依赖：对话历史记录、文件存储系统、用户认证增强
  └─ AI技术知识库（未来，公司内部）
      ├─ AI技术表格/文档管理
      ├─ 热门AI技术跟踪
      ├─ 技术实现原理说明
      ├─ 学习资源整理
      ├─ 技术通俗解释
      └─ 依赖：基础功能（可独立开发，内部工具）

【运维支持分支】→ 前置条件：基础功能
  ├─ 错误日志和监控 ✅ V1.5（简单版）
  │   └─ 依赖：基础功能
  └─ 数据备份机制 ✅ V1.5（简单版）
      └─ 依赖：数据库已建立

【基础设施分支】→ 可独立或并行开发
  ├─ Redis 缓存
  ├─ 消息队列（Redis Streams）
  ├─ 监控和告警系统
  └─ 数据备份机制
```

### 1.2 功能依赖关系说明

**核心依赖链**：
- `基础功能` → `安全与认证` → `数据管理` → `记忆系统` → `多 NPC 世界`
- `基础功能` → `工具与扩展`（可并行）
- `基础功能` → `数据统计`（可并行）
- `基础功能` → `社交与分享`（可并行）
- `基础功能` → `知识管理`（可并行）
  - `知识库/内容管理` → `RAG功能`（可选，使用知识库作为RAG数据源）
  - `知识库/内容管理` → `工具调用能力`（可选，读取知识库内容）
  - `知识库/内容管理` → `后续行动系统`（可选，保存行动产生的产出物）
- `记忆系统` → `对话管理增强`（依赖记忆快速索引）
- `工具调用能力` → `后续行动系统`（依赖工具调用）

**可选分支**：
- 某些功能可以独立开发，不依赖其他功能
- 某些功能可以并行开发，互不干扰
- 某些功能是其他功能的增强，可以后续添加

**前置条件标注**：
- 每个功能分支都标注了前置条件
- 功能内部标注了依赖关系
- 开发时需确保前置条件已满足

### 1.3 功能开发建议

**并行开发路径**：
- `安全与认证` + `数据管理` + `数据统计` 可以并行开发（互不依赖）
- `工具调用能力` 可以独立开发（不阻塞其他功能）
- `基础设施分支`（Redis、消息队列、监控）可以提前准备

**顺序开发路径**：
- `短期记忆系统` → `中期记忆系统` → `长期记忆系统`（强依赖链）
- `多 NPC 世界场景` → `NPC 互相对话`（强依赖链）
- `事件记录系统` → `事件总线架构`（增强关系）

**灵活选择原则**：
- 根据用户反馈和业务需求选择优先级
- 某些功能可以简化实现，后续再增强
- 某些功能可以分阶段实现，先实现核心部分

---

## 2. 安全与认证功能规划

### 2.1 功能目标

增强用户认证安全性，完善权限验证机制，提升系统安全性。

**前置条件**：基础登录/注册功能已实现

**V1.5 版本状态**：✅ 已规划并实现

### 2.2 功能列表

#### 2.2.1 用户认证增强 ✅ V1.5

**功能描述**：
- 实现 JWT Token 进行用户认证
- 密码加密（bcrypt）
- Token 刷新机制（可选）
- 用户权限验证和数据隔离增强

**前置条件**：
- 基础登录/注册功能

**依赖关系**：
- 后续功能（API 限流、数据统计）依赖此功能

**技术实现**：
- JWT Token 生成和验证
- 密码哈希存储（bcrypt）
- Token 刷新机制（可选）
- 中间件实现 Token 验证

**实现方案**：详见 [V1.5 版本规划 - 密码功能](./v1.5/01-密码功能实现方案.md) 和 [V1.5 版本规划 - JWT认证](./v1.5/02-JWT认证实现方案.md)

**优先级**：P0

---

#### 2.2.1.1 版本更新提醒和用户信息补全功能（未来）

**功能描述**：
- **版本更新检测**：系统检测到版本更新后，提醒用户需要更新登录信息
- **用户信息补全提醒**：检测用户缺少的信息（密码、邮箱等），提醒用户补全
- **强制补全流程**：对于关键信息（如密码），可以强制用户补全后才能使用
- **账号找回功能**：支持通过邮箱找回账号和重置密码
- **用户引导**：提供清晰的引导流程，帮助用户完成信息补全

**核心价值**：
- **平滑迁移**：帮助用户从 V1（只用账号）平滑迁移到 V1.5（需要密码）
- **数据安全**：确保用户设置密码，提升账户安全性
- **用户体验**：友好的提醒和引导，不强制用户立即补全
- **账号恢复**：支持账号找回，降低账号丢失风险

**前置条件**：
- 用户认证增强（JWT Token、密码加密）
- 用户注册功能（基础）

**依赖关系**：
- 依赖用户认证增强（用于检测用户信息完整性）
- 可以独立开发，不阻塞其他功能

**技术实现**：

- **数据库设计**：
  - `users` 表扩展：
    - `password`：密码哈希（V1 用户为 NULL）
    - `email`：邮箱（可选，用于账号找回）
    - `email_verified`：邮箱是否已验证（BOOLEAN）
    - `profile_completed`：用户信息是否已补全（BOOLEAN）
    - `last_profile_reminder_at`：最后提醒时间（TIMESTAMP）
    - `profile_completion_version`：完成信息补全时的版本号（VARCHAR）
  
  - `user_profile_reminders` 表：记录用户信息补全提醒（可选）
    - `id`：提醒ID
    - `user_id`：用户ID
    - `reminder_type`：提醒类型（password_required/email_required/profile_incomplete）
    - `reminder_count`：提醒次数
    - `last_reminder_at`：最后提醒时间
    - `completed_at`：完成时间（如果已补全）
    - `created_at`：创建时间

- **版本检测服务**：
  - `VersionService.js`：版本检测和管理服务
    - `checkUserVersion(userId)`：检测用户使用的版本
    - `detectVersionUpdate(userId)`：检测版本更新
    - `getRequiredUpdates(userId)`：获取需要更新的信息列表

- **用户信息补全检测**：
  - `UserProfileService.js`：用户信息补全服务
    - `checkProfileCompleteness(userId)`：检查用户信息完整性
    - `getMissingFields(userId)`：获取缺失的字段列表
    - `updateProfile(userId, updates)`：更新用户信息
    - `markProfileCompleted(userId)`：标记信息已补全

- **账号找回功能**：
  - `AccountRecoveryService.js`：账号找回服务
    - `sendRecoveryEmail(email)`：发送找回邮件
    - `verifyRecoveryToken(token)`：验证找回令牌
    - `resetPassword(userId, newPassword)`：重置密码
    - `findAccountByEmail(email)`：通过邮箱查找账号

- **API 设计**：
  - `GET /api/v1/users/profile/status` - 获取用户信息补全状态
    - 返回：`{ completed: boolean, missingFields: [], reminders: [] }`
  - `POST /api/v1/users/profile/complete` - 补全用户信息
    - 请求参数：`password`、`email`等
  - `POST /api/v1/users/account/recovery` - 发送账号找回邮件
    - 请求参数：`email` 或 `userId`
  - `POST /api/v1/users/account/reset-password` - 重置密码
    - 请求参数：`token`、`newPassword`
  - `GET /api/v1/users/version/updates` - 获取版本更新信息
    - 返回：`{ hasUpdates: boolean, requiredActions: [], newFeatures: [] }`

**用户体验流程**：

- **版本更新检测**：
  1. 用户登录后，系统检测版本更新
  2. 如果检测到版本更新，显示更新提醒弹窗
  3. 提醒内容：
     - "系统已更新到 V1.5 版本"
     - "为了您的账户安全，请设置密码"
     - "新功能：账号找回、JWT Token 认证等"
  4. 用户可以选择"立即设置"或"稍后提醒"

- **信息补全提醒**：
  1. 系统检测用户信息完整性
  2. 如果缺少关键信息（如密码），显示提醒
  3. 提醒方式：
     - **首次登录**：强制弹窗，必须设置密码
     - **后续登录**：顶部横幅提醒，不强制
     - **定期提醒**：每 7 天提醒一次（如果未补全）
  4. 用户点击"立即设置"，跳转到信息补全页面

- **信息补全页面**：
  1. 显示需要补全的信息列表
  2. 每个信息项显示：
     - 信息名称（如"密码"）
     - 是否必填
     - 补全按钮
  3. 用户填写信息并保存
  4. 保存后，标记为已补全

- **账号找回流程**：
  1. 用户在登录页点击"忘记密码"
  2. 输入邮箱或 User ID
  3. 系统发送找回邮件（包含重置链接）
  4. 用户点击邮件中的链接
  5. 跳转到重置密码页面
  6. 用户设置新密码
  7. 重置成功，可以登录

**前端实现**：

- **版本更新提醒组件**：
  - `components/VersionUpdateModal/VersionUpdateModal.jsx`
  - 显示版本更新信息和新功能
  - 提供"立即更新"和"稍后提醒"按钮

- **信息补全提醒组件**：
  - `components/ProfileReminder/ProfileReminder.jsx`
  - 顶部横幅提醒
  - 显示缺失的信息列表
  - 点击跳转到补全页面

- **信息补全页面**：
  - `pages/CompleteProfile/CompleteProfile.jsx`
  - 表单：密码设置、邮箱绑定等
  - 进度指示：显示补全进度
  - 保存后更新状态

- **账号找回页面**：
  - `pages/AccountRecovery/AccountRecovery.jsx`
  - 输入邮箱或 User ID
  - 发送找回邮件
  - 重置密码表单

**业务规则**：

1. **版本更新检测**：
   - 用户登录时检测版本更新
   - 记录用户最后使用的版本
   - 如果版本更新，显示更新提醒

2. **信息补全策略**：
   - **强制补全**：密码（关键信息，必须设置）
   - **推荐补全**：邮箱（用于账号找回，推荐设置）
   - **可选补全**：其他信息（可选）

3. **提醒频率**：
   - 首次登录：立即提醒
   - 后续登录：每 7 天提醒一次（如果未补全）
   - 最多提醒 5 次，之后不再提醒（但功能仍受限）

4. **功能限制**：
   - 未设置密码：可以登录，但某些功能受限（如 API Key 管理）
   - 未绑定邮箱：无法使用账号找回功能
   - 信息补全后：解除所有限制

**实现步骤**：

1. **阶段一：版本检测和信息补全检测**（1周）
   - 实现版本检测服务
   - 实现用户信息完整性检测
   - 实现 API 接口

2. **阶段二：前端提醒和引导**（1周）
   - 实现版本更新提醒组件
   - 实现信息补全提醒组件
   - 实现信息补全页面

3. **阶段三：账号找回功能**（1周）
   - 实现账号找回服务
   - 实现邮件发送功能
   - 实现重置密码功能

4. **阶段四：优化和测试**（1周）
   - 优化用户体验
   - 完善错误处理
   - 测试完整流程

**优先级**：P0（版本迁移的关键功能）

**保密等级**：公开（✅ 可以）- 标准功能，无创新点

---

#### 2.2.1.2 用户标识分离功能（未来）

**功能描述**：
- **userId 与用户名/账号分离**：userId 仅作为后端身份唯一性标识，不再作为用户名或账号使用
- **独立账号系统**：用户使用独立的账号（如邮箱、手机号、自定义用户名）登录，而非 userId
- **向后兼容**：支持现有用户（如使用 "userI" 等 userId 作为账号的用户）平滑迁移到新账号系统
- **账号唯一性**：确保账号（邮箱/手机号/用户名）的唯一性，与 userId 分离管理

**核心价值**：
- **安全性提升**：userId 作为内部标识，不对外暴露，降低安全风险
- **用户体验**：用户可以使用更友好的账号（邮箱、手机号、自定义用户名）登录
- **系统架构**：清晰的账号体系，userId 仅用于后端数据关联和权限验证
- **可扩展性**：为未来多账号绑定、账号找回等功能提供基础

**前置条件**：
- 用户认证增强（JWT Token、密码加密）
- 版本更新提醒和用户信息补全功能（用于用户迁移）

**依赖关系**：
- 依赖用户认证增强（用于账号系统重构）
- 依赖版本更新提醒功能（用于引导用户迁移）
- 后续功能（账号找回、多账号绑定）依赖此功能

**技术实现**：

- **数据库设计**：
  - `users` 表扩展：
    - `id`：userId（保持不变，作为主键，仅用于后端）
    - `account`：账号（新增，唯一索引，用于登录，如邮箱、手机号、自定义用户名）
    - `account_type`：账号类型（新增，enum：email/phone/username）
    - `username`：用户名（显示名称，可重复，用于前端展示）
    - `password`：密码哈希
    - `legacy_user_id_account`：是否使用旧版 userId 作为账号（BOOLEAN，用于迁移标识）
  
  - `user_accounts` 表：多账号绑定表（可选，未来扩展）
    - `id`：绑定ID
    - `user_id`：用户ID（关联 users.id）
    - `account`：账号（邮箱/手机号/用户名）
    - `account_type`：账号类型
    - `is_primary`：是否为主账号（BOOLEAN）
    - `verified`：是否已验证（BOOLEAN）
    - `created_at`：创建时间

- **账号服务**：
  - `AccountService.js`：账号管理服务
    - `createAccount(userId, account, accountType)`：创建账号
    - `findByAccount(account)`：通过账号查找用户
    - `validateAccount(account, accountType)`：验证账号格式
    - `checkAccountAvailability(account)`：检查账号是否可用
    - `migrateLegacyUser(userId, newAccount)`：迁移旧版用户到新账号系统

- **认证服务重构**：
  - `AuthService.js`：认证服务（重构）
    - `login(account, password)`：使用账号登录（而非 userId）
    - `register(account, accountType, username, password)`：使用账号注册
    - `findUserByAccount(account)`：通过账号查找用户
    - `generateUserId()`：生成新的 userId（内部使用）

- **API 设计**：
  - `POST /api/v1/users/register` - 用户注册（重构）
    - 请求参数：`account`（账号）、`accountType`（账号类型）、`username`（用户名）、`password`（密码）
    - 返回：`{ userId, account, username, token }`
  - `POST /api/v1/users/login` - 用户登录（重构）
    - 请求参数：`account`（账号）、`password`（密码）
    - 返回：`{ userId, account, username, token }`
  - `POST /api/v1/users/account/migrate` - 迁移旧账号到新账号系统
    - 请求参数：`userId`（旧 userId）、`newAccount`（新账号）、`accountType`（账号类型）
    - 返回：`{ success, userId, account }`
  - `GET /api/v1/users/account/check` - 检查账号是否可用
    - 请求参数：`account`（账号）
    - 返回：`{ available: boolean }`

**用户体验流程**：

- **新用户注册**：
  1. 用户选择账号类型（邮箱/手机号/自定义用户名）
  2. 输入账号、用户名、密码
  3. 系统验证账号唯一性
  4. 创建用户记录（生成 userId，保存账号）
  5. 返回登录凭证

- **旧用户迁移**：
  1. 系统检测到用户使用旧版 userId 作为账号
  2. 显示迁移提醒："为了您的账户安全，请设置新的登录账号"
  3. 用户选择账号类型并输入新账号
  4. 系统验证账号可用性
  5. 绑定新账号到现有 userId
  6. 标记迁移完成，后续使用新账号登录

- **用户登录**：
  1. 用户输入账号（邮箱/手机号/用户名）和密码
  2. 系统通过账号查找用户
  3. 验证密码
  4. 返回 JWT Token（包含 userId）

**业务规则**：

1. **账号唯一性**：
   - 账号（account）必须全局唯一
   - 不同账号类型可以相同值（如邮箱和用户名可以相同，但系统会区分）
   - userId 保持不变，仅用于后端关联

2. **账号类型**：
   - `email`：邮箱账号（推荐，支持账号找回）
   - `phone`：手机号账号（可选，需要验证码验证）
   - `username`：自定义用户名账号（可选，需满足命名规范）

3. **用户名可重复性**：
   - **重要变更**：用户名（username）在后续版本中将改为可重复
   - **原因**：用户名代表用户自己的名字，类似于现实世界中多人可以叫同一个名字
   - **实现方式**：
     - 移除用户名的唯一性约束（UNIQUE INDEX）
     - 用户名仅用于前端展示，不用于登录或身份识别
     - 登录和身份识别使用账号（account）和 userId
   - **影响**：多个用户可以使用相同的用户名，但账号（account）和 userId 必须唯一

4. **向后兼容**：
   - 支持旧版用户（使用 userId 作为账号）继续登录
   - 引导旧版用户迁移到新账号系统
   - 迁移后，旧账号（userId）不再用于登录，但仍保留用于数据关联

5. **迁移策略**：
   - **强制迁移**：新版本发布后，旧版用户首次登录时强制迁移
   - **可选迁移**：旧版用户可以选择稍后迁移，但会定期提醒
   - **迁移期限**：设置迁移期限（如 3 个月），过期后强制迁移

**实现步骤**：

1. **阶段一：数据库设计和账号服务**（1周）
   - 扩展 users 表结构
   - 实现账号管理服务
   - 实现账号验证和唯一性检查

2. **阶段二：认证服务重构**（1周）
   - 重构登录/注册 API
   - 实现账号查找逻辑
   - 更新 JWT Token 生成逻辑

3. **阶段三：用户迁移功能**（1周）
   - 实现旧用户检测
   - 实现迁移流程
   - 实现迁移提醒和引导

4. **阶段四：前端适配**（1周）
   - 更新登录/注册页面
   - 实现账号类型选择
   - 实现迁移引导页面

5. **阶段五：测试和优化**（1周）
   - 测试完整流程
   - 优化用户体验
   - 完善错误处理

**优先级**：P1（重要功能，提升安全性和用户体验）

**保密等级**：公开（✅ 可以）- 标准账号系统设计，无创新点

**相关文档**：
- [V1 功能需求 - 用户认证](./v1/03-功能需求.md)
- [V1 API 设计 - 用户认证](./v1/04-API设计.md)
- [V1.5 版本规划 - JWT认证](./v1.5/02-JWT认证实现方案.md)

---

#### 2.2.2 基础数据统计

**功能描述**：
- 用户数据统计（NPC 数量、对话数量等）
- NPC 使用统计（对话次数、最后使用时间等）
- 简单的数据可视化（图表）

**前置条件**：
- 基础功能（NPC 创建、对话历史记录）
- 用户认证增强（可选，用于用户级别的统计）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 后续高级数据分析功能依赖此功能

**技术实现**：
- 统计数据表设计
- 统计 API 实现
- 前端图表组件（如 Chart.js）

**优先级**：P1

---

#### 2.2.3 API 限流和安全增强 ✅ V1.5（简单版）

**功能描述**：
- 实现 API 限流（用户级别、IP 级别）
- LLM API 特殊限流（防止成本过高）
- 增强 API 安全性（CORS、CSRF 防护）（基础实现）

**前置条件**：
- 用户认证增强（JWT Token）（用于用户级别限流）

**依赖关系**：
- 用户级别限流依赖 JWT Token 认证
- IP 级别限流可独立实现

**技术实现**：
- 限流中间件（express-rate-limit，内存存储）
- 安全中间件配置（基础）
- 监控和告警系统（未来）

**实现方案**：详见 [V1.5 版本规划 - API限流](./v1.5/03-API限流实现方案.md)

**扩展性**：
- 当前：内存存储（简单、零成本）
- 未来：可替换为 Redis（rate-limit-redis），接口不变

**优先级**：P0

---

#### 2.2.4 数据备份机制 ✅ V1.5（简单版）

**功能描述**：
- 实现定期数据备份（每日全量）
- 实现数据恢复工具（简单版）
- 备份文件管理（保留7天）

**前置条件**：
- 数据库已建立（基础功能）

**依赖关系**：
- 可独立开发，不依赖其他功能
- 建议在数据量增长前实现

**技术实现**：
- 数据库备份脚本（mysqldump）
- 数据恢复工具（简单版）
- 备份文件自动清理

**实现方案**：详见 [V1.5 版本规划 - 数据备份](./v1.5/09-数据备份实现方案.md)

**扩展性**：
- 当前：mysqldump + 本地文件（零成本）
- 未来：可接入云存储（OSS/S3），增量备份（binlog）

**优先级**：P0

---

#### 2.2.5 会员用户数据保护功能（未来）

**功能描述**：
- **会员用户数据保护**：保护开会员的用户的用户数据，不用于模型训练
- **数据使用标记**：在数据库中明确标记哪些用户数据可以用于模型训练，哪些不能
- **数据隔离机制**：确保会员用户的数据在数据收集、存储、处理等环节都被隔离和保护
- **数据使用策略管理**：管理员可以配置和管理数据使用策略，明确哪些数据可以用于训练

**核心承诺**：
- **会员用户数据保护**：开会员的用户的用户数据（对话记录、Agent配置、用户行为等）不会被用于模型训练
- **数据使用透明化**：用户可以在设置中查看自己的数据使用状态和保护状态
- **数据隔离保证**：会员用户的数据在系统层面被隔离，确保不会被误用于训练

**前置条件**：
- 用户认证功能
- 会员/付费功能（需要先实现会员标识）
- 数据收集和处理系统（如果未来需要收集数据用于训练）

**依赖关系**：
- 依赖会员/付费功能（用于识别会员用户）
- 可以独立开发，不阻塞其他功能
- 如果未来需要收集数据用于模型训练，必须先实现此功能

**技术实现**：
- **数据库设计**：
  - `users` 表扩展：
    - `is_premium`：是否为会员（BOOLEAN，默认 false）
    - `premium_expires_at`：会员到期时间（TIMESTAMP，可选）
    - `data_protection_enabled`：数据保护启用状态（BOOLEAN，默认 true，会员用户自动启用）
    - `data_usage_consent`：数据使用同意状态（BOOLEAN，默认 false，会员用户默认为 false）
  
  - `data_usage_policies` 表：存储数据使用策略（可选）
    - `id`：策略ID
    - `user_id`：用户ID（可选，如果为 null 则为全局策略）
    - `policy_type`：策略类型（training/analytics/sharing等）
    - `allowed`：是否允许（BOOLEAN）
    - `created_at`：创建时间
    - `updated_at`：更新时间
  
  - `data_usage_logs` 表：记录数据使用日志（可选，用于审计）
    - `id`：日志ID
    - `user_id`：用户ID
    - `data_type`：数据类型（conversation/agent/user_behavior等）
    - `usage_type`：使用类型（training/analytics/sharing等）
    - `allowed`：是否允许使用（BOOLEAN）
    - `timestamp`：时间戳
    - `reason`：原因（如果拒绝使用）

- **数据保护机制**：
  - **会员用户识别**：系统自动识别会员用户（`is_premium = true`）
  - **数据标记**：所有会员用户的数据自动标记为"受保护"（`data_protection_enabled = true`）
  - **数据使用检查**：在数据收集、处理、训练等环节，检查用户的数据保护状态
  - **数据隔离**：会员用户的数据在存储和处理时被隔离，确保不会被误用

- **API 设计**：
  - `GET /api/v1/users/:id/data-protection` - 获取用户数据保护状态
  - `PUT /api/v1/users/:id/data-protection` - 更新用户数据保护设置（仅管理员或用户本人）
  - `GET /api/v1/users/:id/data-usage-policy` - 获取用户数据使用策略
  - `PUT /api/v1/users/:id/data-usage-policy` - 更新用户数据使用策略
  - `GET /api/v1/admin/data-usage-stats` - 获取数据使用统计（管理员，用于审计）

- **数据使用检查中间件**：
  - 在数据收集和处理流程中，添加数据使用检查中间件
  - 检查用户是否为会员用户，如果是，则拒绝使用其数据用于训练
  - 记录数据使用日志，用于审计和合规

- **前端实现**：
  - **用户设置页面**：
    - 显示用户的数据保护状态（会员用户显示"已保护"）
    - 显示数据使用策略（哪些数据可以用于哪些用途）
    - 允许用户查看和更新数据使用同意状态（非会员用户）
  - **会员标识**：
    - 在用户界面中显示会员标识
    - 明确告知会员用户其数据受到保护

**业务规则**：
1. **会员用户自动保护**：用户开通会员后，自动启用数据保护（`data_protection_enabled = true`）
2. **数据使用默认拒绝**：会员用户的数据默认不允许用于模型训练（`data_usage_consent = false`）
3. **数据隔离保证**：会员用户的数据在系统层面被隔离，确保不会被误用于训练
4. **数据使用审计**：所有数据使用尝试都会被记录，用于审计和合规
5. **会员到期处理**：会员到期后，数据保护状态保持不变（用户可以选择继续保护或允许使用）

**用户体验**：
- **会员用户**：
  - 开通会员后，自动获得数据保护
  - 在用户设置中可以看到"数据保护已启用"的标识
  - 明确知道自己的数据不会被用于模型训练
  - 可以查看数据使用日志（如果启用）
  
- **非会员用户**：
  - 可以选择是否同意数据用于模型训练
  - 在用户设置中可以查看和更新数据使用同意状态
  - 可以选择开通会员以获得数据保护

**应用场景**：
- **数据隐私保护**：保护会员用户的隐私数据，不用于模型训练
- **合规要求**：满足数据保护和隐私法规的要求
- **用户信任**：增强用户对平台的信任，特别是对数据隐私的关注
- **会员权益**：作为会员的一项权益，提升会员价值

**重要说明**：
- **数据保护承诺**：平台明确承诺，会员用户的数据不会被用于模型训练
- **数据隔离机制**：在系统层面实现数据隔离，确保承诺得到执行
- **数据使用透明化**：用户可以在设置中查看自己的数据保护状态和使用策略
- **审计和合规**：记录所有数据使用尝试，用于审计和合规检查

**优先级**：P1（如果未来需要收集数据用于模型训练，则优先级提升为 P0）

---

---

## 3. 数据管理功能规划

### 3.1 功能目标

增强核心功能，提升用户体验，增加数据管理能力。

**前置条件**：基础功能（NPC 创建、对话历史记录）

**V1.5 版本状态**：✅ 已规划并实现

### 3.2 功能列表

#### 3.2.1 NPC 编辑和删除 ✅ V1.5

**功能描述**：
- 允许用户编辑 NPC 的配置（名称、人设、模型等）
- 允许用户删除 NPC
- 删除 NPC 时的数据清理策略（软删除或硬删除）

**前置条件**：
- NPC 创建功能

**依赖关系**：
- 删除功能需要考虑对话历史记录的关联
- 如果已实现记忆系统，需要考虑记忆数据的清理

**技术实现**：
- PUT /api/v1/agents/:id API
- DELETE /api/v1/agents/:id API
- 数据清理逻辑（软删除）

**实现方案**：详见 [V1.5 版本规划 - NPC编辑删除](./v1.5/04-NPC编辑删除实现方案.md)

**优先级**：P0

---

#### 3.2.1.1 自动生成头像功能（未来）

**功能描述**：
- 用户创建 NPC 时，可以根据 Agent 名称和 systemPrompt 自动生成头像
- 使用 AI 图像生成服务（如 DALL-E、Midjourney API、Stable Diffusion 等）
- 用户可以选择使用自动生成的头像，或手动上传/输入头像 URL
- 生成的头像可以保存到本地或云存储

**前置条件**：
- NPC 创建功能
- AI 图像生成 API（可选，也可以使用免费的头像生成服务）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 可以增强 NPC 创建的用户体验

**技术实现**：
- 集成 AI 图像生成 API（如 DALL-E、Stable Diffusion）
- 或使用免费头像生成服务（如 DiceBear、Avatar API）
- 头像生成服务封装（AvatarService）
- 前端添加"自动生成头像"按钮
- 头像缓存机制（避免重复生成）

**实现方案**：
- **方案 A（推荐）**：使用免费头像生成服务（DiceBear、Avatar API）
  - 优点：零成本、快速、稳定
  - 缺点：样式有限，不能完全根据 prompt 生成
  - 实现：根据 Agent 名称生成种子，调用头像 API
  
- **方案 B**：集成 AI 图像生成 API（DALL-E、Stable Diffusion）
  - 优点：可以根据 prompt 生成个性化头像
  - 缺点：需要 API Key，有成本，生成速度较慢
  - 实现：将 Agent 名称和 systemPrompt 组合成 prompt，调用图像生成 API

**用户体验**：
- 创建 NPC 时，显示"自动生成头像"按钮
- 点击后显示生成进度（如果使用 AI 生成）
- 生成完成后预览，用户可以选择使用或重新生成
- 支持多次生成，直到用户满意

**优先级**：P1

---

#### 3.2.1.2 相似名称提醒机制（未来）

**功能描述**：
- 用户创建 NPC 时，如果输入的名称与已有 NPC 名称相似，系统会提醒用户
- 提醒方式：前端实时检查，显示警告提示（非阻止提交）
- 相似度算法：使用字符串相似度算法（如 Levenshtein 距离、Jaro-Winkler 等）
- 用户可以忽略提醒继续创建，或修改名称

**前置条件**：
- NPC 创建功能
- 名称唯一性检查（已有）

**依赖关系**：
- 基于现有的名称唯一性检查功能
- 可以增强用户体验，避免用户创建重复的 NPC

**技术实现**：
- 后端：添加相似名称检查 API（`GET /api/v1/agents/similar-names?userId=xxx&name=xxx`）
- 前端：实时检查（输入时或失焦时）
- 相似度算法：使用字符串相似度库（如 `string-similarity`、`fuzzy-search`）
- 相似度阈值：建议 70% 以上相似度才提醒（可配置）

**实现方案**：
1. **后端实现**：
   - 在 `AgentService` 中添加 `findSimilarNames` 方法
   - 查询用户的所有 NPC 名称
   - 使用相似度算法计算相似度
   - 返回相似度超过阈值的名称列表

2. **前端实现**：
   - 在创建 NPC 表单中，名称输入框失焦时调用检查 API
   - 如果发现相似名称，显示警告提示（非错误提示）
   - 提示内容："检测到相似名称：'xxx'，是否继续创建？"
   - 用户可以点击"忽略"继续创建，或修改名称

**相似度算法选择**：
- **Levenshtein 距离**：计算两个字符串的编辑距离
- **Jaro-Winkler**：适合短字符串，对前缀相似度敏感
- **余弦相似度**：将字符串转换为向量后计算相似度
- **推荐**：使用 `string-similarity` 库，支持多种算法

**用户体验**：
- 输入名称时，实时检查（防抖处理，避免频繁请求）
- 发现相似名称时，显示友好的警告提示
- 提示中包含相似名称列表，用户可以点击查看详情
- 用户可以忽略提醒继续创建，或修改名称

**优先级**：P1

---

#### 3.2.2 短期记忆系统

**功能描述**：
- 实现 NPC 的短期记忆（最近 N 次对话的摘要）
- 在对话中使用短期记忆增强上下文
- 记忆的自动更新和管理
- **替代当前"最近N条历史事件"的上下文构建方式**

**当前实现**：
- 对话上下文构建：获取最近 20 条历史事件（`getRecentEvents(sessionId, limit = 20)`）
- 上下文限制：默认 20 条事件，可配置（`contextLimit = 20`）
- 问题：随着对话历史增长，简单的"最近N条"方式无法有效利用历史信息

**未来改进**：
- **基于记忆模型的上下文构建**：
  - 短期记忆：最近N次对话的摘要（替代当前"最近N条事件"）
  - 中期记忆：重要事件的摘要和关联
  - 长期记忆：角色背景、关系网络、知识库
  - 记忆快速索引：基于记忆的对话历史检索
- **上下文配置策略**：
  - 用户可以选择不同的上下文构建策略
  - 策略1：最近N条事件（当前方式，简单但有限）
  - 策略2：短期记忆 + 最近N条事件（混合方式）
  - 策略3：短期记忆 + 中期记忆 + 长期记忆（完整记忆系统）
  - 策略4：记忆快速索引 + 相关历史（智能检索）
- **Agent级别配置**：
  - 每个Agent可以配置自己的上下文构建策略
  - 不同Agent可以使用不同的记忆模型
  - 配置项：
    - `contextStrategy`: 上下文构建策略（recent_events/memory_hybrid/memory_full/memory_index/custom）
    - `contextLimit`: 上下文限制（如果使用recent_events策略）
    - `memoryConfig`: 记忆配置（如果使用记忆相关策略）

- **前端用户配置**：
  - **上下文窗口长度选择**：用户可以在前端选择上下文长度
    - 提供几个预设选项：短（10条）、中（20条）、长（50条）、超长（100条）、自定义
    - 用户可以根据对话历史长短、模型token限制等需求选择
    - 配置保存在用户设置中，可以全局应用或按Agent应用
  - **配置层级**：
    - **全局默认**：系统默认值（20条）
    - **用户设置**：用户个人偏好设置（覆盖全局默认）
    - **Agent配置**：Agent级别的配置（覆盖用户设置）
    - **会话临时**：当前会话的临时设置（覆盖Agent配置）
  - **前端UI**：
    - 在对话页面添加"上下文设置"按钮或下拉菜单
    - 显示当前上下文长度和策略
    - 允许用户快速切换上下文长度
    - 显示上下文使用情况（如"已使用 15/20 条"）

**前置条件**：
- 对话历史记录功能
- 事件记录系统（用于记忆触发）

**依赖关系**：
- 中期/长期记忆系统依赖此功能
- NPC 互相对话功能依赖此功能
- **对话上下文构建功能依赖此功能**（替代当前"最近N条事件"方式）

**技术实现**：
- 记忆表设计（memories 表）
- 记忆生成服务（使用 LLM 生成摘要）
- 记忆检索和更新逻辑
- **上下文构建服务重构**：
  - 从`getRecentEvents`改为`buildContextWithMemory`
  - 支持多种上下文构建策略
  - 支持Agent级别的上下文配置
  - 支持用户级别的上下文配置
  - 支持会话临时上下文配置

- **数据库设计**：
  - **Agent配置扩展**（`agents`表）：
    - `context_strategy`: 上下文构建策略（VARCHAR）
    - `context_limit`: 上下文限制（INT，如果使用recent_events策略）
    - `memory_config`: 记忆配置（JSON，如果使用记忆相关策略）
  
  - **用户设置扩展**（`users`表或新建`user_settings`表）：
    - `default_context_limit`: 用户默认上下文长度（INT）
    - `default_context_strategy`: 用户默认上下文策略（VARCHAR）
    - `context_preferences`: 上下文偏好设置（JSON）
  
  - **会话临时设置**（`sessions`表扩展或新建`session_settings`表）：
    - `session_id`: 会话ID
    - `context_limit`: 会话临时上下文长度（INT，可选）
    - `context_strategy`: 会话临时上下文策略（VARCHAR，可选）

- **配置优先级**：
  - 会话临时设置 > Agent配置 > 用户设置 > 全局默认
  - 如果某个层级未配置，使用下一层级的配置

- **API设计**：
  - `POST /api/v1/messages` - 发送消息（改进版，支持上下文策略）
    - 请求参数：`contextLimit`（可选，覆盖Agent配置）
    - 根据配置优先级构建上下文
  - `GET /api/v1/agents/:id/context-config` - 获取Agent的上下文配置
  - `PUT /api/v1/agents/:id/context-config` - 更新Agent的上下文配置
  - `GET /api/v1/users/:id/context-settings` - 获取用户的上下文设置
  - `PUT /api/v1/users/:id/context-settings` - 更新用户的上下文设置
  - `PUT /api/v1/sessions/:id/context-settings` - 设置会话临时上下文配置（可选）

- **前端实现**：
  - **上下文设置UI**：
    - 在对话页面添加"上下文设置"按钮或下拉菜单
    - 显示当前上下文长度和策略
    - 提供预设选项：短（10条）、中（20条）、长（50条）、超长（100条）、自定义
    - 允许用户快速切换上下文长度
    - 显示上下文使用情况（如"已使用 15/20 条"）
  - **设置保存**：
    - 用户选择后，保存到用户设置或会话临时设置
    - 发送消息时，将`contextLimit`参数传递给后端
  - **设置显示**：
    - 在对话页面显示当前上下文配置
    - 在Agent详情页显示Agent的上下文配置

**优先级**：P0

---

#### 3.2.3 对话搜索功能 ✅ V1.5（不做筛选）

**功能描述**：
- 支持搜索对话内容
- 支持关键词高亮显示
- 不做筛选功能（简化实现）

**前置条件**：
- 对话历史记录功能

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 数据导出功能可以复用搜索逻辑

**技术实现**：
- 全文搜索（MySQL FULLTEXT 索引）
- 搜索 API 实现
- 前端搜索界面

**实现方案**：详见 [V1.5 版本规划 - 对话搜索](./v1.5/05-对话搜索实现方案.md)

**优先级**：P0

---

#### 3.2.4 对话筛选功能（未来）

**功能描述**：
- 支持按时间范围筛选对话
- 支持按 NPC 筛选对话
- 支持按类型筛选对话

**前置条件**：
- 对话搜索功能

**优先级**：P1

---

#### 3.2.5 数据导入导出功能 ✅ V1.5

**功能描述**：
- 支持导出对话历史（JSON、TXT、Markdown 格式）
- 支持导出 NPC 配置
- 支持导入对话历史（包含 prompt、模型信息）
- 模型兼容性处理（如果模型不存在，提供替代方案）

**前置条件**：
- 对话历史记录功能
- NPC 数据管理功能

**依赖关系**：
- 可以复用对话搜索的逻辑
- 可独立开发，不阻塞其他功能

**技术实现**：
- 导出服务实现
- 导入服务实现（模型映射）
- 文件生成和下载
- 导出格式转换

**实现方案**：详见 [V1.5 版本规划 - 数据导入导出](./v1.5/07-数据导入导出实现方案.md)

**优先级**：P1

---

#### 3.2.6 对话管理增强（未来）

**功能描述**：
- 支持选中对话中的某段文字，开启新对话
- 提供对话分支管理功能（从某段对话继续发展）
- 支持对话精炼和摘要生成
- 用户可以选择开启新对话的方式（直接使用选中内容、或精炼当前聊天记录）

**前置条件**：
- 对话历史记录功能
- 记忆快速索引系统（用于上下文理解）

**依赖关系**：
- 依赖记忆快速索引系统来理解对话上下文
- 对话分享功能可以复用对话精炼能力

**技术实现**：
- 文本选中和提取功能
- 对话分支创建服务
- 对话精炼服务（使用LLM）
- 对话关联关系管理

**优先级**：P1

---

#### 3.2.7 聊天历史展示优化（未来）

**功能描述**：
- 实现微信式聊天历史展示（上滑查看所有历史）
- 基于记忆的上下文展示（AI上下文使用结构化记忆，而非完整历史）
- 用户可以通过自然语言查询历史（"咱们上次聊过什么"）
- 同一NPC不同主题对话的智能管理

**前置条件**：
- 对话历史记录功能
- 记忆快速索引系统

**依赖关系**：
- 依赖记忆快速索引系统来实现智能检索
- 对话管理增强功能可以增强此功能

**技术实现**：
- 聊天历史UI组件（无限滚动）
- 记忆索引与历史记录的关联展示
- 自然语言查询接口
- 对话主题自动分类

**优先级**：P1

---

#### 3.2.7.1 对话交互增强：基础交互功能（未来）

**功能描述**：
- **一键复制整段回答**：用户可以一键复制AI生成的整段回答内容，提升使用效率
- **复制代码块**：代码块提供单独的复制按钮，方便单独复制代码
- **重新生成回答**：用户对当前回答不满意时，可以重新生成回答
- **编辑问题**：用户可以修改已发送的提问，自动重新生成回答
- **点赞/点踩反馈**：用户可以点赞或点踩回答，收集用户反馈，改进AI质量
- **继续生成**：回答被截断时，用户可以继续生成完整回答
- **朗读回答**：使用TTS文字转语音，让AI读出回答内容（可选）

**核心价值**：
- **提升使用效率**：快速复制整段回答，减少手动操作
- **改善用户体验**：重新生成、编辑问题等功能让用户更容易获得满意的回答
- **收集反馈**：点赞/点踩功能帮助改进AI质量
- **增强可访问性**：朗读功能帮助视觉障碍用户或需要听读的场景

**前置条件**：
- 对话系统（基础）
- 消息展示功能（基础）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 可以显著提升用户体验
- 后续可以扩展为更复杂的交互功能

**技术实现**：

- **复制功能**：
  - **前端实现**：
    - 在每条AI消息下方添加"复制"按钮
    - 点击后复制整段回答内容到剪贴板
    - 显示复制成功提示
    - 代码块单独提供复制按钮（使用代码高亮组件）
  - **技术方案**：
    - 使用 `navigator.clipboard.writeText()` API
    - 代码块使用 `react-syntax-highlighter` 的复制功能
    - 处理复制失败的情况（降级到 `document.execCommand('copy')`）

- **重新生成功能**：
  - **前端实现**：
    - 在每条AI消息下方添加"重新生成"按钮
    - 点击后使用相同的问题重新调用API
    - 显示新的回答（可以替换原回答或并排显示）
  - **后端实现**：
    - 复用现有的消息发送API
    - 支持传入 `regenerate: true` 参数
    - 可以记录重新生成的次数（用于分析）

- **编辑问题功能**：
  - **前端实现**：
    - 在用户消息上添加"编辑"按钮
    - 点击后允许用户修改消息内容
    - 修改后自动重新发送并生成回答
    - 可以显示编辑历史（可选）
  - **后端实现**：
    - 支持更新已发送的消息内容
    - 重新生成回答时使用更新后的问题
    - 记录编辑历史（可选）

- **点赞/点踩功能**：
  - **数据库设计**：
    - `message_feedback` 表：存储用户反馈
      - `id`：反馈ID
      - `user_id`：用户ID
      - `event_id`：消息事件ID
      - `feedback_type`：反馈类型（like/dislike）
      - `created_at`：创建时间
  - **API设计**：
    - `POST /api/v1/messages/:eventId/feedback` - 提交反馈
      - 请求参数：`feedbackType`（like/dislike）
    - `GET /api/v1/messages/:eventId/feedback` - 获取反馈统计（可选）
  - **前端实现**：
    - 在每条AI消息下方添加点赞/点踩按钮
    - 点击后提交反馈，显示已反馈状态
    - 可以显示反馈统计（可选）

- **继续生成功能**：
  - **前端实现**：
    - 检测回答是否被截断（如末尾有"..."或长度异常）
    - 显示"继续生成"按钮
    - 点击后调用API继续生成
  - **后端实现**：
    - 检测回答是否完整（通过LLM API的finish_reason判断）
    - 如果被截断，支持继续生成
    - 将新生成的内容追加到原回答

- **朗读功能**（可选）：
  - **前端实现**：
    - 使用 Web Speech API（`speechSynthesis`）
    - 在每条AI消息下方添加"朗读"按钮
    - 点击后开始朗读，显示播放控制（暂停、停止）
    - 支持选择语音（中文、英文等）
  - **技术方案**：
    - 使用浏览器原生 TTS API（零成本）
    - 或集成第三方TTS服务（如Azure TTS、Google TTS）

**用户体验**：

- **复制功能**：
  - 用户点击"复制"按钮，立即复制整段回答
  - 显示"已复制"提示，提升反馈
  - 代码块有独立的复制按钮，方便单独复制代码

- **重新生成**：
  - 用户点击"重新生成"，系统使用相同问题重新生成
  - 可以替换原回答或并排显示多个版本
  - 用户可以对比不同版本，选择满意的回答

- **编辑问题**：
  - 用户点击"编辑"，修改已发送的问题
  - 修改后自动重新生成回答
  - 可以查看编辑历史（可选）

- **点赞/点踩**：
  - 用户点击点赞/点踩按钮，提交反馈
  - 按钮显示已反馈状态
  - 帮助系统改进AI质量

- **继续生成**：
  - 回答被截断时，显示"继续生成"按钮
  - 点击后继续生成完整回答
  - 新内容追加到原回答

- **朗读**：
  - 用户点击"朗读"，AI读出回答内容
  - 支持暂停、停止、调整语速
  - 适合需要听读的场景

**优先级建议**：

| 功能 | 优先级 | 说明 |
|------|--------|------|
| 一键复制整段回答 | P0（必备） | 基础功能，提升使用效率 |
| 复制代码块 | P0（必备） | 代码场景必需 |
| 重新生成回答 | P0（必备） | 改善用户体验 |
| 编辑问题 | P0（必备） | 改善用户体验 |
| 点赞/点踩反馈 | P1（推荐） | 收集反馈，改进质量 |
| 继续生成 | P1（推荐） | 处理回答截断问题 |
| 代码高亮显示 | P1（推荐） | 代码场景必需 |
| 朗读回答 | P2（可选） | 增强可访问性 |
| 运行代码 | P2（可选） | 高级功能 |
| 插入代码到编辑器 | P2（可选） | 高级功能 |
| 收藏/书签 | P2（可选） | 内容管理 |

**实现步骤**：

1. **阶段一：基础复制功能**（1周）
   - 实现一键复制整段回答
   - 实现代码块单独复制
   - 优化复制体验和提示

2. **阶段二：重新生成和编辑**（1周）
   - 实现重新生成回答功能
   - 实现编辑问题功能
   - 优化用户体验

3. **阶段三：反馈和继续生成**（1周）
   - 实现点赞/点踩功能
   - 实现继续生成功能
   - 实现反馈统计（可选）

4. **阶段四：高级功能**（可选，1-2周）
   - 实现朗读功能
   - 实现代码运行功能（如果支持）
   - 实现收藏/书签功能

**优先级**：P0（基础交互功能是必备功能）

**保密等级**：公开（✅ 可以）- 标准功能，无创新点

---

#### 3.2.7.2 对话交互增强：代码相关功能（未来）

**功能描述**：
- **代码高亮显示**：自动识别和美化代码块，支持多种编程语言的语法高亮
- **运行代码**：支持在浏览器中运行代码（如JavaScript、Python等）（部分产品支持）
- **插入代码到编辑器**：将代码直接插入到代码编辑器（如VS Code、Cursor等）

**核心价值**：
- **提升代码可读性**：代码高亮让代码更易读
- **增强实用性**：运行代码功能让用户可以直接测试代码
- **提高效率**：插入代码到编辑器减少手动复制粘贴

**前置条件**：
- 对话系统（基础）
- 代码识别功能（基础）

**依赖关系**：
- 代码高亮功能可以独立开发
- 运行代码功能需要代码执行环境（如沙箱）
- 插入代码到编辑器需要编辑器集成

**技术实现**：

- **代码高亮显示**：
  - **前端实现**：
    - 使用 `react-syntax-highlighter` 库（已集成）
    - 自动识别代码块（Markdown代码块）
    - 支持多种编程语言（JavaScript、Python、Java、C++等）
    - 支持主题切换（可选）
  - **技术方案**：
    - 使用现有的 `react-syntax-highlighter` 组件
    - 通过 Markdown 解析识别代码块
    - 根据代码语言选择对应的语法高亮器

- **运行代码功能**（可选）：
  - **前端实现**：
    - 在代码块下方添加"运行"按钮
    - 点击后在沙箱环境中运行代码
    - 显示运行结果（输出、错误等）
  - **技术方案**：
    - **JavaScript**：使用 `eval()` 或 `Function()`（需要安全限制）
    - **Python**：使用 Pyodide（在浏览器中运行Python）
    - **其他语言**：需要后端代码执行服务（如Docker容器）
  - **安全考虑**：
    - 使用沙箱环境隔离代码执行
    - 限制代码执行时间和资源
    - 禁止访问敏感API（文件系统、网络等）

- **插入代码到编辑器**（可选）：
  - **前端实现**：
    - 在代码块下方添加"插入到编辑器"按钮
    - 点击后通过协议（如 `vscode://`）打开编辑器
    - 或使用剪贴板API复制代码
  - **技术方案**：
    - 使用 `vscode://` 协议打开VS Code
    - 使用 `cursor://` 协议打开Cursor
    - 或使用剪贴板API + 提示用户粘贴

**用户体验**：

- **代码高亮**：
  - 代码块自动识别和美化
  - 支持多种编程语言
  - 提升代码可读性

- **运行代码**：
  - 用户点击"运行"按钮
  - 代码在沙箱中执行
  - 显示运行结果或错误信息

- **插入代码到编辑器**：
  - 用户点击"插入到编辑器"
  - 代码自动打开编辑器或复制到剪贴板
  - 用户可以直接使用代码

**优先级**：P1（推荐，代码场景必需）

**保密等级**：公开（✅ 可以）- 标准功能，无创新点

---

#### 3.2.7.3 对话交互增强：内容管理功能（未来）

**功能描述**：
- **收藏/书签对话**：用户可以收藏重要的对话，标记为书签，方便后续快速检索
- **搜索历史对话**：在对话记录中搜索（已规划，见对话搜索功能）

**核心价值**：
- **快速检索**：收藏功能帮助用户快速找到重要对话
- **内容管理**：书签功能帮助用户组织和管理对话内容

**前置条件**：
- 对话历史记录功能
- 收藏系统（需要新建）

**依赖关系**：
- 可以独立开发，不阻塞其他功能
- 搜索历史对话功能已规划（见对话搜索功能）

**技术实现**：

- **收藏/书签功能**：
  - **数据库设计**：
    - `bookmarks` 表：存储用户收藏
      - `id`：收藏ID
      - `user_id`：用户ID
      - `session_id`：会话ID（可选）
      - `event_id`：事件ID（可选，收藏特定消息）
      - `title`：收藏标题（用户自定义）
      - `notes`：备注（用户自定义）
      - `tags`：标签（JSON数组）
      - `created_at`：创建时间
  - **API设计**：
    - `POST /api/v1/bookmarks` - 创建收藏
      - 请求参数：`sessionId`、`eventId`（可选）、`title`、`notes`、`tags`
    - `GET /api/v1/bookmarks` - 获取收藏列表
      - 支持按标签筛选、搜索
    - `GET /api/v1/bookmarks/:id` - 获取收藏详情
    - `PUT /api/v1/bookmarks/:id` - 更新收藏
    - `DELETE /api/v1/bookmarks/:id` - 删除收藏
  - **前端实现**：
    - 在对话消息上添加"收藏"按钮
    - 点击后弹出收藏表单（标题、备注、标签）
    - 收藏后显示书签图标
    - 提供收藏列表页面，显示所有收藏

**用户体验**：

- **收藏对话**：
  - 用户点击"收藏"按钮
  - 填写收藏信息（标题、备注、标签）
  - 收藏后可以快速访问

- **查看收藏**：
  - 用户进入收藏列表页面
  - 可以按标签筛选、搜索
  - 点击收藏项跳转到对应对话

**优先级**：P2（可选，内容管理功能）

**保密等级**：公开（✅ 可以）- 标准功能，无创新点

---

#### 3.2.7.4 对话交互增强：支持用户连续发送和AI打断（未来）

**功能描述**：
- **支持用户连续发送多条消息**：用户可以在不等待AI回复的情况下，连续发送多条消息
- **支持AI打断用户**：AI正在生成回复时，用户仍然可以继续发送消息，AI会基于最新的消息上下文生成回复
- **消息队列管理**：后端需要管理待处理的消息队列，按顺序处理用户的多条消息
- **上下文合并**：AI回复时，需要合并用户连续发送的多条消息作为上下文

**当前限制**：
- 用户发送消息后，前端会设置`sending`状态为true，阻止用户继续发送
- 前端需要等待AI回复后，才能发送下一条消息
- 这导致对话体验不够流畅，无法实现自然的连续对话

**核心价值**：
- **更自然的对话体验**：用户可以像真实对话一样，连续表达自己的想法
- **提高对话效率**：用户不需要等待AI回复，可以快速连续发送多条消息
- **支持复杂对话场景**：用户可以一次性提供多个信息点，AI可以综合处理

**前置条件**：
- 对话系统（基础）
- 事件记录系统（基础）
- 消息发送API（基础）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 可以增强对话系统的用户体验
- 后续可以扩展为更复杂的对话管理功能（如对话分支、对话合并等）

**技术实现**：
- **前端改进**：
  - 移除`sending`状态对发送按钮的完全禁用
  - 允许用户在AI回复过程中继续发送消息
  - 显示"AI正在思考..."状态，但不阻止用户发送
  - 支持消息队列显示（显示待处理的消息）
  
- **后端改进**：
  - **消息队列管理**：
    - 为每个会话维护一个消息队列
    - 用户发送的消息先加入队列
    - 后端按顺序处理队列中的消息
    - 支持消息合并（如果用户连续发送多条消息，可以合并为一条上下文）
  
  - **并发控制**：
    - 同一会话的消息串行处理（防止消息顺序混乱）
    - 如果AI正在生成回复，新的用户消息加入队列等待
    - 如果AI已完成回复，立即处理队列中的下一条消息
  
  - **上下文构建**：
    - 如果用户连续发送多条消息，将这些消息合并为一条上下文
    - AI回复时，基于合并后的上下文生成回复
    - 支持消息分组（将连续的用户消息分组，AI回复时引用整组消息）

- **数据库设计**（可选，如果需要持久化队列）：
  - `message_queue` 表：存储待处理的消息队列
    - `id`：队列项ID
    - `session_id`：会话ID
    - `user_id`：用户ID
    - `agent_id`：Agent ID
    - `content`：消息内容
    - `status`：状态（pending/processing/completed）
    - `created_at`：创建时间
    - `processed_at`：处理时间

- **API设计**：
  - `POST /api/v1/messages` - 发送消息（改进版，支持队列）
    - 立即返回，不等待AI回复
    - 返回消息ID和队列状态
  - `GET /api/v1/messages/queue/:sessionId` - 获取消息队列状态（可选）
    - 返回队列中的消息数量和状态
  - `POST /api/v1/messages/batch` - 批量发送消息（可选）
    - 支持一次性发送多条消息

**用户体验**：
- **连续发送**：
  - 用户可以快速连续发送多条消息
  - 输入框始终可用，不会被禁用
  - 显示"AI正在思考..."提示，但不阻止发送
  
- **消息状态显示**：
  - 用户消息：立即显示，标记为"已发送"
  - AI回复：显示"正在生成..."状态，完成后显示完整回复
  - 队列状态：显示"还有X条消息待处理"（可选）
  
- **对话流程**：
  - 用户发送消息1 → 立即显示消息1
  - 用户发送消息2 → 立即显示消息2（不等待AI回复）
  - AI基于消息1和消息2生成回复 → 显示AI回复
  - 用户发送消息3 → 立即显示消息3
  - AI基于消息3生成回复 → 显示AI回复

**应用场景**：
- **快速提问**：用户可以快速连续提出多个问题，AI可以综合回答
- **补充信息**：用户在AI回复过程中，可以补充更多信息
- **复杂对话**：用户可以一次性提供多个信息点，AI可以综合处理
- **自然对话**：模拟真实对话场景，用户可以连续表达想法

**技术挑战**：
- **消息顺序**：确保消息按正确顺序处理，避免顺序混乱
- **上下文合并**：如何合理合并用户连续发送的多条消息
- **性能优化**：避免消息队列过长，影响响应速度
- **错误处理**：如果某条消息处理失败，如何处理后续消息

**实现方案**：
- **方案A（推荐）**：前端乐观更新 + 后端队列管理
  - 前端立即显示用户消息，不等待AI回复
  - 后端维护消息队列，按顺序处理
  - AI回复时，合并队列中的连续用户消息作为上下文
  - 优点：用户体验好，实现相对简单
  - 缺点：需要管理消息队列
  
- **方案B**：前端消息合并 + 后端批量处理
  - 前端检测用户连续发送，自动合并为一条消息
  - 后端处理合并后的消息
  - 优点：实现简单，不需要队列管理
  - 缺点：用户无法看到自己发送的多条消息

**优先级**：P1

---

#### 3.2.8 知识库/内容管理功能（未来）

**功能描述**：
- 用户可以存储和管理聊天产生的产出物，包括：
  - **文档**：聊天中生成的文档、文章、笔记等文本内容
  - **数据库**：聊天中产生的数据表结构、数据内容、SQL脚本等
  - **图表**：聊天中生成的图表、可视化内容、图片等
  - **其他素材**：RAG相关的素材、代码片段、配置文件等
- 支持内容分类和标签管理
- 支持内容搜索和检索
- 支持内容与对话的关联（查看内容来源的对话）
- 支持内容的编辑、删除、分享等操作

**核心价值**：
- **知识沉淀**：将聊天产生的有价值内容保存下来，形成个人知识库
- **内容复用**：保存的内容可以在后续对话中引用和使用
- **RAG支持**：为RAG（检索增强生成）提供素材库，支持向量化存储和检索
- **工作流支持**：支持从对话到实际产出的完整工作流

**前置条件**：
- 对话历史记录功能
- 文件存储系统（本地存储或云存储）
- 用户认证增强（用于权限控制）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- RAG功能可以依赖此功能（使用知识库作为RAG数据源）
- 工具调用能力可以依赖此功能（读取知识库内容）
- 后续行动系统可以依赖此功能（保存行动产生的产出物）

**技术实现**：
- **数据库设计**：
  - `knowledge_items` 表：存储知识库项目
    - `id`：项目ID
    - `user_id`：用户ID
    - `title`：标题
    - `type`：类型（document/database/chart/code/other）
    - `content`：内容（文本内容或JSON格式）
    - `file_url`：文件URL（如果内容存储在文件中）
    - `file_type`：文件类型（pdf/docx/md/sql/json/png/jpg等）
    - `tags`：标签（JSON数组）
    - `category`：分类
    - `session_id`：关联的会话ID（可选）
    - `event_id`：关联的事件ID（可选，记录来源消息）
    - `created_at`：创建时间
    - `updated_at`：更新时间
    - `metadata`：元数据（JSON，存储额外信息）
  
  - `knowledge_vectors` 表：存储向量化内容（用于RAG）
    - `id`：向量ID
    - `knowledge_item_id`：关联的知识库项目ID
    - `chunk_id`：分块ID（如果内容被分块）
    - `vector`：向量数据（JSON或BLOB）
    - `text`：原始文本（用于检索）
    - `created_at`：创建时间
  
  - `knowledge_tags` 表：标签管理（可选）
    - `id`：标签ID
    - `user_id`：用户ID
    - `name`：标签名称
    - `color`：标签颜色
    - `created_at`：创建时间

- **文件存储**：
  - 本地存储：存储在服务器文件系统（适合小规模）
  - 云存储：使用对象存储服务（如AWS S3、阿里云OSS、腾讯云COS等）
  - 文件上传和下载API
  - 文件类型验证和大小限制

- **内容管理功能**：
  - 创建知识库项目（从对话中提取、手动创建、文件上传）
  - 编辑和更新内容
  - 删除内容
  - 分类和标签管理
  - 内容搜索（全文搜索、标签搜索、类型搜索）
  - 内容预览（文档预览、图表预览等）

- **RAG支持**：
  - 内容向量化（使用embedding模型）
  - 向量存储和检索（使用向量数据库，如Milvus、Pinecone、Qdrant等）
  - 相似度搜索（根据用户查询检索相关内容）
  - 内容分块（大文档分块处理）

- **对话关联**：
  - 在对话中标记内容为"保存到知识库"
  - 自动提取对话中的产出物（如代码、图表、文档等）
  - 查看内容来源的对话上下文
  - 在知识库中查看关联的对话

**API设计**：
- `POST /api/v1/knowledge` - 创建知识库项目
- `GET /api/v1/knowledge` - 获取知识库列表（支持搜索、筛选、分页）
- `GET /api/v1/knowledge/:id` - 获取知识库项目详情
- `PUT /api/v1/knowledge/:id` - 更新知识库项目
- `DELETE /api/v1/knowledge/:id` - 删除知识库项目
- `POST /api/v1/knowledge/:id/tags` - 添加标签
- `DELETE /api/v1/knowledge/:id/tags/:tagId` - 删除标签
- `POST /api/v1/knowledge/upload` - 上传文件
- `GET /api/v1/knowledge/:id/download` - 下载文件
- `POST /api/v1/knowledge/from-event/:eventId` - 从对话事件创建知识库项目
- `GET /api/v1/knowledge/:id/related-session` - 获取关联的会话信息
- `POST /api/v1/knowledge/search` - 向量搜索（RAG）

**用户体验**：
- **保存内容**：
  - 在对话中，用户可以选中消息或点击"保存到知识库"按钮
  - 系统自动识别内容类型（文档、代码、图表等）
  - 用户可以编辑标题、添加标签、选择分类
  - 保存后，内容出现在知识库中
  
- **知识库管理**：
  - 知识库首页：展示所有保存的内容（卡片式或列表式）
  - 分类和标签筛选：用户可以按类型、标签、分类筛选
  - 搜索功能：支持全文搜索和标签搜索
  - 内容预览：点击内容可以预览（文档、图表、代码等）
  - 编辑和删除：用户可以编辑或删除内容
  
- **内容复用**：
  - 在对话中，用户可以引用知识库中的内容
  - 支持"插入到对话"功能，将知识库内容插入到当前对话
  - RAG自动检索：在对话中自动检索相关知识库内容，增强上下文

- **RAG素材管理**：
  - 用户可以上传文档、图片等素材到知识库
  - 素材自动向量化，支持RAG检索
  - 在对话中，系统自动检索相关素材，增强回答质量

**应用场景**：
- **学习笔记**：用户与学习助手对话，产生学习笔记，保存到知识库
- **代码库**：用户与编程助手对话，产生代码片段，保存到知识库
- **数据分析**：用户与数据分析助手对话，产生图表和数据，保存到知识库
- **文档生成**：用户与文档助手对话，产生文档，保存到知识库
- **RAG增强**：用户上传文档到知识库，在后续对话中自动检索相关内容

**技术选型建议**：
- **向量数据库**：Milvus（开源）、Pinecone（云服务）、Qdrant（开源）
- **Embedding模型**：OpenAI text-embedding-ada-002、BGE、M3E等
- **文件存储**：本地存储（开发阶段）→ 云存储（生产环境）
- **文档解析**：支持PDF、Word、Markdown、代码文件等格式解析

**优先级**：P1

---

## 4. 多 NPC 世界功能规划

### 4.1 功能目标

实现高级功能，打造多 NPC 世界，支持 NPC 互相对话和复杂交互。

**前置条件**：
- 单个 NPC 系统（NPC 创建、对话）
- 短期记忆系统（用于 NPC 之间的上下文）
- 事件记录系统（用于 NPC 交互事件）

### 4.2 功能列表

#### 4.2.1 多 NPC 世界场景

**功能描述**：
- 用户可以与多个 NPC 同时存在于一个场景中
- 场景可视化（2D 或 3D）
- NPC 在场景中的位置和状态

**前置条件**：
- NPC 创建功能
- 基础对话系统

**依赖关系**：
- NPC 互相对话功能依赖此功能
- NPC 关系网络功能依赖此功能

**技术实现**：
- 场景表设计（scenes 表）
- 场景管理服务
- 前端场景渲染（Canvas 或 WebGL）

**优先级**：P0

---

#### 4.2.2 NPC 互相对话

**功能描述**：
- NPC 之间可以互相对话
- 用户可以选择观察 NPC 之间的对话
- NPC 对话的触发机制（时间、事件、用户指令）

**前置条件**：
- 多 NPC 世界场景
- 短期记忆系统（用于 NPC 之间的上下文记忆）
- 事件总线架构（用于事件驱动的对话触发）

**依赖关系**：
- NPC 关系网络功能依赖此功能
- 中期/长期记忆系统可以增强此功能

**技术实现**：
- NPC 对话调度服务
- 对话事件记录（A2A 事件）
- 对话触发和规则引擎

**优先级**：P0

---

#### 4.2.3 中期/长期记忆系统

**功能描述**：
- 实现 NPC 的中期记忆（重要事件的摘要）
- 实现 NPC 的长期记忆（角色背景、关系网络）
- 记忆的检索和使用机制

**前置条件**：
- 短期记忆系统
- 事件记录系统（用于识别重要事件）

**依赖关系**：
- NPC 互相对话功能可以增强此功能
- NPC 关系网络功能依赖此功能

**技术实现**：
- 记忆分层设计（短期、中期、长期）
- 记忆生成和更新服务
- 记忆检索和融合逻辑

**优先级**：P0

---

#### 4.2.6 记忆可解释性系统（未来）

**功能描述**：
- 实现记忆提取过程的可解释性
- 记录每次记忆提取的过程和结果
- 对比不同记忆提取方式的优劣
- 提供记忆提取过程的文字化展示
- 支持记忆提取策略的持续优化

**前置条件**：
- 短期/中期/长期记忆系统

**依赖关系**：
- 记忆管理AI系统依赖此功能
- 可增强现有记忆系统的可靠性

**技术实现**：
- 记忆提取日志系统
- 提取方式对比分析服务
- 可解释性展示界面
- 提取策略评估机制

**优先级**：P1

---

#### 4.2.7 记忆快速索引系统（未来）

**功能描述**：
- 实现基于记忆的对话历史快速检索
- 支持自然语言查询历史（如"咱们上次聊过什么"）
- 同一NPC不同主题对话的智能管理
- 用户无需手动管理对话历史，通过自然语言即可获取
- **替代当前"最近N条历史事件"的上下文构建方式**

**当前实现**：
- 对话上下文构建：获取最近 20 条历史事件（`getRecentEvents(sessionId, limit = 20)`）
- 上下文限制：默认 20 条事件，可配置（`contextLimit = 20`）
- 问题：随着对话历史增长，简单的"最近N条"方式无法有效利用历史信息

**未来改进**：
- **基于记忆的上下文构建**：
  - 使用记忆索引快速检索相关历史
  - 根据当前对话主题，智能选择相关历史记录
  - 不再依赖简单的"最近N条"，而是基于语义相关性
- **上下文配置策略**：
  - 策略1：最近N条事件（当前方式，简单但有限）
  - 策略2：记忆索引 + 相关历史（智能检索）
  - 策略3：短期记忆 + 记忆索引（混合方式）
  - 策略4：完整记忆系统（短期+中期+长期+索引）

**前置条件**：
- 中期/长期记忆系统
- 对话历史记录功能

**依赖关系**：
- 对话管理增强功能依赖此功能
- 聊天历史展示优化依赖此功能
- **对话上下文构建功能依赖此功能**（替代当前"最近N条事件"方式）

**技术实现**：
- 记忆索引表设计
- 自然语言查询解析
- 记忆与对话历史的关联检索
- 上下文记忆快速加载
- **上下文构建服务重构**：
  - 从`getRecentEvents`改为`buildContextWithMemoryIndex`
  - 支持基于记忆索引的上下文构建
  - 支持Agent级别的上下文配置

**优先级**：P0

---

#### 4.2.8 记忆管理AI系统（未来）

**功能描述**：
- 使用AI来管理和优化记忆提取过程
- 自动对比和优化不同的记忆提取策略
- 根据对话质量动态调整记忆提取方式
- 实现"永久聊天"的核心能力

**前置条件**：
- 记忆可解释性系统
- 长期记忆系统

**依赖关系**：
- 这是实现"永久聊天"功能的关键组件
- 可增强所有记忆相关功能

**技术实现**：
- AI记忆管理服务
- 提取策略自动优化算法
- 记忆质量评估系统
- 持续学习和改进机制

**优先级**：P0

---

#### 4.2.4 工具调用能力

**功能描述**：
- NPC 可以调用外部工具（搜索、知识库、计算等）
- 工具的定义和注册机制
- 工具调用的权限和安全控制

**前置条件**：
- 对话系统（基础）
- 用户认证增强（用于权限控制）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 多 NPC 世界功能可以增强工具调用场景
- 后续行动系统依赖此功能

**技术实现**：
- 工具接口定义
- 工具注册和管理服务
- LLM Function Calling 集成

**优先级**：P1

---

#### 4.2.4.2 用户自定义 API Key 功能（未来）

**功能描述**：
- 用户可以在自己的账户中配置和管理自己的 API Key
- 支持为不同的 Agent 配置不同的 API Key
- 支持全局 API Key（所有 Agent 默认使用）和 Agent 级别 API Key（特定 Agent 使用）
- 支持多个 API Key 配置（故障转移）
- API Key 加密存储（不在数据库中明文存储）
- 用户可以选择使用自己的 API Key 或使用平台提供的 API Key

**核心价值**：
- **成本控制**：用户使用自己的 API Key，平台不承担 LLM 调用成本
- **灵活配置**：用户可以为不同 Agent 配置不同的 API Key
- **隐私保护**：用户的 API Key 加密存储，平台无法查看
- **故障转移**：支持配置多个 API Key，自动故障转移

**前置条件**：
- 用户认证增强（JWT Token）
- 密码加密功能（用于 API Key 加密）
- 工具调用能力（用于调用 LLM API）

**依赖关系**：
- 依赖用户认证增强（用于用户身份识别）
- 依赖密码加密功能（用于 API Key 加密存储）
- 可以独立开发，不阻塞其他功能

**技术实现**：

- **数据库设计**：
  - `user_api_keys` 表：存储用户的 API Key
    - `id`：记录ID
    - `user_id`：用户ID
    - `provider`：提供商（openrouter/openai/deepseek）
    - `api_key_encrypted`：加密后的 API Key（使用 bcrypt 或 AES 加密）
    - `api_key_hash`：API Key 的哈希值（用于标识，不存储完整 Key）
    - `is_default`：是否为默认 API Key（BOOLEAN）
    - `is_active`：是否启用（BOOLEAN）
    - `usage_count`：使用次数（可选）
    - `last_used_at`：最后使用时间（可选）
    - `created_at`：创建时间
    - `updated_at`：更新时间
  
  - `agent_api_keys` 表：存储 Agent 级别的 API Key（可选）
    - `id`：记录ID
    - `agent_id`：Agent ID
    - `user_api_key_id`：关联的用户 API Key ID（外键）
    - `created_at`：创建时间

- **API Key 加密**：
  - 使用 AES-256 加密存储 API Key
  - 加密密钥存储在环境变量中（`API_KEY_ENCRYPTION_KEY`）
  - 或者使用 bcrypt 哈希（但无法解密，只能验证）
  - **推荐**：使用 AES-256 加密，支持解密使用

- **API Key 管理服务**：
  - `UserApiKeyService.js`：用户 API Key 管理服务
    - `createApiKey(userId, provider, apiKey)`：创建 API Key
    - `getApiKeys(userId, provider)`：获取用户的 API Key 列表
    - `getDefaultApiKey(userId, provider)`：获取默认 API Key
    - `setDefaultApiKey(userId, apiKeyId)`：设置默认 API Key
    - `deleteApiKey(userId, apiKeyId)`：删除 API Key
    - `encryptApiKey(apiKey)`：加密 API Key
    - `decryptApiKey(encryptedApiKey)`：解密 API Key

- **LLMService 修改**：
  - 修改 `callLLMAPI` 函数，支持传入用户 API Key
  - 优先级：Agent 级别 API Key > 用户默认 API Key > 平台 API Key
  - 示例：
    ```javascript
    async function callLLMAPI(provider, model, systemPrompt, messages, timeout, userApiKey) {
      // 优先使用用户 API Key
      const apiKey = userApiKey || process.env[config.apiKeyEnv];
      // ... 调用 API
    }
    ```

- **Agent 创建和更新**：
  - Agent 创建时可以指定使用的 API Key
  - Agent 更新时可以修改 API Key
  - 如果未指定，使用用户的默认 API Key 或平台 API Key

- **API 设计**：
  - `POST /api/v1/users/api-keys` - 创建用户 API Key
    - 请求参数：`provider`、`apiKey`、`isDefault`（可选）
  - `GET /api/v1/users/api-keys` - 获取用户的 API Key 列表
    - 支持按提供商筛选：`?provider=openrouter`
  - `GET /api/v1/users/api-keys/:id` - 获取 API Key 详情（不返回完整 Key）
  - `PUT /api/v1/users/api-keys/:id` - 更新 API Key（更新 Key 或设置默认）
  - `DELETE /api/v1/users/api-keys/:id` - 删除 API Key
  - `PUT /api/v1/users/api-keys/:id/default` - 设置默认 API Key
  - `POST /api/v1/agents/:id/api-key` - 为 Agent 设置 API Key
  - `DELETE /api/v1/agents/:id/api-key` - 移除 Agent 的 API Key

**用户体验**：

- **配置 API Key**：
  1. 用户进入"设置"页面
  2. 选择"API Key 管理"
  3. 选择提供商（OpenRouter、OpenAI、DeepSeek）
  4. 输入 API Key（支持多个，用逗号分隔）
  5. 选择是否设为默认
  6. 保存后，API Key 加密存储

- **Agent 级别配置**：
  1. 创建或编辑 Agent 时
  2. 可以选择使用哪个 API Key
  3. 选项：使用默认 API Key、使用平台 API Key、选择特定 API Key
  4. 保存后，该 Agent 使用指定的 API Key

- **API Key 管理**：
  - 用户可以查看所有配置的 API Key（不显示完整 Key，只显示部分）
  - 用户可以启用/禁用 API Key
  - 用户可以设置默认 API Key
  - 用户可以查看 API Key 使用统计（如果启用）

**安全考虑**：

- **加密存储**：
  - API Key 必须加密存储，不能明文存储
  - 使用 AES-256 加密，密钥存储在环境变量中
  - 数据库管理员无法查看用户的 API Key

- **权限控制**：
  - 用户只能管理自己的 API Key
  - API Key 操作需要 JWT Token 验证
  - 验证用户身份，防止越权访问

- **API Key 验证**：
  - 创建 API Key 时，可以验证 API Key 是否有效（可选）
  - 验证方式：调用对应提供商的健康检查 API

- **使用限制**：
  - 可以限制每个用户最多配置的 API Key 数量
  - 可以限制每个 API Key 的使用频率（防止滥用）

**应用场景**：

- **个人使用**：用户使用自己的 API Key，不消耗平台资源
- **企业使用**：企业用户使用企业 API Key，统一管理成本
- **多账户管理**：用户有多个账户的 API Key，统一管理
- **成本分摊**：平台和用户分摊 LLM 调用成本

**实现步骤**：

1. **阶段一：数据库和加密**（1周）
   - 创建 `user_api_keys` 表
   - 实现 API Key 加密和解密功能
   - 实现 UserApiKeyService 基础功能

2. **阶段二：API 实现**（1周）
   - 实现 API Key 管理的所有 API
   - 实现权限验证和错误处理
   - 实现 API Key 验证功能（可选）

3. **阶段三：LLMService 集成**（1周）
   - 修改 LLMService，支持用户 API Key
   - 实现优先级逻辑（Agent > 用户默认 > 平台）
   - 测试 API Key 切换功能

4. **阶段四：前端实现**（1周）
   - 实现 API Key 管理页面
   - 实现 Agent 创建/编辑时的 API Key 选择
   - 实现 API Key 使用统计（可选）

**优先级**：P1（如果用户有强烈需求，可以提升为 P0）

**保密等级**：公开（✅ 可以）- 标准功能，无创新点

---

#### 4.2.4.1 工作流 Agent 生成器（未来）

**功能描述**：
- 用户输入工作流生成规则（一步一步，可能还有分支）
- 用户输入生成样例（完整对应规则）
- 系统自动生成一个工作流 Agent，该 Agent 能够按照规则执行工作流
- 支持复杂工作流：
  - **顺序步骤**：按顺序执行多个步骤
  - **分支条件**：根据条件选择不同的执行路径
  - **循环迭代**：重复执行某些步骤
  - **并行执行**：同时执行多个步骤
  - **错误处理**：处理执行失败的情况
- 生成的 Agent 能够：
  - 理解用户输入
  - 按照规则执行工作流
  - 处理分支和条件
  - 调用工具和外部服务
  - 返回执行结果

**核心价值**：
- **零代码工作流**：用户无需编程，通过规则和样例即可创建复杂工作流
- **智能理解**：通过样例学习，Agent 能够理解规则并正确执行
- **灵活扩展**：支持复杂的工作流模式（分支、循环、并行等）
- **自动化执行**：生成的 Agent 可以自动执行工作流，无需人工干预

**前置条件**：
- 工具调用能力（Function Calling）
- NPC 创建功能
- 对话系统（基础）

**依赖关系**：
- 依赖工具调用能力来执行工作流步骤
- 可以作为 NPC 创建功能的增强
- 可以独立开发，不阻塞其他功能

**技术实现**：

- **工作流定义格式**（JSON/YAML）：
  ```json
  {
    "name": "代码审查工作流",
    "description": "自动审查代码并生成报告",
    "steps": [
      {
        "id": "step1",
        "name": "读取代码",
        "type": "action",
        "action": "read_file",
        "params": {
          "filePath": "{{input.filePath}}"
        }
      },
      {
        "id": "step2",
        "name": "代码审查",
        "type": "llm_call",
        "prompt": "请审查以下代码，找出潜在问题：\n{{step1.result}}",
        "model": "anthropic/claude-sonnet-4.5"
      },
      {
        "id": "step3",
        "name": "判断是否需要修复",
        "type": "condition",
        "condition": "{{step2.result.hasIssues}}",
        "branches": [
          {
            "condition": true,
            "nextStep": "step4"
          },
          {
            "condition": false,
            "nextStep": "step5"
          }
        ]
      },
      {
        "id": "step4",
        "name": "生成修复建议",
        "type": "llm_call",
        "prompt": "基于审查结果，生成修复建议：\n{{step2.result}}"
      },
      {
        "id": "step5",
        "name": "生成报告",
        "type": "action",
        "action": "create_file",
        "params": {
          "filePath": "review_report.md",
          "content": "{{step2.result}}"
        }
      }
    ]
  }
  ```

- **样例定义格式**：
  ```json
  {
    "workflowId": "workflow_123",
    "examples": [
      {
        "input": {
          "filePath": "src/utils.js",
          "code": "function add(a, b) { return a + b; }"
        },
        "output": {
          "step1": {
            "result": "function add(a, b) { return a + b; }"
          },
          "step2": {
            "result": {
              "hasIssues": false,
              "review": "代码简洁，无问题"
            }
          },
          "step3": {
            "branch": false
          },
          "step5": {
            "result": {
              "filePath": "review_report.md",
              "content": "代码审查通过"
            }
          }
        }
      }
    ]
  }
  ```

- **Agent 生成流程**：
  1. **规则解析**：解析工作流定义，理解步骤、分支、条件等
  2. **样例学习**：使用 LLM 分析样例，理解规则的实际执行方式
  3. **Prompt 生成**：根据规则和样例生成 Agent 的 systemPrompt
  4. **工具注册**：注册工作流中需要的工具（如 read_file、create_file 等）
  5. **Agent 创建**：创建新的 Agent，配置 systemPrompt 和工具
  6. **验证测试**：使用样例验证生成的 Agent 是否正确

- **工作流执行引擎**：
  - `WorkflowEngine.js`：工作流执行引擎
  - 支持步骤执行、分支判断、循环迭代、并行执行
  - 支持变量替换（`{{step1.result}}`）
  - 支持错误处理和重试

- **数据库设计**：
  - `workflows` 表：存储工作流定义
    - `id`：工作流ID
    - `user_id`：用户ID
    - `name`：工作流名称
    - `description`：工作流描述
    - `definition`：工作流定义（JSON）
    - `examples`：样例数据（JSON）
    - `generated_agent_id`：生成的 Agent ID
    - `created_at`：创建时间
    - `updated_at`：更新时间
  
  - `workflow_executions` 表：存储工作流执行记录（可选）
    - `id`：执行ID
    - `workflow_id`：工作流ID
    - `agent_id`：Agent ID
    - `input`：输入数据（JSON）
    - `output`：输出数据（JSON）
    - `status`：状态（running/success/fail）
    - `error_message`：错误信息（如果失败）
    - `created_at`：创建时间
    - `completed_at`：完成时间

- **API 设计**：
  - `POST /api/v1/workflows` - 创建工作流定义
  - `POST /api/v1/workflows/:id/generate-agent` - 生成工作流 Agent
  - `GET /api/v1/workflows` - 获取用户的工作流列表
  - `GET /api/v1/workflows/:id` - 获取工作流详情
  - `PUT /api/v1/workflows/:id` - 更新工作流定义
  - `DELETE /api/v1/workflows/:id` - 删除工作流
  - `POST /api/v1/workflows/:id/execute` - 执行工作流（可选，用于测试）
  - `GET /api/v1/workflows/:id/executions` - 获取执行历史（可选）

**用户体验**：

- **创建工作流**：
  1. 用户进入"创建工作流"页面
  2. 用户输入工作流名称和描述
  3. 用户通过可视化界面或 JSON 编辑器定义工作流规则
  4. 用户输入样例（输入和输出）
  5. 点击"生成 Agent"按钮
  6. 系统自动生成 Agent，显示生成结果
  7. 用户可以使用生成的 Agent 执行工作流

- **可视化工作流编辑器**（可选）：
  - 拖拽式界面，用户可以通过拖拽创建步骤
  - 连接步骤，定义执行顺序和分支
  - 配置每个步骤的参数和条件
  - 实时预览工作流结构

- **工作流执行**：
  - 用户与生成的 Agent 对话
  - Agent 理解用户输入，按照工作流规则执行
  - Agent 返回执行结果
  - 用户可以在对话中查看执行进度和结果

**应用场景**：

- **代码审查工作流**：
  - 规则：读取代码 → 审查代码 → 判断是否有问题 → 生成报告或修复建议
  - 样例：提供代码审查的输入输出样例
  - 生成的 Agent 可以自动审查代码

- **文档生成工作流**：
  - 规则：收集信息 → 整理结构 → 生成文档 → 格式化输出
  - 样例：提供文档生成的输入输出样例
  - 生成的 Agent 可以自动生成文档

- **数据处理工作流**：
  - 规则：读取数据 → 清洗数据 → 分析数据 → 生成报告
  - 样例：提供数据处理的输入输出样例
  - 生成的 Agent 可以自动处理数据

- **自动化测试工作流**：
  - 规则：编写测试用例 → 执行测试 → 收集结果 → 生成报告
  - 样例：提供测试的输入输出样例
  - 生成的 Agent 可以自动执行测试

**技术挑战**：

- **规则理解**：如何让 LLM 准确理解工作流规则
- **样例学习**：如何通过样例学习规则的实际执行方式
- **分支处理**：如何正确处理复杂的分支和条件逻辑
- **错误处理**：如何处理执行失败和异常情况
- **变量替换**：如何正确处理步骤之间的数据传递

**实现方案**：

- **方案A（推荐）**：基于 LLM 的规则理解和执行
  - 使用 LLM 理解工作流规则和样例
  - 生成详细的 systemPrompt，描述工作流执行逻辑
  - Agent 在执行时，LLM 根据 systemPrompt 和当前状态决定下一步
  - 优点：灵活，支持复杂逻辑
  - 缺点：依赖 LLM 的理解能力，可能不够精确

- **方案B**：基于规则引擎的执行
  - 解析工作流定义，构建执行计划
  - 使用规则引擎执行工作流
  - Agent 负责与用户交互，规则引擎负责执行
  - 优点：精确，可预测
  - 缺点：需要实现规则引擎，复杂度较高

- **方案C（混合）**：LLM + 规则引擎
  - LLM 负责理解用户输入和生成输出
  - 规则引擎负责执行工作流步骤和分支判断
  - Agent 作为协调者，调用规则引擎执行步骤
  - 优点：结合两者优势
  - 缺点：实现复杂度较高

**优先级**：P0（核心创意功能，高优先级）

**保密等级**：保密（❌ 不能）- **核心创意**：工作流 Agent 生成的核心算法和实现方式

---

#### 4.2.10 API 使用情况监控功能（未来）

**功能描述**：
- **API Key 状态监控**：显示每个 API Key 的状态（正常使用/已禁用）
- **API Key 使用量统计**：统计每个 API Key 的调用次数、成功次数、失败次数
- **API Key 管理界面**：用户可以查看和管理所有配置的 API Key
- **使用量可视化**：以图表形式展示 API Key 的使用趋势和分布
- **故障转移统计**：统计 API Key 故障转移的次数和原因

**当前问题**：
- 用户无法看到有多少个 API Key 是正常使用的
- 用户无法看到有多少个 API Key 已经被禁用
- 用户无法看到每个 API Key 分别有多少用量
- 用户无法了解 API Key 的使用情况和健康状态

**核心价值**：
- **API Key 管理**：帮助用户了解和管理所有配置的 API Key
- **成本控制**：通过使用量统计，帮助用户控制 API 调用成本
- **故障诊断**：通过故障转移统计，帮助用户发现和解决 API Key 问题
- **资源优化**：通过使用量分析，帮助用户优化 API Key 配置

**前置条件**：
- 多 API Key 故障转移功能（已实现）
- LLM API 调用功能（已实现）
- 用户认证增强（用于权限控制）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 依赖多 API Key 故障转移功能（用于统计故障转移）
- 可以增强 API 限流功能（基于使用量进行限流）

**技术实现**：
- **数据库设计**：
  - `api_key_usage` 表：存储 API Key 使用记录
    - `id`：记录ID
    - `provider`：提供商（openrouter/openai/deepseek）
    - `api_key_index`：API Key 索引（第几个 Key）
    - `api_key_hash`：API Key 的哈希值（用于标识，不存储完整 Key）
    - `status`：状态（active/disabled/error）
    - `call_count`：调用次数
    - `success_count`：成功次数
    - `fail_count`：失败次数
    - `last_used_at`：最后使用时间
    - `last_error_at`：最后错误时间
    - `last_error_code`：最后错误码（401/403/429/timeout等）
    - `created_at`：创建时间
    - `updated_at`：更新时间
  
  - `api_key_usage_log` 表：存储详细的 API Key 使用日志（可选）
    - `id`：日志ID
    - `provider`：提供商
    - `api_key_index`：API Key 索引
    - `api_key_hash`：API Key 的哈希值
    - `status`：调用状态（success/fail）
    - `error_code`：错误码（如果失败）
    - `response_time`：响应时间（毫秒）
    - `timestamp`：时间戳
  
- **API 设计**：
  - `GET /api/v1/admin/api-keys` - 获取所有 API Key 状态和使用量
    - 返回格式：包含每个 API Key 的状态、使用量、最后使用时间等
    - 支持按提供商筛选
    - 支持按状态筛选（active/disabled/error）
  - `GET /api/v1/admin/api-keys/:provider` - 获取指定提供商的 API Key 列表
  - `GET /api/v1/admin/api-keys/:provider/:index` - 获取指定 API Key 的详细信息
  - `GET /api/v1/admin/api-keys/usage-stats` - 获取使用量统计（按时间范围）
    - 支持按天/周/月统计
    - 支持按提供商统计
  - `GET /api/v1/admin/api-keys/failover-stats` - 获取故障转移统计
    - 统计每个 API Key 的故障转移次数和原因
  - `PUT /api/v1/admin/api-keys/:provider/:index/status` - 更新 API Key 状态（启用/禁用）
    - 请求参数：`status`（active/disabled）
  - `GET /api/v1/admin/api-keys/health` - 获取 API Key 健康状态概览
    - 返回：正常使用的数量、已禁用的数量、有错误的数量

- **使用量统计逻辑**：
  - 每次调用 LLM API 时，记录 API Key 的使用情况
  - 统计每个 API Key 的调用次数、成功次数、失败次数
  - 记录最后使用时间和最后错误时间
  - 根据错误码判断 API Key 状态（401/403 → disabled，429 → rate_limit，timeout → error）

- **前端实现**：
  - **API Key 管理页面**：
    - 显示所有配置的 API Key（按提供商分组）
    - 每个 API Key 显示：状态、使用量、最后使用时间、最后错误时间
    - 支持启用/禁用 API Key
    - 支持查看详细使用日志
  - **使用量统计图表**：
    - 按时间范围显示使用量趋势（折线图）
    - 按提供商显示使用量分布（饼图）
    - 显示故障转移统计（柱状图）
  - **健康状态概览**：
    - 显示正常使用的 API Key 数量
    - 显示已禁用的 API Key 数量
    - 显示有错误的 API Key 数量
    - 显示总体健康状态（健康/警告/错误）

**用户体验**：
- **查看 API Key 状态**：用户可以一目了然地看到所有 API Key 的状态
- **查看使用量**：用户可以查看每个 API Key 的使用量统计
- **管理 API Key**：用户可以启用/禁用 API Key，优化配置
- **故障诊断**：用户可以通过故障转移统计发现和解决 API Key 问题
- **成本控制**：用户可以通过使用量统计控制 API 调用成本

**应用场景**：
- **API Key 管理**：用户需要管理多个 API Key，了解每个 Key 的状态和使用情况
- **成本控制**：用户需要了解 API 调用成本，优化 API Key 配置
- **故障诊断**：用户需要诊断 API Key 问题，了解故障转移原因
- **资源优化**：用户需要优化 API Key 配置，提高系统稳定性

**优先级**：P1

---

#### 4.2.9 后续行动系统（未来）

**功能描述**：
- 将对话中产生的想法转化为实际任务（如开发软件、创建项目、生成书籍等）
- 支持对话成果的后续发展（打印、导出、执行等）
- 提供实时反馈和进度跟踪
- 即使没有完整功能，也要提供实时反馈机制

**前置条件**：
- 工具调用能力
- 对话历史记录功能

**依赖关系**：
- 依赖工具调用能力来执行具体行动
- 可以增强对话的价值和实用性

**技术实现**：
- 想法提取和任务生成服务
- 任务执行引擎
- 进度跟踪和反馈系统
- 多种输出格式支持（软件、文档、书籍等）

**优先级**：P1

---

#### 4.2.9.1 Git 操作工具（未来）

**功能描述**：
- NPC 能够识别对话中的创意内容，并自动保存到 Git 仓库
- 支持创建文件、提交更改、推送到远程仓库
- 支持多种触发方式：
  - **主动触发**：用户明确要求保存到 Git（如"把这个想法保存到 Git"）
  - **智能识别**：NPC 自动识别创意内容并询问是否保存
  - **自动保存**：用户配置后，NPC 自动保存特定类型的创意
- 支持文件组织和管理：
  - 自动生成文件名和路径
  - 支持 Markdown、代码文件等多种格式
  - 支持创建目录结构
- 支持 Git 操作：
  - 创建或更新文件
  - 提交更改（自动生成 commit message）
  - 推送到远程仓库
  - 处理冲突和错误

**核心价值**：
- **无缝工作流**：对话中的创意直接转化为代码/文档，无需手动操作
- **知识沉淀**：自动保存有价值的对话内容，形成知识库
- **效率提升**：减少手动操作，提高工作效率
- **版本管理**：利用 Git 的版本控制能力，追踪创意演进

**前置条件**：
- 工具调用能力（Function Calling）
- 对话历史记录功能
- 用户认证增强（用于权限控制）

**依赖关系**：
- 依赖工具调用能力来执行 Git 操作
- 可以作为后续行动系统的一部分
- 可以独立开发，不阻塞其他功能

**技术实现**：

- **Git 工具定义**（Function Calling）：
  ```javascript
  // Git 工具函数定义
  const gitTools = [
    {
      name: "create_file_in_git",
      description: "在 Git 仓库中创建或更新文件",
      parameters: {
        type: "object",
        properties: {
          filePath: {
            type: "string",
            description: "文件路径（相对于仓库根目录）"
          },
          content: {
            type: "string",
            description: "文件内容"
          },
          commitMessage: {
            type: "string",
            description: "提交信息（可选，如果不提供则自动生成）"
          }
        },
        required: ["filePath", "content"]
      }
    },
    {
      name: "commit_and_push",
      description: "提交更改并推送到远程仓库",
      parameters: {
        type: "object",
        properties: {
          commitMessage: {
            type: "string",
            description: "提交信息"
          },
          branch: {
            type: "string",
            description: "分支名称（默认：main）"
          }
        },
        required: ["commitMessage"]
      }
    }
  ];
  ```

- **Git 操作服务**：
  - `GitService.js`：封装 Git 操作（使用 `simple-git` 库）
  - 支持创建文件、提交、推送
  - 错误处理和冲突处理
  - 权限验证（确保用户有权限操作 Git）

- **内容识别和提取**：
  - 使用 LLM 识别对话中的创意内容
  - 提取关键信息（标题、内容、类型等）
  - 生成合适的文件名和路径
  - 生成 commit message

- **数据库设计**（可选，用于记录操作历史）：
  - `git_operations` 表：记录 Git 操作历史
    - `id`：操作ID
    - `user_id`：用户ID
    - `agent_id`：Agent ID
    - `session_id`：会话ID
    - `operation_type`：操作类型（create_file/commit/push）
    - `file_path`：文件路径
    - `commit_message`：提交信息
    - `status`：状态（success/fail）
    - `error_message`：错误信息（如果失败）
    - `created_at`：创建时间

- **配置管理**：
  - 用户配置 Git 仓库路径
  - 用户配置 Git 用户名和邮箱
  - 用户配置自动保存规则（哪些类型的创意自动保存）
  - 用户配置 Git 操作权限（是否允许自动推送）

- **API 设计**：
  - `POST /api/v1/tools/git/create-file` - 创建文件
  - `POST /api/v1/tools/git/commit-push` - 提交并推送
  - `GET /api/v1/tools/git/operations` - 获取操作历史
  - `PUT /api/v1/users/:id/git-config` - 更新 Git 配置

**用户体验**：

- **主动触发**：
  - 用户："把这个想法保存到 Git"
  - NPC 识别内容，询问文件路径和文件名
  - 用户确认后，NPC 创建文件并提交推送
  - 返回操作结果和 Git 链接

- **智能识别**：
  - NPC 识别到创意内容（如代码、设计思路、文档等）
  - NPC 询问："检测到创意内容，是否保存到 Git？"
  - 用户确认后，自动保存

- **自动保存**（用户配置后）：
  - 用户配置自动保存规则（如"所有代码片段自动保存"）
  - NPC 自动识别并保存，无需用户确认
  - 定期批量提交和推送

**安全考虑**：

- **权限控制**：
  - 用户必须明确授权 Git 操作权限
  - 每次操作前验证用户权限
  - 记录所有 Git 操作日志

- **路径限制**：
  - 限制文件路径范围（只能操作指定目录）
  - 防止路径遍历攻击
  - 验证文件路径合法性

- **内容验证**：
  - 验证文件内容大小限制
  - 验证文件类型（允许的文件扩展名）
  - 防止恶意代码注入

**实现步骤**：

1. **阶段一：基础 Git 操作**（1-2周）
   - 实现 Git 工具函数（创建文件、提交、推送）
   - 实现 GitService 服务层
   - 实现权限验证和错误处理

2. **阶段二：内容识别**（1周）
   - 实现内容识别和提取逻辑
   - 实现文件名和路径生成
   - 实现 commit message 生成

3. **阶段三：用户配置**（1周）
   - 实现 Git 配置管理
   - 实现自动保存规则配置
   - 实现操作历史记录

4. **阶段四：集成和优化**（1周）
   - 集成到对话系统
   - 优化用户体验
   - 添加错误处理和提示

**技术选型**：

- **Git 操作库**：`simple-git`（Node.js Git 操作库）
- **Function Calling**：使用 LLM 的 Function Calling 能力（如 OpenAI、Claude）
- **内容识别**：使用 LLM 识别和提取创意内容

**应用场景**：

- **代码生成**：对话中生成的代码自动保存到 Git
- **文档编写**：对话中产生的文档自动保存
- **创意记录**：设计思路、产品想法自动保存
- **知识管理**：对话中的知识点自动整理到 Git 仓库

**优先级**：P1（如果用户有强烈需求，可以提升为 P0）

**保密等级**：内部（⚠️ 仅内部）- 涉及工作流创新，可内部讨论，但不对外公开

---

#### 4.2.5 事件总线架构

**功能描述**：
- 实现事件总线，统一管理所有事件
- 支持事件订阅和发布
- 支持事件的可视化和分析

**前置条件**：
- 事件记录系统（基础）
- Redis 缓存（用于消息队列）

**依赖关系**：
- NPC 互相对话功能依赖此功能
- 多 NPC 世界功能依赖此功能
- 可以增强现有的事件记录系统

**技术实现**：
- 事件总线服务（消息队列，如 Redis Streams）
- 事件订阅和发布机制
- 事件可视化界面

**优先级**：P1

---

## 5. 社交与分享功能规划

### 5.1 功能目标

增强用户社交体验，支持对话分享和精炼分享，提升内容的传播价值。

**前置条件**：对话系统、对话历史记录

### 5.2 功能列表

#### 5.2.1 对话分享功能（未来）

**功能描述**：
- 支持分享完整对话记录
- 支持分享对话的精炼版本
- 分享链接生成和管理
- 分享权限控制（公开、仅链接、密码保护）

**前置条件**：
- 对话历史记录功能
- 对话管理增强（用于生成精炼版本）

**依赖关系**：
- 对话精炼分享功能依赖此功能
- 可独立开发，不阻塞其他功能

**技术实现**：
- 分享链接生成服务
- 分享内容渲染（网页版）
- 分享权限管理
- 分享统计和追踪

**优先级**：P1

---

#### 5.2.2 对话精炼分享（未来）

**功能描述**：
- AI自动生成对话摘要和精炼版本
- 用户自定义分享内容范围
- 支持多种精炼策略（关键点提取、主题总结、亮点提取等）

**前置条件**：
- 对话分享功能
- 记忆系统（用于理解对话重点）

**依赖关系**：
- 依赖对话分享功能
- 可以复用记忆系统的摘要能力

**技术实现**：
- 对话精炼服务（使用LLM）
- 精炼策略配置
- 精炼内容预览和编辑
- 精炼质量评估

**优先级**：P2

---

#### 5.2.3 Agent分享功能（未来）

**功能描述**：
- 支持分享完整的Agent（NPC）配置
- **两种分享方式**：
  - **分享给朋友**：通过链接分享，朋友可以通过链接查看和导入Agent
  - **分享到社区**：将Agent发布到社区，其他用户可以浏览、查看和导入（需要社区功能支持）
- 用户可选择分享等级：
  - **完整分享**：模型、提示词、对话记录和重构记忆一起分享
  - **部分分享（不含记忆）**：不分享记忆，其他全部分享（模型、提示词、对话记录）
  - **自定义记忆分享**：用户主动选择记忆部分，其他全部分享
- 分享链接生成和管理
- 分享权限控制（公开、仅链接、密码保护、仅好友）

**前置条件**：
- NPC创建功能
- 对话历史记录功能
- 记忆系统（用于记忆分享选项）
- **分享到社区**：需要社区功能支持（见 5.2.4）

**依赖关系**：
- **分享给朋友**：可独立开发，不依赖社区功能
- **分享到社区**：依赖社区功能（5.2.4），如果要做分享到社区，必须先做社区功能
- 依赖对话分享功能的基础设施
- 需要记忆系统支持（用于记忆选择和分享）

**技术实现**：
- **分享给朋友**（简单版，可先实现）：
  - Agent分享服务（包含配置打包）
  - 分享链接生成（唯一ID）
  - 分享内容渲染（网页版，可导入）
  - 分享权限管理（公开、仅链接、密码保护）
  - 分享统计和追踪（访问次数、导入次数）
  
- **分享到社区**（需要社区功能）：
  - 社区Agent展示页面
  - Agent搜索和筛选功能
  - Agent详情页（包含创建者信息、使用统计等）
  - 社区Agent导入功能
  - 社区Agent评分和评论（可选）

**用户体验**：
- **分享给朋友**：
  - 用户在Agent详情页点击"分享"按钮
  - 选择分享方式（链接分享、二维码分享）
  - 选择分享等级（完整/部分/自定义）
  - 生成分享链接，用户可以复制链接或生成二维码
  - 朋友通过链接访问，可以查看Agent信息并导入
  
- **分享到社区**：
  - 用户在Agent详情页点击"分享到社区"按钮
  - 填写Agent介绍、标签等信息
  - 选择分享等级和权限设置
  - 提交后Agent出现在社区中
  - 其他用户可以浏览、搜索、查看和导入

**重要说明**：
- **分享给朋友**功能可以独立实现，不需要社区功能
- **分享到社区**功能需要完整的社区功能支持（见 5.2.4）
- 如果决定做分享到社区，需要先实现社区功能的基础设施

**优先级**：P1

---

#### 5.2.4 智能生命社区功能（未来）

**功能描述**：
- 建立一个开放的社区平台，用户可以分享自己的Agent，浏览和导入其他用户的Agent
- **社区核心功能**：
  - 社区首页：展示所有公开分享的Agent
  - Agent搜索和筛选：按标签、类型、创建者等筛选
  - Agent详情页：查看Agent信息、创建者信息、使用统计等
  - Agent导入功能：一键导入其他用户分享的Agent
  - Agent评分和评论（可选）：用户可以对Agent进行评分和评论
- **社区与分享的关系**：
  - Agent分享功能中的"分享到社区"需要社区功能支持
  - 如果要做分享到社区，必须先实现社区功能的基础设施
  - 社区功能可以独立开发，不依赖其他高级功能

**前置条件**：
- NPC创建功能
- Agent分享功能（分享给朋友的基础功能）
- 用户认证增强（用于用户身份识别）

**依赖关系**：
- Agent分享功能中的"分享到社区"依赖此功能
- 可以独立开发，不依赖记忆系统、多NPC世界等高级功能
- 后续可以扩展为更复杂的社区功能（如用户同位体、NPC互相对话等）

**技术实现**：
- **社区数据库设计**：
  - `shared_agents` 表：存储社区中分享的Agent信息
  - `agent_tags` 表：Agent标签管理
  - `agent_imports` 表：记录Agent导入次数和用户
  - `agent_ratings` 表：Agent评分和评论（可选）
  
- **社区功能实现**：
  - 社区首页：展示所有公开分享的Agent（分页、排序）
  - Agent搜索：支持关键词搜索、标签筛选、类型筛选
  - Agent详情页：显示Agent完整信息、创建者信息、使用统计
  - Agent导入：一键导入功能，将分享的Agent复制到用户自己的Agent列表
  - 分享管理：用户可以管理自己分享的Agent（编辑、下架、查看统计）

**用户体验**：
- 浏览社区：用户可以浏览社区中所有公开分享的Agent
- 搜索Agent：用户可以搜索和筛选感兴趣的Agent
- 查看详情：用户可以查看Agent的详细信息、创建者信息、使用统计
- 导入Agent：用户可以一键导入其他用户分享的Agent到自己的列表
- 分享Agent：用户可以将自己的Agent分享到社区

**优先级**：P1（如果要做分享到社区功能，必须先实现此功能）

---

#### 5.2.5 智能生命社区 - 用户同位体功能（未来）

**功能描述**：
- 用户可以创建自己的"同位体"（Avatar Agent），代表用户在社区中
- 同位体是基于用户自己创建的Agent，但专门用于社区交互
- 其他用户可以与该同位体对话，就像与用户本人对话一样
- 同位体可以继承用户的记忆、性格、对话风格等特征
- 用户可以选择哪些Agent作为自己的同位体，以及同位体的公开程度

**核心概念**：
- **同位体（Avatar Agent）**：用户在社区中的AI代表，基于用户创建的Agent
- **智能生命社区**：一个开放的社区平台，用户可以放置自己的同位体，与其他用户的同位体交互
- **社区交互**：用户可以与社区中其他用户的同位体对话，也可以让自己的同位体与其他用户的同位体对话

**前置条件**：
- NPC创建功能
- 对话历史记录功能
- 记忆系统（用于继承用户特征）
- Agent分享功能（用于社区展示）
- 智能生命社区功能（5.2.4，社区基础设施）
- 多NPC世界功能（用于社区场景）

**依赖关系**：
- 依赖智能生命社区功能（5.2.4）的基础设施
- 依赖Agent分享功能的基础设施
- 需要记忆系统支持（用于继承用户特征）
- 需要多NPC世界功能（用于社区场景和NPC互相对话）
- 可以增强社交与分享功能的体验

**技术实现**：
- **社区数据库设计**：
  - `community_avatars` 表：存储用户同位体信息
  - `avatar_interactions` 表：记录同位体之间的交互
  - `community_scenes` 表：社区场景管理
  
- **同位体创建和管理**：
  - 用户可以选择已有Agent作为同位体，或创建新的同位体
  - 同位体可以继承用户的记忆和对话风格
  - 用户可以为同位体设置公开程度（公开、仅好友、私密）
  
- **社区功能**：
  - 社区首页：展示所有公开的同位体
  - 同位体详情页：查看同位体信息、对话历史、创建者信息
  - 与同位体对话：用户可以与社区中其他用户的同位体对话
  - 同位体互相对话：用户的同位体可以与其他用户的同位体自动对话（AI驱动）
  
- **权限和隐私**：
  - 用户可以选择哪些Agent作为同位体
  - 用户可以选择同位体的公开程度
  - 用户可以选择是否允许其他用户与自己的同位体对话
  - 用户可以选择是否允许自己的同位体与其他用户的同位体自动对话

**用户体验**：
- 创建同位体：用户可以选择已有Agent或创建新的Agent作为同位体
- 社区浏览：用户可以浏览社区中所有公开的同位体
- 与同位体对话：用户可以点击任意同位体，开始对话
- 同位体管理：用户可以管理自己的同位体，设置公开程度、更新信息等
- 社区互动：用户的同位体可以与其他用户的同位体在社区中自动交互

**应用场景**：
- **个人品牌**：用户创建自己的同位体，代表自己在社区中
- **知识分享**：用户创建专业领域的同位体，分享知识和经验
- **社交互动**：用户与社区中其他用户的同位体对话，建立社交关系
- **AI社区**：多个同位体在社区中自动交互，形成活跃的AI社区生态

**优先级**：P1

---

#### 5.2.6 好友功能（未来）

**功能描述**：
- 用户可以添加其他用户为好友
- **用户可以添加Agent（AI）为好友**：用户可以将自己创建的Agent或其他用户分享的Agent添加为好友
- 支持好友列表管理（添加、删除、查看）
- 支持好友状态（在线、离线、最近活跃时间）
- 支持通过用户ID或用户名搜索和添加好友
- 支持通过Agent ID或Agent名称搜索和添加Agent为好友
- 支持好友请求和确认机制（双向确认，Agent无需确认）
- **好友列表中区分显示人类用户和AI Agent**：在好友列表中明确标识好友的身份类型（人类/AI）

**前置条件**：
- 用户认证功能
- 用户管理功能
- NPC创建功能（用于添加Agent为好友）

**依赖关系**：
- 可独立开发，不依赖其他功能
- 群功能（5.2.7）可以依赖好友功能（如"仅好友可见"的群）
- Agent分享功能可以依赖好友功能（如"仅好友"分享）

**技术实现**：
- **数据库设计**：
  - `friendships` 表：存储好友关系
    - `id`：关系ID
    - `user_id`：用户ID
    - `friend_id`：好友ID（用户ID或Agent ID）
    - `friend_type`：好友类型（user/agent）
    - `status`：关系状态（pending/accepted/blocked）
    - `created_at`：创建时间
    - `accepted_at`：确认时间（Agent无需确认，自动接受）
  
  - `friend_requests` 表：存储好友请求（可选）
    - `id`：请求ID
    - `from_user_id`：发起请求的用户ID
    - `to_id`：接收请求的ID（用户ID或Agent ID）
    - `to_type`：接收者类型（user/agent）
    - `status`：请求状态（pending/accepted/rejected）
    - `created_at`：创建时间
    - `accepted_at`：确认时间（Agent自动接受）
  
- **API设计**：
  - `POST /api/v1/friends/request` - 发送好友请求
    - 请求参数：`friendId`（用户ID或Agent ID）、`friendType`（user/agent）
    - Agent好友请求自动接受，无需确认
  - `POST /api/v1/friends/accept` - 接受好友请求（仅用于用户好友）
  - `POST /api/v1/friends/reject` - 拒绝好友请求（仅用于用户好友）
  - `GET /api/v1/friends` - 获取好友列表
    - 返回格式：包含好友类型（user/agent）、好友信息（用户信息或Agent信息）
    - 支持按类型筛选（只显示用户好友、只显示Agent好友、显示全部）
  - `DELETE /api/v1/friends/:friendId` - 删除好友
    - 支持删除用户好友和Agent好友
  - `GET /api/v1/friends/search` - 搜索用户或Agent（用于添加好友）
    - 支持搜索用户（按用户名或用户ID）
    - 支持搜索Agent（按Agent名称或Agent ID）
    - 返回结果中包含类型标识（user/agent）

- **前端实现**：
  - **好友列表UI**：
    - 显示所有好友（用户和Agent）
    - **身份标识**：在好友列表中明确标识好友身份
      - 用户好友：显示"人类"标识或用户图标
      - Agent好友：显示"AI"标识或Agent图标
    - 支持按类型筛选（只显示用户好友、只显示Agent好友、显示全部）
    - 支持按状态筛选（在线、离线）
  - **添加好友UI**：
    - 支持搜索用户和Agent
    - 搜索结果中显示类型标识（用户/AI）
    - 点击添加后，Agent自动添加成功，用户需要等待确认
  - **好友详情**：
    - 用户好友：显示用户信息、在线状态、最近活跃时间
    - Agent好友：显示Agent信息、头像、人设、最后对话时间

**用户体验**：
- **添加好友**：
  - 用户可以搜索其他用户，发送好友请求
  - 用户可以搜索Agent（自己创建的或其他用户分享的），添加为好友
  - Agent好友添加后立即生效，无需确认
  - 用户好友需要等待对方确认
- **好友列表**：
  - 用户可以查看自己的好友列表（包含用户和Agent）
  - **身份区分**：好友列表中明确标识每个好友的身份类型
    - 用户好友：显示"人类"标识、用户头像、用户名
    - Agent好友：显示"AI"标识、Agent头像、Agent名称
  - 支持按类型筛选（只显示用户好友、只显示Agent好友、显示全部）
  - 支持按状态筛选（在线、离线）
- **好友状态**：
  - 用户好友：显示在线状态和最近活跃时间
  - Agent好友：显示最后对话时间（Agent始终"在线"）
- **好友管理**：
  - 用户可以删除好友、屏蔽好友等
  - 支持删除用户好友和Agent好友

**应用场景**：
- **用户社交**：用户可以添加其他用户为好友，建立社交关系
- **AI陪伴**：用户可以添加Agent为好友，将常用的Agent加入好友列表，方便快速访问
- **混合好友列表**：用户的好友列表可以同时包含人类好友和AI好友，统一管理

**优先级**：P1

---

#### 5.2.7 群功能（未来）

**功能描述**：
- 用户可以创建群组
- **用户和Agent都可以加入群**：群成员可以是用户，也可以是Agent
- 支持群管理功能（创建、加入、退出、踢出成员）
- 支持群设置（群名称、群描述、群头像、权限设置）
- 支持群成员管理（查看成员列表、设置管理员、权限管理）

**前置条件**：
- 用户认证功能
- NPC创建功能（Agent可以加入群）
- 好友功能（可选，用于"仅好友"的群）

**依赖关系**：
- 群体会话功能（5.2.8）依赖此功能
- 可以依赖好友功能（如"仅好友可见"的群）
- 可以独立开发，不依赖记忆系统等高级功能

**技术实现**：
- **数据库设计**：
  - `groups` 表：存储群组信息
    - `id`：群组ID
    - `name`：群组名称
    - `description`：群组描述
    - `avatar_url`：群组头像
    - `creator_id`：创建者用户ID
    - `type`：群组类型（public/private/invite_only）
    - `max_members`：最大成员数
    - `created_at`：创建时间
    - `updated_at`：更新时间
  
  - `group_members` 表：存储群成员关系
    - `group_id`：群组ID
    - `member_id`：成员ID（用户ID或Agent ID）
    - `member_type`：成员类型（user/agent）
    - `role`：成员角色（owner/admin/member）
    - `joined_at`：加入时间
    - `left_at`：离开时间（如果已离开）
  
  - `group_invitations` 表：存储群邀请（可选）
    - `group_id`：群组ID
    - `inviter_id`：邀请者ID
    - `invitee_id`：被邀请者ID
    - `status`：邀请状态（pending/accepted/rejected）
    - `created_at`：创建时间

- **API设计**：
  - `POST /api/v1/groups` - 创建群组
  - `GET /api/v1/groups` - 获取用户的群组列表
  - `GET /api/v1/groups/:groupId` - 获取群组详情
  - `PUT /api/v1/groups/:groupId` - 更新群组信息
  - `DELETE /api/v1/groups/:groupId` - 解散群组
  - `POST /api/v1/groups/:groupId/members` - 加入群组
  - `DELETE /api/v1/groups/:groupId/members/:memberId` - 退出或踢出成员
  - `GET /api/v1/groups/:groupId/members` - 获取群成员列表
  - `PUT /api/v1/groups/:groupId/members/:memberId/role` - 设置成员角色

**用户体验**：
- 创建群组：用户可以创建群组，设置群名称、描述、权限等
- 加入群组：用户可以搜索和加入公开群组，或通过邀请加入私密群组
- 添加Agent到群：用户可以将自己的Agent添加到群中
- 群管理：群主和管理员可以管理群成员、设置权限等
- 群列表：用户可以查看自己加入的所有群组

**应用场景**：
- **学习小组**：用户创建学习群，添加学习相关的Agent
- **兴趣社区**：用户创建兴趣群，添加相关领域的Agent
- **协作项目**：用户创建项目群，添加助手Agent
- **社交聊天**：用户创建聊天群，添加陪伴Agent

**优先级**：P1

---

#### 5.2.8 群体会话功能（未来）

**功能描述**：
- 支持群组内的群体会话（多人对话）
- **参与者可变**：与固定会话不同，群体会话的参与者可能会变动（有人加入、有人退出）
- 支持用户和Agent在群组中发送消息
- 支持群组消息历史记录
- 支持@提及功能（@用户或@Agent）
- 支持消息通知（新消息提醒）

**核心区别**：
- **固定会话（当前实现）**：
  - 参与者固定（user + agent），参与者不变
  - Session ID 通过参与者列表匹配（JSON匹配）
  - 同一参与者组合只有一个Session
  
- **群体会话（新功能）**：
  - 参与者可变，可能有多个用户和多个Agent
  - Session ID 固定（绑定到群组ID），不随参与者变化
  - 参与者变动不影响Session ID
  - 需要记录参与者的加入和退出历史

**前置条件**：
- 群功能（5.2.7）
- 对话系统（基础）
- 事件记录系统（基础）

**依赖关系**：
- 依赖群功能（5.2.7）
- 可以独立开发，不依赖记忆系统等高级功能
- 后续可以扩展为更复杂的群组功能（如群组记忆、群组Agent等）

**技术实现**：
- **数据库设计**：
  - `group_sessions` 表：存储群组会话
    - `id`：会话ID（固定，绑定到群组）
    - `group_id`：群组ID（外键）
    - `created_at`：创建时间
    - `last_active_at`：最后活动时间
    - `message_count`：消息总数
  
  - `group_session_participants` 表：存储群体会话的参与者（动态）
    - `session_id`：会话ID
    - `participant_id`：参与者ID（用户ID或Agent ID）
    - `participant_type`：参与者类型（user/agent）
    - `joined_at`：加入时间
    - `left_at`：离开时间（如果已离开）
    - `is_active`：是否活跃（当前在群中）
  
  - `group_events` 表：存储群组消息事件（扩展events表或新建）
    - `id`：事件ID
    - `session_id`：会话ID（群组会话）
    - `from_id`：发送者ID（用户ID或Agent ID）
    - `from_type`：发送者类型（user/agent）
    - `content`：消息内容
    - `mentions`：@提及列表（JSON数组）
    - `timestamp`：时间戳

- **会话管理**：
  - 群组创建时自动创建群体会话（固定Session ID）
  - 成员加入时，在`group_session_participants`中添加记录
  - 成员退出时，更新`left_at`和`is_active`字段
  - 查询群组消息时，使用固定的Session ID查询

- **消息发送**：
  - 用户或Agent在群组中发送消息
  - 消息保存到`group_events`表，使用群组的固定Session ID
  - 支持@提及功能，解析消息中的@用户名或@Agent名
  - 发送消息后，更新群组会话的`last_active_at`

- **消息历史**：
  - 查询群组消息时，使用群组的固定Session ID
  - 支持分页查询（按时间倒序）
  - 支持搜索功能（搜索群组内的消息）

**与固定会话的区别**：

| 特性 | 固定会话（当前） | 群体会话（新功能） |
|------|----------------|------------------|
| 参与者 | 固定（user + agent） | 可变（多个user和agent） |
| Session ID | 通过参与者匹配 | 固定（绑定群组ID） |
| 参与者变动 | 不支持 | 支持（加入/退出） |
| 查询方式 | JSON匹配participants | 直接使用Session ID |
| 使用场景 | 一对一对话 | 群组对话 |

**用户体验**：
- 群组聊天：用户在群组中发送消息，所有成员都能看到
- 添加Agent：用户可以将Agent添加到群组，Agent可以参与对话
- 消息历史：用户可以查看群组的历史消息
- @提及：用户可以@其他成员或Agent
- 消息通知：新消息时通知群组成员

**应用场景**：
- **学习讨论**：学习群中，用户和Agent一起讨论问题
- **项目协作**：项目群中，用户和助手Agent协作完成任务
- **社交聊天**：聊天群中，用户和陪伴Agent一起聊天
- **知识分享**：知识群中，用户和专家Agent分享知识

**优先级**：P1

---

## 6. 知识管理功能规划

### 6.1 功能目标

建立AI技术知识库，供公司内部使用，帮助团队了解和学习AI相关技术。

**前置条件**：基础功能（可独立开发）

**说明**：此功能为**公司内部使用**，不面向用户。

### 6.2 功能列表

#### 6.2.1 AI技术知识库（未来，公司内部）

**功能描述**：
- 建立AI技术表格/文档管理系统（公司内部）
- 跟踪热门AI技术和趋势
- 提供技术实现原理说明
- 整理学习资源（教程、论文、代码示例等）
- 提供技术的通俗解释（降低学习门槛）

**前置条件**：
- 基础功能（可独立开发）

**依赖关系**：
- 可完全独立开发，不依赖其他功能
- 可以作为工具调用能力的知识来源（内部参考）

**技术实现**：
- 知识库数据库设计（内部系统）
- 技术文档管理系统
- 搜索和检索功能
- 内容更新和维护机制

**优先级**：P2（内部工具，优先级较低）

---

## 7. 内容审核功能规划

### 7.1 功能目标

确保平台内容安全，防止违规内容传播，保护用户和平台安全。

**前置条件**：对话系统、用户认证增强

### 7.2 功能列表

#### 7.2.1 内容审核系统（未来）

**功能描述**：
- 实现AI内容判定机制（自动检测违规内容）
- 用户封号功能（针对违规用户）
- 多国家/地区内容策略（根据法律法规调整）
- 内容认证和权限管理（针对允许内容的特殊认证）

**前置条件**：
- 对话系统（需要审核对话内容）
- 用户认证增强（用于用户管理和封号）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 建议在用户规模扩大前实现

**技术实现**：
- AI内容审核服务（使用LLM或专门的内容审核API）
- 违规内容检测规则引擎
- 用户封号和管理系统
- 多地区策略配置
- 内容认证和权限系统

**优先级**：P0（在用户规模扩大前）

---

## 8. 长期愿景

### 8.1 产品愿景

打造一个沉浸式的 AI NPC 交互平台，让用户能够与多个具有独特人设和记忆的 AI 角色进行深度对话，满足学习、陪伴、娱乐等多种需求。

### 8.2 技术愿景

- **可扩展架构**：支持水平扩展，支持大规模用户
- **智能化**：AI 能力不断增强，NPC 行为更加自然
- **可视化**：丰富的可视化界面，展示 NPC 的行为和思维过程
- **开放平台**：支持第三方插件和扩展

### 8.3 功能愿景

#### 8.3.1 记忆系统演进

- **短期记忆**：最近对话的上下文（规划中，依赖对话系统）
- **中期记忆**：重要事件的摘要和关联（规划中，依赖短期记忆）
- **长期记忆**：角色背景、关系网络、知识库（规划中，依赖中期记忆）
- **记忆可解释性**：记忆提取过程记录和对比（未来，依赖记忆系统）
- **记忆快速索引**：基于记忆的对话历史检索（未来，依赖中期/长期记忆）
- **记忆管理AI**：AI自动管理和优化记忆提取（未来，依赖记忆可解释性）
- **永久聊天**：通过记忆管理实现与AI的永久对话能力（未来，依赖记忆管理AI）

#### 8.3.2 交互方式演进

- **文本对话**：基础的文本对话（✅ 已实现）
- **对话管理增强**：选中文字开启新对话、对话分支管理（未来，依赖文本对话、记忆系统）
- **聊天历史优化**：微信式展示、记忆索引查询（未来，依赖文本对话、记忆系统）
- **多模态交互**：支持图片、语音、视频（未来，依赖文本对话）
- **动作系统**：NPC 可以执行动作和任务（未来，依赖工具调用能力）
- **后续行动**：想法转化为实际任务（未来，依赖工具调用能力）
- **情感系统**：NPC 具有情感状态和表达（未来，依赖记忆系统）

#### 8.3.3 世界系统演进

- **单人世界**：用户与 NPC 一对一对话（✅ 已实现）
- **多 NPC 世界**：用户与多个 NPC 共存在场景中（规划中，依赖单人世界）
- **NPC 社区**：NPC 之间形成社区和关系网络（未来，依赖多 NPC 世界、长期记忆）
- **世界规则**：世界具有物理规则、时间系统、事件系统（未来，依赖事件总线架构）

---

## 9. 技术演进方向

### 9.1 架构演进

- **当前**：单体架构，简单实现 ✅
- **演进路径 1**：引入缓存、消息队列（依赖：数据量增长、性能需求）
- **演进路径 2**：微服务架构，事件驱动（依赖：事件总线架构、多 NPC 世界）
- **未来**：分布式系统，支持大规模并发（依赖：微服务架构、监控系统）

### 9.2 技术栈演进

- **数据库**：MySQL（✅ 当前）→ 引入 Redis 缓存（依赖：性能需求）→ 引入 NoSQL（如 MongoDB）（依赖：复杂数据结构需求）
- **缓存**：无（✅ 当前）→ Redis 缓存（依赖：性能优化需求）→ Redis 集群（依赖：大规模并发）
- **消息队列**：无（✅ 当前）→ Redis Streams（依赖：事件总线架构）→ RabbitMQ / Kafka（依赖：大规模事件处理）
- **监控**：基础日志（✅ 当前）→ 错误日志和监控（✅ V1.5 简单版）→ 完整的监控和告警系统（依赖：系统稳定性需求）

### 9.3 AI 能力演进

- **LLM 模型**：OpenRouter 统一入口（✅ 当前）→ 支持更多提供商（依赖：用户需求）→ 用户自定义 API Key（依赖：权限系统）
- **Prompt 工程**：基础 system prompt（✅ 当前）→ Prompt 优化工具（依赖：用户需求）→ 智能 Prompt 优化（依赖：工具调用能力）
- **多模态**：文本对话（✅ 当前）→ 支持图片（依赖：LLM 模型支持）→ 支持语音、视频（依赖：基础设施）
- **Agent 框架**：基础实现（✅ 当前）→ 集成 LangChain（依赖：工具调用需求）→ 完整 Agent 框架（依赖：多 NPC 世界）

---

## 10. 用户反馈收集

### 10.1 反馈渠道 ✅ V1.5

- **应用内反馈**：在应用中提供反馈入口 ✅ V1.5
- **用户调研**：定期进行用户调研（未来）
- **数据分析**：分析用户行为数据（未来）
- **社区反馈**：建立用户社区（如 Discord、微信群）（未来）

**V1.5 实现**：
- 反馈提交功能（Bug、功能建议、使用问题）
- 反馈分类和状态管理
- 自动附加用户环境信息

**实现方案**：详见 [V1.5 版本规划 - 用户反馈](./v1.5/06-用户反馈实现方案.md)

### 10.2 反馈处理流程

```
收集反馈 ✅ V1.5
  ↓
分类和优先级评估（未来）
  ↓
产品规划（未来）
  ↓
开发实现（未来）
  ↓
用户通知（未来）
```

---

## 11. 竞品分析

### 11.1 竞品跟踪

- **Character.AI**：多角色对话平台
- **Replika**：AI 陪伴应用
- **ChatGPT**：通用对话助手

### 11.2 差异化策略

- **更灵活的 NPC 创建**：用户可以完全自定义 NPC 的人设和模型
- **事件驱动架构**：为未来扩展预留更多可能性
- **记忆系统**：实现分层的记忆系统，NPC 具有持续的记忆
- **多 NPC 世界**：支持多 NPC 共存和互相对话
- **数据永久保留**：承诺永久保留用户数据，除非用户主动删除
- **Agent 持续优化**：承诺随着技术发展，持续优化已有 Agent

---

## 12. 商业模式（未来考虑）

### 12.1 免费功能

- 基础 NPC 创建和对话
- 有限的对话次数
- 基础的记忆功能

### 12.2 付费功能（未来考虑）

- 无限对话次数
- 高级记忆系统
- 更多 LLM 模型选择
- 优先技术支持
- 数据导出和分析功能
- **会员用户数据保护**：会员用户的数据不会被用于模型训练（见 2.2.5）

---

## 13. 版本规划状态

### 13.1 V1.5 版本（当前规划）

**状态**：✅ 已规划并实现

**功能清单**：
- ✅ 密码功能（bcrypt 加密）
- ✅ JWT Token 认证
- ✅ API 限流（简单版）
- ✅ NPC 编辑和删除
- ✅ 对话搜索功能（不做筛选）
- ✅ 用户反馈功能
- ✅ 数据导入导出功能
- ✅ 错误日志和监控（简单版）
- ✅ 数据备份机制（简单版）

**详细文档**：请参考 [V1.5 版本规划](./v1.5/README.md)

### 13.2 未来版本

**数据管理增强**：
- 对话筛选、高级搜索
- 对话管理增强（选中文字开启新对话）
- 聊天历史展示优化（微信式展示、记忆索引）

**记忆系统**：
- 短期、中期、长期记忆
- 记忆可解释性系统
- 记忆快速索引系统
- 记忆管理AI系统（永久聊天核心）

**多 NPC 世界**：
- 场景管理、NPC 互相对话
- NPC 关系网络

**工具与扩展**：
- LLM Function Calling
- API 使用情况监控功能（API Key 状态监控、使用量统计、管理界面）
- 后续行动系统（想法转化为实际任务）
- 事件总线架构

**社交与分享**：
- 对话分享功能
- 对话精炼分享
- Agent分享功能（分享给朋友/分享到社区，完整分享/部分分享/自定义记忆分享）
- 智能生命社区功能（社区中分享Agent）
- 好友功能（添加好友、好友列表管理）
- 群功能（创建群组、用户和Agent都可以加入）
- 群体会话功能（参与者可变，固定Session ID）
- 智能生命社区 - 用户同位体功能（社区中放置用户自己的Agent）

**知识管理**：
- AI技术知识库（公司内部）

**安全与审核**：
- 内容审核系统（AI判定、封号功能）
- 会员用户数据保护功能（数据隔离、不用于模型训练）

---

## 14. 相关文档

- [V1 产品文档](./v1/README.md) - V1 版本完整产品文档
- [V1.5 版本规划](./v1.5/README.md) - V1.5 版本详细规划
- [V1 产品概述](./v1/01-产品概述.md) - V1 产品定义和目标
- [V1 功能需求](./v1/03-功能需求.md) - V1 功能需求详细说明

---

**文档维护**：后续规划变更时，需同步更新本文档和产品规划文档。

