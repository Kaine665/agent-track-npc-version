# 未来版本规划

**文档版本**：v1.2  
**最后更新**：2025-01-XX
**相关文档**：[V1 产品文档](./v1/README.md)

---

## 说明

本文档描述的是**潜在的功能演进路线图**，而非严格的版本划分。功能之间可能存在依赖关系，某些功能是其他功能的前置条件。路线图可能产生多个分支，根据实际需求、优先级和资源情况灵活选择开发路径。

**核心原则**：
- 功能是**连续谱**，而非离散版本
- 功能之间存在**依赖关系**和**前置条件**
- 路线图可能产生**多个分支**，可以并行开发
- 根据实际需求**灵活选择**开发路径

当前已完成的基础功能请参考 [V1 产品文档](./v1/README.md)。  
**V1.5 版本规划**请参考 [V1.5 版本规划](./v1.5/README.md)。

---

## 功能保密等级说明

### 保密等级分类

| 等级 | 说明 | 是否可以对外分享 | 示例 |
|------|------|----------------|------|
| **公开（Public）** | 可以公开分享的功能，不涉及核心创意 | ✅ 可以 | 基础CRUD、搜索、数据导出等 |
| **内部（Internal）** | 可以内部讨论，但不对外公开 | ⚠️ 仅内部 | 部分优化功能、技术实现细节 |
| **保密（Confidential）** | 核心创意功能，需要保密 | ❌ 不能 | 记忆系统、多NPC世界等核心差异化功能 |
| **机密（Secret）** | 最高级别保密，绝对不能泄露 | ❌ 绝对不能 | 核心算法、独特创新点 |

### 重要性分类

| 等级 | 说明 | 对产品的影响 |
|------|------|------------|
| **核心（Core）** | 核心功能，产品差异化关键 | 直接影响产品竞争力 |
| **重要（Important）** | 重要功能，但不是核心差异化 | 提升用户体验，但不是唯一性 |
| **次要（Secondary）** | 次要功能，可以公开 | 锦上添花，不影响核心价值 |

### 功能保密等级表格

| 功能名称 | 重要性 | 保密等级 | 是否可以对外分享 | 保密原因 |
|---------|--------|---------|----------------|---------|
| **安全与认证分支** |
| JWT Token 认证 | 重要 | 公开 | ✅ 可以 | 标准技术实现，无创新点 |
| 密码加密（bcrypt） | 重要 | 公开 | ✅ 可以 | 标准技术实现，无创新点 |
| API 限流 | 重要 | 公开 | ✅ 可以 | 标准技术实现，无创新点 |
| 会员用户数据保护功能 | 核心 | 内部 | ⚠️ 仅内部 | 涉及数据隐私策略，可内部讨论 |
| 内容审核系统 | 重要 | 公开 | ✅ 可以 | 标准功能，无创新点 |
| **数据管理分支** |
| NPC 编辑和删除 | 次要 | 公开 | ✅ 可以 | 基础CRUD功能 |
| 自动生成头像功能 | 次要 | 公开 | ✅ 可以 | 标准功能，无创新点 |
| 相似名称提醒机制 | 次要 | 公开 | ✅ 可以 | 用户体验优化 |
| 对话搜索功能 | 重要 | 公开 | ✅ 可以 | 标准搜索功能 |
| 对话筛选功能 | 重要 | 公开 | ✅ 可以 | 标准筛选功能 |
| 对话管理增强（选中文字开启新对话、对话分支） | 重要 | 内部 | ⚠️ 仅内部 | 涉及交互创新，但可内部讨论 |
| 聊天历史展示优化（微信式展示） | 重要 | 公开 | ✅ 可以 | 参考微信实现，无创新点 |
| 数据导入导出功能 | 重要 | 公开 | ✅ 可以 | 标准数据管理功能 |
| 知识库/内容管理功能 | 重要 | 公开 | ✅ 可以 | 标准知识管理功能 |
| **记忆系统分支** |
| 短期记忆系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：记忆系统的实现方式 |
| 中期记忆系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：记忆分层和提取策略 |
| 长期记忆系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：长期记忆的构建和管理 |
| 记忆可解释性系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：记忆提取过程的可解释性 |
| 记忆快速索引系统 | 核心 | 保密 | ❌ 不能 | **核心创意**：基于记忆的智能检索 |
| 记忆管理AI系统（永久聊天核心） | 核心 | 机密 | ❌ 绝对不能 | **最高机密**：AI自动管理记忆的核心算法 |
| **多 NPC 世界分支** |
| 多 NPC 世界场景 | 核心 | 保密 | ❌ 不能 | **核心创意**：多NPC世界的架构设计 |
| NPC 互相对话 | 核心 | 保密 | ❌ 不能 | **核心创意**：NPC之间的对话机制 |
| NPC 关系网络 | 核心 | 保密 | ❌ 不能 | **核心创意**：NPC关系网络的构建 |
| **工具与扩展分支** |
| 工具调用能力 | 重要 | 公开 | ✅ 可以 | 标准Function Calling实现 |
| API 使用情况监控功能 | 重要 | 公开 | ✅ 可以 | 标准监控功能 |
| 后续行动系统（想法转化为实际任务） | 重要 | 内部 | ⚠️ 仅内部 | 涉及工作流创新，可内部讨论 |
| 事件总线架构 | 重要 | 公开 | ✅ 可以 | 标准事件驱动架构 |
| **数据统计分支** |
| 基础数据统计 | 次要 | 公开 | ✅ 可以 | 标准统计功能 |
| 高级数据分析 | 次要 | 公开 | ✅ 可以 | 标准数据分析功能 |
| **对话交互增强分支** |
| 对话交互增强（连续发送、AI打断） | 重要 | 内部 | ⚠️ 仅内部 | 涉及交互创新，可内部讨论 |
| **用户反馈分支** |
| 用户反馈功能 | 重要 | 公开 | ✅ 可以 | 标准反馈功能 |
| **社交与分享分支** |
| 对话分享功能 | 重要 | 公开 | ✅ 可以 | 标准分享功能 |
| 对话精炼分享 | 重要 | 公开 | ✅ 可以 | 标准内容处理功能 |
| Agent分享功能（分享给朋友） | 重要 | 公开 | ✅ 可以 | 标准分享功能 |
| Agent分享功能（分享到社区） | 重要 | 公开 | ✅ 可以 | 标准社区功能 |
| 智能生命社区功能 | 核心 | 保密 | ❌ 不能 | **核心创意**：社区的概念和架构 |
| 好友功能 | 重要 | 公开 | ✅ 可以 | 标准社交功能 |
| 群功能 | 重要 | 公开 | ✅ 可以 | 标准群组功能 |
| 群体会话功能 | 重要 | 内部 | ⚠️ 仅内部 | 涉及会话架构创新，可内部讨论 |
| 智能生命社区 - 用户同位体功能 | 核心 | 机密 | ❌ 绝对不能 | **最高机密**：用户同位体的核心概念和实现 |
| **知识管理分支** |
| AI技术知识库（公司内部） | 次要 | 内部 | ⚠️ 仅内部 | 内部工具，不对外 |
| **运维支持分支** |
| 错误日志和监控 | 重要 | 公开 | ✅ 可以 | 标准监控功能 |
| 数据备份机制 | 重要 | 公开 | ✅ 可以 | 标准备份功能 |

### 保密原则

1. **核心创意保护**：
   - 记忆系统相关的所有功能都是核心创意，需要严格保密
   - 多NPC世界相关的功能是核心差异化，需要保密
   - 用户同位体功能是最高机密，绝对不能泄露

2. **可以公开的功能**：
   - 基础CRUD功能（编辑、删除、搜索等）
   - 标准技术实现（JWT、密码加密、API限流等）
   - 标准功能（分享、统计、监控等）

3. **内部讨论的功能**：
   - 涉及交互创新的功能（对话管理增强、连续发送等）
   - 涉及工作流创新的功能（后续行动系统）
   - 涉及架构创新的功能（群体会话）

4. **分享建议**：
   - **对外分享时**：只分享"公开"等级的功能
   - **内部讨论时**：可以讨论"内部"和"公开"等级的功能
   - **保密功能**：只在核心团队内部讨论，不对外泄露
   - **机密功能**：只在极少数核心人员中讨论，严格保密

---

## 0. 已知问题和漏洞

### ISSUE-001：NPC 类型与 System Prompt 的关联逻辑问题

**发现时间**：2025-01-XX  
**问题类型**：功能逻辑漏洞  
**优先级**：P1  
**状态**：待修复

**问题描述**：
- 当前实现中，无论是选择"通用"（general）还是"特定"（special）类型，systemPrompt 字段都是可选的
- 但实际上，"通用"类型应该不需要输入 systemPrompt，只有"特定"类型才需要输入 systemPrompt
- 这导致用户体验不一致：通用助手应该使用默认行为，不需要自定义人设

**影响范围**：
- 前端：`npc-frontend/src/pages/CreateAgent/CreateAgent.jsx` - 表单验证逻辑
- 后端：`npc-backend/services/AgentService.js` - 数据验证逻辑
- 产品文档：需要明确说明通用类型和特定类型的区别

**预期行为**：
- **通用类型（general）**：
  - systemPrompt 字段应该隐藏或禁用
  - 使用系统默认的通用助手 prompt
  - 用户只需要填写名称和模型即可
  
- **特定类型（special）**：
  - systemPrompt 字段必填
  - 用户必须输入自定义人设描述
  - 用于创建特定功能的 NPC（如学习教练、心理导师等）

**修复方案**：
1. 前端：根据选择的类型动态显示/隐藏 systemPrompt 字段
2. 后端：根据类型验证 systemPrompt 是否必填
3. 文档：更新产品文档，明确说明两种类型的区别和使用场景

**相关文档**：
- [V1 功能需求 - NPC 创建](./v1/03-功能需求.md)
- [V1 用户场景与用例 - 创建 NPC](./v1/02-用户场景与用例.md)

---


## 1. 功能路线图总览

### 1.1 潜在功能路线图

本文档描述的是一个**连续的功能演进谱系**，而非严格的版本划分。功能之间可能存在依赖关系，某些功能是其他功能的前置条件。路线图可能产生多个分支，根据实际需求和优先级灵活选择开发路径。

```
【已实现基础】✅
  ├─ NPC 创建、对话、历史记录
  ├─ 事件记录系统
  ├─ 基础登录/注册
  └─ API 适配层设计

【安全与认证分支】→ 前置条件：基础登录/注册
  ├─ JWT Token 认证 ✅ V1.5
  │   └─ 依赖：用户认证增强
  ├─ 密码加密（bcrypt）✅ V1.5
  │   └─ 依赖：用户认证增强
  ├─ Token 刷新机制（可选）
  │   └─ 依赖：JWT Token 认证
  ├─ API 限流和安全增强 ✅ V1.5（简单版）
  │   └─ 依赖：JWT Token 认证
  ├─ 会员用户数据保护功能（未来）
  │   ├─ 会员用户数据隔离和保护
  │   ├─ 数据使用策略管理
  │   ├─ 数据使用审计和合规
  │   └─ 依赖：会员/付费功能、用户认证增强
  └─ 内容审核系统（未来）
      ├─ AI内容判定机制（违规内容检测）
      ├─ 用户封号功能
      ├─ 多国家/地区内容策略
      ├─ 内容认证和权限管理
      └─ 依赖：对话系统、用户认证增强

【数据管理分支】→ 前置条件：基础功能
  ├─ NPC 编辑和删除 ✅ V1.5
  │   └─ 依赖：基础 NPC 创建
  ├─ 自动生成头像功能（未来）
  │   └─ 依赖：基础 NPC 创建
  ├─ 相似名称提醒机制（未来）
  │   └─ 依赖：基础 NPC 创建、名称唯一性检查
  ├─ 对话搜索功能 ✅ V1.5（不做筛选）
  │   └─ 依赖：对话历史记录
  ├─ 对话筛选功能（未来）
  │   └─ 依赖：对话搜索功能
  ├─ 对话管理增强（未来）
  │   ├─ 选中文字开启新对话
  │   ├─ 对话分支管理（从某段对话继续）
  │   ├─ 对话精炼和摘要生成
  │   └─ 依赖：对话历史记录、记忆快速索引系统
  ├─ 聊天历史展示优化（未来）
  │   ├─ 微信式聊天历史展示（上滑查看）
  │   ├─ 基于记忆的上下文展示
  │   └─ 依赖：对话历史记录、记忆快速索引系统
  └─ 数据导入导出功能 ✅ V1.5
      └─ 依赖：对话历史记录、NPC 数据

【记忆系统分支】→ 前置条件：对话系统
  ├─ 短期记忆系统
  │   └─ 依赖：对话历史记录、事件记录系统
  ├─ 中期记忆系统
  │   └─ 依赖：短期记忆系统、事件记录系统
  ├─ 长期记忆系统
  │   └─ 依赖：中期记忆系统、关系网络
  ├─ 记忆可解释性系统（未来）
  │   ├─ 记忆提取过程记录和对比
  │   ├─ 记忆提取方式对比分析
  │   └─ 依赖：短期/中期/长期记忆系统
  ├─ 记忆快速索引系统（未来）
  │   ├─ 基于记忆的对话历史检索
  │   ├─ 自然语言查询历史（"咱们上次聊过什么"）
  │   └─ 依赖：中期/长期记忆系统、对话历史记录
  └─ 记忆管理AI系统（未来）
      ├─ 使用AI管理记忆提取和优化
      ├─ 记忆提取策略自动优化
      └─ 依赖：记忆可解释性系统、长期记忆系统

【多 NPC 世界分支】→ 前置条件：单个 NPC 系统、记忆系统
  ├─ 多 NPC 世界场景
  │   └─ 依赖：NPC 创建、场景管理
  ├─ NPC 互相对话
  │   └─ 依赖：多 NPC 世界场景、短期记忆系统、事件总线
  └─ NPC 关系网络
      └─ 依赖：NPC 互相对话、长期记忆系统

【工具与扩展分支】→ 前置条件：对话系统、认证系统
  ├─ 工具调用能力
  │   └─ 依赖：LLM Function Calling、权限系统
  ├─ API 使用情况监控功能（未来）
  │   ├─ API Key 状态监控（正常使用/已禁用）
  │   ├─ API Key 使用量统计（调用次数、成功次数、失败次数）
  │   ├─ API Key 管理界面（查看、启用/禁用）
  │   ├─ 使用量可视化（图表展示）
  │   └─ 依赖：多 API Key 故障转移功能、LLM API 调用功能
  ├─ 后续行动系统（未来）
  │   ├─ 想法转化为实际任务（软件、项目、书籍等）
  │   ├─ 对话成果的后续发展（打印、导出、执行）
  │   ├─ 实时反馈和进度跟踪
  │   └─ 依赖：工具调用能力、对话历史记录
  └─ 事件总线架构
      └─ 依赖：事件记录系统、消息队列

【数据统计分支】→ 前置条件：基础功能、数据管理
  ├─ 基础数据统计（未来）
  │   └─ 依赖：对话历史记录、NPC 数据
  └─ 高级数据分析（未来）
      └─ 依赖：基础数据统计、数据导出功能

【对话交互增强分支】→ 前置条件：对话系统
  └─ 对话交互增强：支持用户连续发送和AI打断（未来）
      ├─ 支持用户连续发送多条消息
      ├─ 支持AI打断用户（AI回复过程中用户可继续发送）
      ├─ 消息队列管理
      └─ 依赖：对话系统、事件记录系统

【用户反馈分支】→ 前置条件：基础功能
  └─ 用户反馈功能 ✅ V1.5

【社交与分享分支】→ 前置条件：对话系统
  ├─ 对话分享功能（未来）
  │   ├─ 分享完整对话记录
  │   ├─ 分享对话精炼版本
  │   └─ 依赖：对话历史记录、对话管理增强
  ├─ 对话精炼分享（未来）
  │   ├─ AI自动生成对话摘要
  │   ├─ 自定义分享内容范围
  │   └─ 依赖：对话分享功能、记忆系统
  ├─ Agent分享功能（未来）
  │   ├─ 分享给朋友（链接分享，可独立实现）
  │   ├─ 分享到社区（需要社区功能支持）
  │   ├─ 完整分享（模型、提示词、对话记录、记忆）
  │   ├─ 部分分享（不含记忆）
  │   ├─ 自定义记忆分享
  │   └─ 依赖：NPC创建、对话历史记录、记忆系统（分享到社区需要社区功能）
  ├─ 智能生命社区功能（未来）
  │   ├─ 社区首页（展示分享的Agent）
  │   ├─ Agent搜索和筛选
  │   ├─ Agent详情页和导入功能
  │   └─ 依赖：NPC创建、Agent分享（分享给朋友）
  ├─ 好友功能（未来）
  │   ├─ 添加好友、好友列表管理
  │   ├─ 好友请求和确认机制
  │   └─ 依赖：用户认证
  ├─ 群功能（未来）
  │   ├─ 创建群组、群成员管理
  │   ├─ 用户和Agent都可以加入群
  │   └─ 依赖：用户认证、NPC创建、好友功能（可选）
  ├─ 群体会话功能（未来）
  │   ├─ 群组内多人对话
  │   ├─ 参与者可变（与固定会话不同）
  │   ├─ 固定Session ID（绑定群组）
  │   └─ 依赖：群功能、对话系统
  └─ 智能生命社区 - 用户同位体功能（未来）
      ├─ 用户创建自己的同位体（Avatar Agent）
      ├─ 社区中放置和展示同位体
      ├─ 用户与社区中其他用户的同位体对话
      ├─ 同位体之间自动交互（AI驱动）
      └─ 依赖：NPC创建、记忆系统、Agent分享、智能生命社区功能、多NPC世界

【知识管理分支】→ 前置条件：基础功能
  ├─ 知识库/内容管理功能（未来）
  │   ├─ 文档、数据库、图表等产出物存储
  │   ├─ RAG素材管理
  │   ├─ 内容与对话关联
  │   └─ 依赖：对话历史记录、文件存储系统、用户认证增强
  └─ AI技术知识库（未来，公司内部）
      ├─ AI技术表格/文档管理
      ├─ 热门AI技术跟踪
      ├─ 技术实现原理说明
      ├─ 学习资源整理
      ├─ 技术通俗解释
      └─ 依赖：基础功能（可独立开发，内部工具）

【运维支持分支】→ 前置条件：基础功能
  ├─ 错误日志和监控 ✅ V1.5（简单版）
  │   └─ 依赖：基础功能
  └─ 数据备份机制 ✅ V1.5（简单版）
      └─ 依赖：数据库已建立

【基础设施分支】→ 可独立或并行开发
  ├─ Redis 缓存
  ├─ 消息队列（Redis Streams）
  ├─ 监控和告警系统
  └─ 数据备份机制
```

### 1.2 功能依赖关系说明

**核心依赖链**：
- `基础功能` → `安全与认证` → `数据管理` → `记忆系统` → `多 NPC 世界`
- `基础功能` → `工具与扩展`（可并行）
- `基础功能` → `数据统计`（可并行）
- `基础功能` → `社交与分享`（可并行）
- `基础功能` → `知识管理`（可并行）
  - `知识库/内容管理` → `RAG功能`（可选，使用知识库作为RAG数据源）
  - `知识库/内容管理` → `工具调用能力`（可选，读取知识库内容）
  - `知识库/内容管理` → `后续行动系统`（可选，保存行动产生的产出物）
- `记忆系统` → `对话管理增强`（依赖记忆快速索引）
- `工具调用能力` → `后续行动系统`（依赖工具调用）

**可选分支**：
- 某些功能可以独立开发，不依赖其他功能
- 某些功能可以并行开发，互不干扰
- 某些功能是其他功能的增强，可以后续添加

**前置条件标注**：
- 每个功能分支都标注了前置条件
- 功能内部标注了依赖关系
- 开发时需确保前置条件已满足

### 1.3 功能开发建议

**并行开发路径**：
- `安全与认证` + `数据管理` + `数据统计` 可以并行开发（互不依赖）
- `工具调用能力` 可以独立开发（不阻塞其他功能）
- `基础设施分支`（Redis、消息队列、监控）可以提前准备

**顺序开发路径**：
- `短期记忆系统` → `中期记忆系统` → `长期记忆系统`（强依赖链）
- `多 NPC 世界场景` → `NPC 互相对话`（强依赖链）
- `事件记录系统` → `事件总线架构`（增强关系）

**灵活选择原则**：
- 根据用户反馈和业务需求选择优先级
- 某些功能可以简化实现，后续再增强
- 某些功能可以分阶段实现，先实现核心部分

---

## 2. 安全与认证功能规划

### 2.1 功能目标

增强用户认证安全性，完善权限验证机制，提升系统安全性。

**前置条件**：基础登录/注册功能已实现

**V1.5 版本状态**：✅ 已规划并实现

### 2.2 功能列表

#### 2.2.1 用户认证增强 ✅ V1.5

**功能描述**：
- 实现 JWT Token 进行用户认证
- 密码加密（bcrypt）
- Token 刷新机制（可选）
- 用户权限验证和数据隔离增强

**前置条件**：
- 基础登录/注册功能

**依赖关系**：
- 后续功能（API 限流、数据统计）依赖此功能

**技术实现**：
- JWT Token 生成和验证
- 密码哈希存储（bcrypt）
- Token 刷新机制（可选）
- 中间件实现 Token 验证

**实现方案**：详见 [V1.5 版本规划 - 密码功能](./v1.5/01-密码功能实现方案.md) 和 [V1.5 版本规划 - JWT认证](./v1.5/02-JWT认证实现方案.md)

**优先级**：P0

---

#### 2.2.2 基础数据统计

**功能描述**：
- 用户数据统计（NPC 数量、对话数量等）
- NPC 使用统计（对话次数、最后使用时间等）
- 简单的数据可视化（图表）

**前置条件**：
- 基础功能（NPC 创建、对话历史记录）
- 用户认证增强（可选，用于用户级别的统计）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 后续高级数据分析功能依赖此功能

**技术实现**：
- 统计数据表设计
- 统计 API 实现
- 前端图表组件（如 Chart.js）

**优先级**：P1

---

#### 2.2.3 API 限流和安全增强 ✅ V1.5（简单版）

**功能描述**：
- 实现 API 限流（用户级别、IP 级别）
- LLM API 特殊限流（防止成本过高）
- 增强 API 安全性（CORS、CSRF 防护）（基础实现）

**前置条件**：
- 用户认证增强（JWT Token）（用于用户级别限流）

**依赖关系**：
- 用户级别限流依赖 JWT Token 认证
- IP 级别限流可独立实现

**技术实现**：
- 限流中间件（express-rate-limit，内存存储）
- 安全中间件配置（基础）
- 监控和告警系统（未来）

**实现方案**：详见 [V1.5 版本规划 - API限流](./v1.5/03-API限流实现方案.md)

**扩展性**：
- 当前：内存存储（简单、零成本）
- 未来：可替换为 Redis（rate-limit-redis），接口不变

**优先级**：P0

---

#### 2.2.4 数据备份机制 ✅ V1.5（简单版）

**功能描述**：
- 实现定期数据备份（每日全量）
- 实现数据恢复工具（简单版）
- 备份文件管理（保留7天）

**前置条件**：
- 数据库已建立（基础功能）

**依赖关系**：
- 可独立开发，不依赖其他功能
- 建议在数据量增长前实现

**技术实现**：
- 数据库备份脚本（mysqldump）
- 数据恢复工具（简单版）
- 备份文件自动清理

**实现方案**：详见 [V1.5 版本规划 - 数据备份](./v1.5/09-数据备份实现方案.md)

**扩展性**：
- 当前：mysqldump + 本地文件（零成本）
- 未来：可接入云存储（OSS/S3），增量备份（binlog）

**优先级**：P0

---

#### 2.2.5 会员用户数据保护功能（未来）

**功能描述**：
- **会员用户数据保护**：保护开会员的用户的用户数据，不用于模型训练
- **数据使用标记**：在数据库中明确标记哪些用户数据可以用于模型训练，哪些不能
- **数据隔离机制**：确保会员用户的数据在数据收集、存储、处理等环节都被隔离和保护
- **数据使用策略管理**：管理员可以配置和管理数据使用策略，明确哪些数据可以用于训练

**核心承诺**：
- **会员用户数据保护**：开会员的用户的用户数据（对话记录、Agent配置、用户行为等）不会被用于模型训练
- **数据使用透明化**：用户可以在设置中查看自己的数据使用状态和保护状态
- **数据隔离保证**：会员用户的数据在系统层面被隔离，确保不会被误用于训练

**前置条件**：
- 用户认证功能
- 会员/付费功能（需要先实现会员标识）
- 数据收集和处理系统（如果未来需要收集数据用于训练）

**依赖关系**：
- 依赖会员/付费功能（用于识别会员用户）
- 可以独立开发，不阻塞其他功能
- 如果未来需要收集数据用于模型训练，必须先实现此功能

**技术实现**：
- **数据库设计**：
  - `users` 表扩展：
    - `is_premium`：是否为会员（BOOLEAN，默认 false）
    - `premium_expires_at`：会员到期时间（TIMESTAMP，可选）
    - `data_protection_enabled`：数据保护启用状态（BOOLEAN，默认 true，会员用户自动启用）
    - `data_usage_consent`：数据使用同意状态（BOOLEAN，默认 false，会员用户默认为 false）
  
  - `data_usage_policies` 表：存储数据使用策略（可选）
    - `id`：策略ID
    - `user_id`：用户ID（可选，如果为 null 则为全局策略）
    - `policy_type`：策略类型（training/analytics/sharing等）
    - `allowed`：是否允许（BOOLEAN）
    - `created_at`：创建时间
    - `updated_at`：更新时间
  
  - `data_usage_logs` 表：记录数据使用日志（可选，用于审计）
    - `id`：日志ID
    - `user_id`：用户ID
    - `data_type`：数据类型（conversation/agent/user_behavior等）
    - `usage_type`：使用类型（training/analytics/sharing等）
    - `allowed`：是否允许使用（BOOLEAN）
    - `timestamp`：时间戳
    - `reason`：原因（如果拒绝使用）

- **数据保护机制**：
  - **会员用户识别**：系统自动识别会员用户（`is_premium = true`）
  - **数据标记**：所有会员用户的数据自动标记为"受保护"（`data_protection_enabled = true`）
  - **数据使用检查**：在数据收集、处理、训练等环节，检查用户的数据保护状态
  - **数据隔离**：会员用户的数据在存储和处理时被隔离，确保不会被误用

- **API 设计**：
  - `GET /api/v1/users/:id/data-protection` - 获取用户数据保护状态
  - `PUT /api/v1/users/:id/data-protection` - 更新用户数据保护设置（仅管理员或用户本人）
  - `GET /api/v1/users/:id/data-usage-policy` - 获取用户数据使用策略
  - `PUT /api/v1/users/:id/data-usage-policy` - 更新用户数据使用策略
  - `GET /api/v1/admin/data-usage-stats` - 获取数据使用统计（管理员，用于审计）

- **数据使用检查中间件**：
  - 在数据收集和处理流程中，添加数据使用检查中间件
  - 检查用户是否为会员用户，如果是，则拒绝使用其数据用于训练
  - 记录数据使用日志，用于审计和合规

- **前端实现**：
  - **用户设置页面**：
    - 显示用户的数据保护状态（会员用户显示"已保护"）
    - 显示数据使用策略（哪些数据可以用于哪些用途）
    - 允许用户查看和更新数据使用同意状态（非会员用户）
  - **会员标识**：
    - 在用户界面中显示会员标识
    - 明确告知会员用户其数据受到保护

**业务规则**：
1. **会员用户自动保护**：用户开通会员后，自动启用数据保护（`data_protection_enabled = true`）
2. **数据使用默认拒绝**：会员用户的数据默认不允许用于模型训练（`data_usage_consent = false`）
3. **数据隔离保证**：会员用户的数据在系统层面被隔离，确保不会被误用于训练
4. **数据使用审计**：所有数据使用尝试都会被记录，用于审计和合规
5. **会员到期处理**：会员到期后，数据保护状态保持不变（用户可以选择继续保护或允许使用）

**用户体验**：
- **会员用户**：
  - 开通会员后，自动获得数据保护
  - 在用户设置中可以看到"数据保护已启用"的标识
  - 明确知道自己的数据不会被用于模型训练
  - 可以查看数据使用日志（如果启用）
  
- **非会员用户**：
  - 可以选择是否同意数据用于模型训练
  - 在用户设置中可以查看和更新数据使用同意状态
  - 可以选择开通会员以获得数据保护

**应用场景**：
- **数据隐私保护**：保护会员用户的隐私数据，不用于模型训练
- **合规要求**：满足数据保护和隐私法规的要求
- **用户信任**：增强用户对平台的信任，特别是对数据隐私的关注
- **会员权益**：作为会员的一项权益，提升会员价值

**重要说明**：
- **数据保护承诺**：平台明确承诺，会员用户的数据不会被用于模型训练
- **数据隔离机制**：在系统层面实现数据隔离，确保承诺得到执行
- **数据使用透明化**：用户可以在设置中查看自己的数据保护状态和使用策略
- **审计和合规**：记录所有数据使用尝试，用于审计和合规检查

**优先级**：P1（如果未来需要收集数据用于模型训练，则优先级提升为 P0）

---

---

## 3. 数据管理功能规划

### 3.1 功能目标

增强核心功能，提升用户体验，增加数据管理能力。

**前置条件**：基础功能（NPC 创建、对话历史记录）

**V1.5 版本状态**：✅ 已规划并实现

### 3.2 功能列表

#### 3.2.1 NPC 编辑和删除 ✅ V1.5

**功能描述**：
- 允许用户编辑 NPC 的配置（名称、人设、模型等）
- 允许用户删除 NPC
- 删除 NPC 时的数据清理策略（软删除或硬删除）

**前置条件**：
- NPC 创建功能

**依赖关系**：
- 删除功能需要考虑对话历史记录的关联
- 如果已实现记忆系统，需要考虑记忆数据的清理

**技术实现**：
- PUT /api/v1/agents/:id API
- DELETE /api/v1/agents/:id API
- 数据清理逻辑（软删除）

**实现方案**：详见 [V1.5 版本规划 - NPC编辑删除](./v1.5/04-NPC编辑删除实现方案.md)

**优先级**：P0

---

#### 3.2.1.1 自动生成头像功能（未来）

**功能描述**：
- 用户创建 NPC 时，可以根据 Agent 名称和 systemPrompt 自动生成头像
- 使用 AI 图像生成服务（如 DALL-E、Midjourney API、Stable Diffusion 等）
- 用户可以选择使用自动生成的头像，或手动上传/输入头像 URL
- 生成的头像可以保存到本地或云存储

**前置条件**：
- NPC 创建功能
- AI 图像生成 API（可选，也可以使用免费的头像生成服务）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 可以增强 NPC 创建的用户体验

**技术实现**：
- 集成 AI 图像生成 API（如 DALL-E、Stable Diffusion）
- 或使用免费头像生成服务（如 DiceBear、Avatar API）
- 头像生成服务封装（AvatarService）
- 前端添加"自动生成头像"按钮
- 头像缓存机制（避免重复生成）

**实现方案**：
- **方案 A（推荐）**：使用免费头像生成服务（DiceBear、Avatar API）
  - 优点：零成本、快速、稳定
  - 缺点：样式有限，不能完全根据 prompt 生成
  - 实现：根据 Agent 名称生成种子，调用头像 API
  
- **方案 B**：集成 AI 图像生成 API（DALL-E、Stable Diffusion）
  - 优点：可以根据 prompt 生成个性化头像
  - 缺点：需要 API Key，有成本，生成速度较慢
  - 实现：将 Agent 名称和 systemPrompt 组合成 prompt，调用图像生成 API

**用户体验**：
- 创建 NPC 时，显示"自动生成头像"按钮
- 点击后显示生成进度（如果使用 AI 生成）
- 生成完成后预览，用户可以选择使用或重新生成
- 支持多次生成，直到用户满意

**优先级**：P1

---

#### 3.2.1.2 相似名称提醒机制（未来）

**功能描述**：
- 用户创建 NPC 时，如果输入的名称与已有 NPC 名称相似，系统会提醒用户
- 提醒方式：前端实时检查，显示警告提示（非阻止提交）
- 相似度算法：使用字符串相似度算法（如 Levenshtein 距离、Jaro-Winkler 等）
- 用户可以忽略提醒继续创建，或修改名称

**前置条件**：
- NPC 创建功能
- 名称唯一性检查（已有）

**依赖关系**：
- 基于现有的名称唯一性检查功能
- 可以增强用户体验，避免用户创建重复的 NPC

**技术实现**：
- 后端：添加相似名称检查 API（`GET /api/v1/agents/similar-names?userId=xxx&name=xxx`）
- 前端：实时检查（输入时或失焦时）
- 相似度算法：使用字符串相似度库（如 `string-similarity`、`fuzzy-search`）
- 相似度阈值：建议 70% 以上相似度才提醒（可配置）

**实现方案**：
1. **后端实现**：
   - 在 `AgentService` 中添加 `findSimilarNames` 方法
   - 查询用户的所有 NPC 名称
   - 使用相似度算法计算相似度
   - 返回相似度超过阈值的名称列表

2. **前端实现**：
   - 在创建 NPC 表单中，名称输入框失焦时调用检查 API
   - 如果发现相似名称，显示警告提示（非错误提示）
   - 提示内容："检测到相似名称：'xxx'，是否继续创建？"
   - 用户可以点击"忽略"继续创建，或修改名称

**相似度算法选择**：
- **Levenshtein 距离**：计算两个字符串的编辑距离
- **Jaro-Winkler**：适合短字符串，对前缀相似度敏感
- **余弦相似度**：将字符串转换为向量后计算相似度
- **推荐**：使用 `string-similarity` 库，支持多种算法

**用户体验**：
- 输入名称时，实时检查（防抖处理，避免频繁请求）
- 发现相似名称时，显示友好的警告提示
- 提示中包含相似名称列表，用户可以点击查看详情
- 用户可以忽略提醒继续创建，或修改名称

**优先级**：P1

---

#### 3.2.2 短期记忆系统

**功能描述**：
- 实现 NPC 的短期记忆（最近 N 次对话的摘要）
- 在对话中使用短期记忆增强上下文
- 记忆的自动更新和管理
- **替代当前"最近N条历史事件"的上下文构建方式**

**当前实现**：
- 对话上下文构建：获取最近 20 条历史事件（`getRecentEvents(sessionId, limit = 20)`）
- 上下文限制：默认 20 条事件，可配置（`contextLimit = 20`）
- 问题：随着对话历史增长，简单的"最近N条"方式无法有效利用历史信息

**未来改进**：
- **基于记忆模型的上下文构建**：
  - 短期记忆：最近N次对话的摘要（替代当前"最近N条事件"）
  - 中期记忆：重要事件的摘要和关联
  - 长期记忆：角色背景、关系网络、知识库
  - 记忆快速索引：基于记忆的对话历史检索
- **上下文配置策略**：
  - 用户可以选择不同的上下文构建策略
  - 策略1：最近N条事件（当前方式，简单但有限）
  - 策略2：短期记忆 + 最近N条事件（混合方式）
  - 策略3：短期记忆 + 中期记忆 + 长期记忆（完整记忆系统）
  - 策略4：记忆快速索引 + 相关历史（智能检索）
- **Agent级别配置**：
  - 每个Agent可以配置自己的上下文构建策略
  - 不同Agent可以使用不同的记忆模型
  - 配置项：
    - `contextStrategy`: 上下文构建策略（recent_events/memory_hybrid/memory_full/memory_index/custom）
    - `contextLimit`: 上下文限制（如果使用recent_events策略）
    - `memoryConfig`: 记忆配置（如果使用记忆相关策略）

- **前端用户配置**：
  - **上下文窗口长度选择**：用户可以在前端选择上下文长度
    - 提供几个预设选项：短（10条）、中（20条）、长（50条）、超长（100条）、自定义
    - 用户可以根据对话历史长短、模型token限制等需求选择
    - 配置保存在用户设置中，可以全局应用或按Agent应用
  - **配置层级**：
    - **全局默认**：系统默认值（20条）
    - **用户设置**：用户个人偏好设置（覆盖全局默认）
    - **Agent配置**：Agent级别的配置（覆盖用户设置）
    - **会话临时**：当前会话的临时设置（覆盖Agent配置）
  - **前端UI**：
    - 在对话页面添加"上下文设置"按钮或下拉菜单
    - 显示当前上下文长度和策略
    - 允许用户快速切换上下文长度
    - 显示上下文使用情况（如"已使用 15/20 条"）

**前置条件**：
- 对话历史记录功能
- 事件记录系统（用于记忆触发）

**依赖关系**：
- 中期/长期记忆系统依赖此功能
- NPC 互相对话功能依赖此功能
- **对话上下文构建功能依赖此功能**（替代当前"最近N条事件"方式）

**技术实现**：
- 记忆表设计（memories 表）
- 记忆生成服务（使用 LLM 生成摘要）
- 记忆检索和更新逻辑
- **上下文构建服务重构**：
  - 从`getRecentEvents`改为`buildContextWithMemory`
  - 支持多种上下文构建策略
  - 支持Agent级别的上下文配置
  - 支持用户级别的上下文配置
  - 支持会话临时上下文配置

- **数据库设计**：
  - **Agent配置扩展**（`agents`表）：
    - `context_strategy`: 上下文构建策略（VARCHAR）
    - `context_limit`: 上下文限制（INT，如果使用recent_events策略）
    - `memory_config`: 记忆配置（JSON，如果使用记忆相关策略）
  
  - **用户设置扩展**（`users`表或新建`user_settings`表）：
    - `default_context_limit`: 用户默认上下文长度（INT）
    - `default_context_strategy`: 用户默认上下文策略（VARCHAR）
    - `context_preferences`: 上下文偏好设置（JSON）
  
  - **会话临时设置**（`sessions`表扩展或新建`session_settings`表）：
    - `session_id`: 会话ID
    - `context_limit`: 会话临时上下文长度（INT，可选）
    - `context_strategy`: 会话临时上下文策略（VARCHAR，可选）

- **配置优先级**：
  - 会话临时设置 > Agent配置 > 用户设置 > 全局默认
  - 如果某个层级未配置，使用下一层级的配置

- **API设计**：
  - `POST /api/v1/messages` - 发送消息（改进版，支持上下文策略）
    - 请求参数：`contextLimit`（可选，覆盖Agent配置）
    - 根据配置优先级构建上下文
  - `GET /api/v1/agents/:id/context-config` - 获取Agent的上下文配置
  - `PUT /api/v1/agents/:id/context-config` - 更新Agent的上下文配置
  - `GET /api/v1/users/:id/context-settings` - 获取用户的上下文设置
  - `PUT /api/v1/users/:id/context-settings` - 更新用户的上下文设置
  - `PUT /api/v1/sessions/:id/context-settings` - 设置会话临时上下文配置（可选）

- **前端实现**：
  - **上下文设置UI**：
    - 在对话页面添加"上下文设置"按钮或下拉菜单
    - 显示当前上下文长度和策略
    - 提供预设选项：短（10条）、中（20条）、长（50条）、超长（100条）、自定义
    - 允许用户快速切换上下文长度
    - 显示上下文使用情况（如"已使用 15/20 条"）
  - **设置保存**：
    - 用户选择后，保存到用户设置或会话临时设置
    - 发送消息时，将`contextLimit`参数传递给后端
  - **设置显示**：
    - 在对话页面显示当前上下文配置
    - 在Agent详情页显示Agent的上下文配置

**优先级**：P0

---

#### 3.2.3 对话搜索功能 ✅ V1.5（不做筛选）

**功能描述**：
- 支持搜索对话内容
- 支持关键词高亮显示
- 不做筛选功能（简化实现）

**前置条件**：
- 对话历史记录功能

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 数据导出功能可以复用搜索逻辑

**技术实现**：
- 全文搜索（MySQL FULLTEXT 索引）
- 搜索 API 实现
- 前端搜索界面

**实现方案**：详见 [V1.5 版本规划 - 对话搜索](./v1.5/05-对话搜索实现方案.md)

**优先级**：P0

---

#### 3.2.4 对话筛选功能（未来）

**功能描述**：
- 支持按时间范围筛选对话
- 支持按 NPC 筛选对话
- 支持按类型筛选对话

**前置条件**：
- 对话搜索功能

**优先级**：P1

---

#### 3.2.5 数据导入导出功能 ✅ V1.5

**功能描述**：
- 支持导出对话历史（JSON、TXT、Markdown 格式）
- 支持导出 NPC 配置
- 支持导入对话历史（包含 prompt、模型信息）
- 模型兼容性处理（如果模型不存在，提供替代方案）

**前置条件**：
- 对话历史记录功能
- NPC 数据管理功能

**依赖关系**：
- 可以复用对话搜索的逻辑
- 可独立开发，不阻塞其他功能

**技术实现**：
- 导出服务实现
- 导入服务实现（模型映射）
- 文件生成和下载
- 导出格式转换

**实现方案**：详见 [V1.5 版本规划 - 数据导入导出](./v1.5/07-数据导入导出实现方案.md)

**优先级**：P1

---

#### 3.2.6 对话管理增强（未来）

**功能描述**：
- 支持选中对话中的某段文字，开启新对话
- 提供对话分支管理功能（从某段对话继续发展）
- 支持对话精炼和摘要生成
- 用户可以选择开启新对话的方式（直接使用选中内容、或精炼当前聊天记录）

**前置条件**：
- 对话历史记录功能
- 记忆快速索引系统（用于上下文理解）

**依赖关系**：
- 依赖记忆快速索引系统来理解对话上下文
- 对话分享功能可以复用对话精炼能力

**技术实现**：
- 文本选中和提取功能
- 对话分支创建服务
- 对话精炼服务（使用LLM）
- 对话关联关系管理

**优先级**：P1

---

#### 3.2.7 聊天历史展示优化（未来）

**功能描述**：
- 实现微信式聊天历史展示（上滑查看所有历史）
- 基于记忆的上下文展示（AI上下文使用结构化记忆，而非完整历史）
- 用户可以通过自然语言查询历史（"咱们上次聊过什么"）
- 同一NPC不同主题对话的智能管理

**前置条件**：
- 对话历史记录功能
- 记忆快速索引系统

**依赖关系**：
- 依赖记忆快速索引系统来实现智能检索
- 对话管理增强功能可以增强此功能

**技术实现**：
- 聊天历史UI组件（无限滚动）
- 记忆索引与历史记录的关联展示
- 自然语言查询接口
- 对话主题自动分类

**优先级**：P1

---

#### 3.2.7.1 对话交互增强：支持用户连续发送和AI打断（未来）

**功能描述**：
- **支持用户连续发送多条消息**：用户可以在不等待AI回复的情况下，连续发送多条消息
- **支持AI打断用户**：AI正在生成回复时，用户仍然可以继续发送消息，AI会基于最新的消息上下文生成回复
- **消息队列管理**：后端需要管理待处理的消息队列，按顺序处理用户的多条消息
- **上下文合并**：AI回复时，需要合并用户连续发送的多条消息作为上下文

**当前限制**：
- 用户发送消息后，前端会设置`sending`状态为true，阻止用户继续发送
- 前端需要等待AI回复后，才能发送下一条消息
- 这导致对话体验不够流畅，无法实现自然的连续对话

**核心价值**：
- **更自然的对话体验**：用户可以像真实对话一样，连续表达自己的想法
- **提高对话效率**：用户不需要等待AI回复，可以快速连续发送多条消息
- **支持复杂对话场景**：用户可以一次性提供多个信息点，AI可以综合处理

**前置条件**：
- 对话系统（基础）
- 事件记录系统（基础）
- 消息发送API（基础）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 可以增强对话系统的用户体验
- 后续可以扩展为更复杂的对话管理功能（如对话分支、对话合并等）

**技术实现**：
- **前端改进**：
  - 移除`sending`状态对发送按钮的完全禁用
  - 允许用户在AI回复过程中继续发送消息
  - 显示"AI正在思考..."状态，但不阻止用户发送
  - 支持消息队列显示（显示待处理的消息）
  
- **后端改进**：
  - **消息队列管理**：
    - 为每个会话维护一个消息队列
    - 用户发送的消息先加入队列
    - 后端按顺序处理队列中的消息
    - 支持消息合并（如果用户连续发送多条消息，可以合并为一条上下文）
  
  - **并发控制**：
    - 同一会话的消息串行处理（防止消息顺序混乱）
    - 如果AI正在生成回复，新的用户消息加入队列等待
    - 如果AI已完成回复，立即处理队列中的下一条消息
  
  - **上下文构建**：
    - 如果用户连续发送多条消息，将这些消息合并为一条上下文
    - AI回复时，基于合并后的上下文生成回复
    - 支持消息分组（将连续的用户消息分组，AI回复时引用整组消息）

- **数据库设计**（可选，如果需要持久化队列）：
  - `message_queue` 表：存储待处理的消息队列
    - `id`：队列项ID
    - `session_id`：会话ID
    - `user_id`：用户ID
    - `agent_id`：Agent ID
    - `content`：消息内容
    - `status`：状态（pending/processing/completed）
    - `created_at`：创建时间
    - `processed_at`：处理时间

- **API设计**：
  - `POST /api/v1/messages` - 发送消息（改进版，支持队列）
    - 立即返回，不等待AI回复
    - 返回消息ID和队列状态
  - `GET /api/v1/messages/queue/:sessionId` - 获取消息队列状态（可选）
    - 返回队列中的消息数量和状态
  - `POST /api/v1/messages/batch` - 批量发送消息（可选）
    - 支持一次性发送多条消息

**用户体验**：
- **连续发送**：
  - 用户可以快速连续发送多条消息
  - 输入框始终可用，不会被禁用
  - 显示"AI正在思考..."提示，但不阻止发送
  
- **消息状态显示**：
  - 用户消息：立即显示，标记为"已发送"
  - AI回复：显示"正在生成..."状态，完成后显示完整回复
  - 队列状态：显示"还有X条消息待处理"（可选）
  
- **对话流程**：
  - 用户发送消息1 → 立即显示消息1
  - 用户发送消息2 → 立即显示消息2（不等待AI回复）
  - AI基于消息1和消息2生成回复 → 显示AI回复
  - 用户发送消息3 → 立即显示消息3
  - AI基于消息3生成回复 → 显示AI回复

**应用场景**：
- **快速提问**：用户可以快速连续提出多个问题，AI可以综合回答
- **补充信息**：用户在AI回复过程中，可以补充更多信息
- **复杂对话**：用户可以一次性提供多个信息点，AI可以综合处理
- **自然对话**：模拟真实对话场景，用户可以连续表达想法

**技术挑战**：
- **消息顺序**：确保消息按正确顺序处理，避免顺序混乱
- **上下文合并**：如何合理合并用户连续发送的多条消息
- **性能优化**：避免消息队列过长，影响响应速度
- **错误处理**：如果某条消息处理失败，如何处理后续消息

**实现方案**：
- **方案A（推荐）**：前端乐观更新 + 后端队列管理
  - 前端立即显示用户消息，不等待AI回复
  - 后端维护消息队列，按顺序处理
  - AI回复时，合并队列中的连续用户消息作为上下文
  - 优点：用户体验好，实现相对简单
  - 缺点：需要管理消息队列
  
- **方案B**：前端消息合并 + 后端批量处理
  - 前端检测用户连续发送，自动合并为一条消息
  - 后端处理合并后的消息
  - 优点：实现简单，不需要队列管理
  - 缺点：用户无法看到自己发送的多条消息

**优先级**：P1

---

#### 3.2.8 知识库/内容管理功能（未来）

**功能描述**：
- 用户可以存储和管理聊天产生的产出物，包括：
  - **文档**：聊天中生成的文档、文章、笔记等文本内容
  - **数据库**：聊天中产生的数据表结构、数据内容、SQL脚本等
  - **图表**：聊天中生成的图表、可视化内容、图片等
  - **其他素材**：RAG相关的素材、代码片段、配置文件等
- 支持内容分类和标签管理
- 支持内容搜索和检索
- 支持内容与对话的关联（查看内容来源的对话）
- 支持内容的编辑、删除、分享等操作

**核心价值**：
- **知识沉淀**：将聊天产生的有价值内容保存下来，形成个人知识库
- **内容复用**：保存的内容可以在后续对话中引用和使用
- **RAG支持**：为RAG（检索增强生成）提供素材库，支持向量化存储和检索
- **工作流支持**：支持从对话到实际产出的完整工作流

**前置条件**：
- 对话历史记录功能
- 文件存储系统（本地存储或云存储）
- 用户认证增强（用于权限控制）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- RAG功能可以依赖此功能（使用知识库作为RAG数据源）
- 工具调用能力可以依赖此功能（读取知识库内容）
- 后续行动系统可以依赖此功能（保存行动产生的产出物）

**技术实现**：
- **数据库设计**：
  - `knowledge_items` 表：存储知识库项目
    - `id`：项目ID
    - `user_id`：用户ID
    - `title`：标题
    - `type`：类型（document/database/chart/code/other）
    - `content`：内容（文本内容或JSON格式）
    - `file_url`：文件URL（如果内容存储在文件中）
    - `file_type`：文件类型（pdf/docx/md/sql/json/png/jpg等）
    - `tags`：标签（JSON数组）
    - `category`：分类
    - `session_id`：关联的会话ID（可选）
    - `event_id`：关联的事件ID（可选，记录来源消息）
    - `created_at`：创建时间
    - `updated_at`：更新时间
    - `metadata`：元数据（JSON，存储额外信息）
  
  - `knowledge_vectors` 表：存储向量化内容（用于RAG）
    - `id`：向量ID
    - `knowledge_item_id`：关联的知识库项目ID
    - `chunk_id`：分块ID（如果内容被分块）
    - `vector`：向量数据（JSON或BLOB）
    - `text`：原始文本（用于检索）
    - `created_at`：创建时间
  
  - `knowledge_tags` 表：标签管理（可选）
    - `id`：标签ID
    - `user_id`：用户ID
    - `name`：标签名称
    - `color`：标签颜色
    - `created_at`：创建时间

- **文件存储**：
  - 本地存储：存储在服务器文件系统（适合小规模）
  - 云存储：使用对象存储服务（如AWS S3、阿里云OSS、腾讯云COS等）
  - 文件上传和下载API
  - 文件类型验证和大小限制

- **内容管理功能**：
  - 创建知识库项目（从对话中提取、手动创建、文件上传）
  - 编辑和更新内容
  - 删除内容
  - 分类和标签管理
  - 内容搜索（全文搜索、标签搜索、类型搜索）
  - 内容预览（文档预览、图表预览等）

- **RAG支持**：
  - 内容向量化（使用embedding模型）
  - 向量存储和检索（使用向量数据库，如Milvus、Pinecone、Qdrant等）
  - 相似度搜索（根据用户查询检索相关内容）
  - 内容分块（大文档分块处理）

- **对话关联**：
  - 在对话中标记内容为"保存到知识库"
  - 自动提取对话中的产出物（如代码、图表、文档等）
  - 查看内容来源的对话上下文
  - 在知识库中查看关联的对话

**API设计**：
- `POST /api/v1/knowledge` - 创建知识库项目
- `GET /api/v1/knowledge` - 获取知识库列表（支持搜索、筛选、分页）
- `GET /api/v1/knowledge/:id` - 获取知识库项目详情
- `PUT /api/v1/knowledge/:id` - 更新知识库项目
- `DELETE /api/v1/knowledge/:id` - 删除知识库项目
- `POST /api/v1/knowledge/:id/tags` - 添加标签
- `DELETE /api/v1/knowledge/:id/tags/:tagId` - 删除标签
- `POST /api/v1/knowledge/upload` - 上传文件
- `GET /api/v1/knowledge/:id/download` - 下载文件
- `POST /api/v1/knowledge/from-event/:eventId` - 从对话事件创建知识库项目
- `GET /api/v1/knowledge/:id/related-session` - 获取关联的会话信息
- `POST /api/v1/knowledge/search` - 向量搜索（RAG）

**用户体验**：
- **保存内容**：
  - 在对话中，用户可以选中消息或点击"保存到知识库"按钮
  - 系统自动识别内容类型（文档、代码、图表等）
  - 用户可以编辑标题、添加标签、选择分类
  - 保存后，内容出现在知识库中
  
- **知识库管理**：
  - 知识库首页：展示所有保存的内容（卡片式或列表式）
  - 分类和标签筛选：用户可以按类型、标签、分类筛选
  - 搜索功能：支持全文搜索和标签搜索
  - 内容预览：点击内容可以预览（文档、图表、代码等）
  - 编辑和删除：用户可以编辑或删除内容
  
- **内容复用**：
  - 在对话中，用户可以引用知识库中的内容
  - 支持"插入到对话"功能，将知识库内容插入到当前对话
  - RAG自动检索：在对话中自动检索相关知识库内容，增强上下文

- **RAG素材管理**：
  - 用户可以上传文档、图片等素材到知识库
  - 素材自动向量化，支持RAG检索
  - 在对话中，系统自动检索相关素材，增强回答质量

**应用场景**：
- **学习笔记**：用户与学习助手对话，产生学习笔记，保存到知识库
- **代码库**：用户与编程助手对话，产生代码片段，保存到知识库
- **数据分析**：用户与数据分析助手对话，产生图表和数据，保存到知识库
- **文档生成**：用户与文档助手对话，产生文档，保存到知识库
- **RAG增强**：用户上传文档到知识库，在后续对话中自动检索相关内容

**技术选型建议**：
- **向量数据库**：Milvus（开源）、Pinecone（云服务）、Qdrant（开源）
- **Embedding模型**：OpenAI text-embedding-ada-002、BGE、M3E等
- **文件存储**：本地存储（开发阶段）→ 云存储（生产环境）
- **文档解析**：支持PDF、Word、Markdown、代码文件等格式解析

**优先级**：P1

---

## 4. 多 NPC 世界功能规划

### 4.1 功能目标

实现高级功能，打造多 NPC 世界，支持 NPC 互相对话和复杂交互。

**前置条件**：
- 单个 NPC 系统（NPC 创建、对话）
- 短期记忆系统（用于 NPC 之间的上下文）
- 事件记录系统（用于 NPC 交互事件）

### 4.2 功能列表

#### 4.2.1 多 NPC 世界场景

**功能描述**：
- 用户可以与多个 NPC 同时存在于一个场景中
- 场景可视化（2D 或 3D）
- NPC 在场景中的位置和状态

**前置条件**：
- NPC 创建功能
- 基础对话系统

**依赖关系**：
- NPC 互相对话功能依赖此功能
- NPC 关系网络功能依赖此功能

**技术实现**：
- 场景表设计（scenes 表）
- 场景管理服务
- 前端场景渲染（Canvas 或 WebGL）

**优先级**：P0

---

#### 4.2.2 NPC 互相对话

**功能描述**：
- NPC 之间可以互相对话
- 用户可以选择观察 NPC 之间的对话
- NPC 对话的触发机制（时间、事件、用户指令）

**前置条件**：
- 多 NPC 世界场景
- 短期记忆系统（用于 NPC 之间的上下文记忆）
- 事件总线架构（用于事件驱动的对话触发）

**依赖关系**：
- NPC 关系网络功能依赖此功能
- 中期/长期记忆系统可以增强此功能

**技术实现**：
- NPC 对话调度服务
- 对话事件记录（A2A 事件）
- 对话触发和规则引擎

**优先级**：P0

---

#### 4.2.3 中期/长期记忆系统

**功能描述**：
- 实现 NPC 的中期记忆（重要事件的摘要）
- 实现 NPC 的长期记忆（角色背景、关系网络）
- 记忆的检索和使用机制

**前置条件**：
- 短期记忆系统
- 事件记录系统（用于识别重要事件）

**依赖关系**：
- NPC 互相对话功能可以增强此功能
- NPC 关系网络功能依赖此功能

**技术实现**：
- 记忆分层设计（短期、中期、长期）
- 记忆生成和更新服务
- 记忆检索和融合逻辑

**优先级**：P0

---

#### 4.2.6 记忆可解释性系统（未来）

**功能描述**：
- 实现记忆提取过程的可解释性
- 记录每次记忆提取的过程和结果
- 对比不同记忆提取方式的优劣
- 提供记忆提取过程的文字化展示
- 支持记忆提取策略的持续优化

**前置条件**：
- 短期/中期/长期记忆系统

**依赖关系**：
- 记忆管理AI系统依赖此功能
- 可增强现有记忆系统的可靠性

**技术实现**：
- 记忆提取日志系统
- 提取方式对比分析服务
- 可解释性展示界面
- 提取策略评估机制

**优先级**：P1

---

#### 4.2.7 记忆快速索引系统（未来）

**功能描述**：
- 实现基于记忆的对话历史快速检索
- 支持自然语言查询历史（如"咱们上次聊过什么"）
- 同一NPC不同主题对话的智能管理
- 用户无需手动管理对话历史，通过自然语言即可获取
- **替代当前"最近N条历史事件"的上下文构建方式**

**当前实现**：
- 对话上下文构建：获取最近 20 条历史事件（`getRecentEvents(sessionId, limit = 20)`）
- 上下文限制：默认 20 条事件，可配置（`contextLimit = 20`）
- 问题：随着对话历史增长，简单的"最近N条"方式无法有效利用历史信息

**未来改进**：
- **基于记忆的上下文构建**：
  - 使用记忆索引快速检索相关历史
  - 根据当前对话主题，智能选择相关历史记录
  - 不再依赖简单的"最近N条"，而是基于语义相关性
- **上下文配置策略**：
  - 策略1：最近N条事件（当前方式，简单但有限）
  - 策略2：记忆索引 + 相关历史（智能检索）
  - 策略3：短期记忆 + 记忆索引（混合方式）
  - 策略4：完整记忆系统（短期+中期+长期+索引）

**前置条件**：
- 中期/长期记忆系统
- 对话历史记录功能

**依赖关系**：
- 对话管理增强功能依赖此功能
- 聊天历史展示优化依赖此功能
- **对话上下文构建功能依赖此功能**（替代当前"最近N条事件"方式）

**技术实现**：
- 记忆索引表设计
- 自然语言查询解析
- 记忆与对话历史的关联检索
- 上下文记忆快速加载
- **上下文构建服务重构**：
  - 从`getRecentEvents`改为`buildContextWithMemoryIndex`
  - 支持基于记忆索引的上下文构建
  - 支持Agent级别的上下文配置

**优先级**：P0

---

#### 4.2.8 记忆管理AI系统（未来）

**功能描述**：
- 使用AI来管理和优化记忆提取过程
- 自动对比和优化不同的记忆提取策略
- 根据对话质量动态调整记忆提取方式
- 实现"永久聊天"的核心能力

**前置条件**：
- 记忆可解释性系统
- 长期记忆系统

**依赖关系**：
- 这是实现"永久聊天"功能的关键组件
- 可增强所有记忆相关功能

**技术实现**：
- AI记忆管理服务
- 提取策略自动优化算法
- 记忆质量评估系统
- 持续学习和改进机制

**优先级**：P0

---

#### 4.2.4 工具调用能力

**功能描述**：
- NPC 可以调用外部工具（搜索、知识库、计算等）
- 工具的定义和注册机制
- 工具调用的权限和安全控制

**前置条件**：
- 对话系统（基础）
- 用户认证增强（用于权限控制）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 多 NPC 世界功能可以增强工具调用场景
- 后续行动系统依赖此功能

**技术实现**：
- 工具接口定义
- 工具注册和管理服务
- LLM Function Calling 集成

**优先级**：P1

---

#### 4.2.10 API 使用情况监控功能（未来）

**功能描述**：
- **API Key 状态监控**：显示每个 API Key 的状态（正常使用/已禁用）
- **API Key 使用量统计**：统计每个 API Key 的调用次数、成功次数、失败次数
- **API Key 管理界面**：用户可以查看和管理所有配置的 API Key
- **使用量可视化**：以图表形式展示 API Key 的使用趋势和分布
- **故障转移统计**：统计 API Key 故障转移的次数和原因

**当前问题**：
- 用户无法看到有多少个 API Key 是正常使用的
- 用户无法看到有多少个 API Key 已经被禁用
- 用户无法看到每个 API Key 分别有多少用量
- 用户无法了解 API Key 的使用情况和健康状态

**核心价值**：
- **API Key 管理**：帮助用户了解和管理所有配置的 API Key
- **成本控制**：通过使用量统计，帮助用户控制 API 调用成本
- **故障诊断**：通过故障转移统计，帮助用户发现和解决 API Key 问题
- **资源优化**：通过使用量分析，帮助用户优化 API Key 配置

**前置条件**：
- 多 API Key 故障转移功能（已实现）
- LLM API 调用功能（已实现）
- 用户认证增强（用于权限控制）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 依赖多 API Key 故障转移功能（用于统计故障转移）
- 可以增强 API 限流功能（基于使用量进行限流）

**技术实现**：
- **数据库设计**：
  - `api_key_usage` 表：存储 API Key 使用记录
    - `id`：记录ID
    - `provider`：提供商（openrouter/openai/deepseek）
    - `api_key_index`：API Key 索引（第几个 Key）
    - `api_key_hash`：API Key 的哈希值（用于标识，不存储完整 Key）
    - `status`：状态（active/disabled/error）
    - `call_count`：调用次数
    - `success_count`：成功次数
    - `fail_count`：失败次数
    - `last_used_at`：最后使用时间
    - `last_error_at`：最后错误时间
    - `last_error_code`：最后错误码（401/403/429/timeout等）
    - `created_at`：创建时间
    - `updated_at`：更新时间
  
  - `api_key_usage_log` 表：存储详细的 API Key 使用日志（可选）
    - `id`：日志ID
    - `provider`：提供商
    - `api_key_index`：API Key 索引
    - `api_key_hash`：API Key 的哈希值
    - `status`：调用状态（success/fail）
    - `error_code`：错误码（如果失败）
    - `response_time`：响应时间（毫秒）
    - `timestamp`：时间戳
  
- **API 设计**：
  - `GET /api/v1/admin/api-keys` - 获取所有 API Key 状态和使用量
    - 返回格式：包含每个 API Key 的状态、使用量、最后使用时间等
    - 支持按提供商筛选
    - 支持按状态筛选（active/disabled/error）
  - `GET /api/v1/admin/api-keys/:provider` - 获取指定提供商的 API Key 列表
  - `GET /api/v1/admin/api-keys/:provider/:index` - 获取指定 API Key 的详细信息
  - `GET /api/v1/admin/api-keys/usage-stats` - 获取使用量统计（按时间范围）
    - 支持按天/周/月统计
    - 支持按提供商统计
  - `GET /api/v1/admin/api-keys/failover-stats` - 获取故障转移统计
    - 统计每个 API Key 的故障转移次数和原因
  - `PUT /api/v1/admin/api-keys/:provider/:index/status` - 更新 API Key 状态（启用/禁用）
    - 请求参数：`status`（active/disabled）
  - `GET /api/v1/admin/api-keys/health` - 获取 API Key 健康状态概览
    - 返回：正常使用的数量、已禁用的数量、有错误的数量

- **使用量统计逻辑**：
  - 每次调用 LLM API 时，记录 API Key 的使用情况
  - 统计每个 API Key 的调用次数、成功次数、失败次数
  - 记录最后使用时间和最后错误时间
  - 根据错误码判断 API Key 状态（401/403 → disabled，429 → rate_limit，timeout → error）

- **前端实现**：
  - **API Key 管理页面**：
    - 显示所有配置的 API Key（按提供商分组）
    - 每个 API Key 显示：状态、使用量、最后使用时间、最后错误时间
    - 支持启用/禁用 API Key
    - 支持查看详细使用日志
  - **使用量统计图表**：
    - 按时间范围显示使用量趋势（折线图）
    - 按提供商显示使用量分布（饼图）
    - 显示故障转移统计（柱状图）
  - **健康状态概览**：
    - 显示正常使用的 API Key 数量
    - 显示已禁用的 API Key 数量
    - 显示有错误的 API Key 数量
    - 显示总体健康状态（健康/警告/错误）

**用户体验**：
- **查看 API Key 状态**：用户可以一目了然地看到所有 API Key 的状态
- **查看使用量**：用户可以查看每个 API Key 的使用量统计
- **管理 API Key**：用户可以启用/禁用 API Key，优化配置
- **故障诊断**：用户可以通过故障转移统计发现和解决 API Key 问题
- **成本控制**：用户可以通过使用量统计控制 API 调用成本

**应用场景**：
- **API Key 管理**：用户需要管理多个 API Key，了解每个 Key 的状态和使用情况
- **成本控制**：用户需要了解 API 调用成本，优化 API Key 配置
- **故障诊断**：用户需要诊断 API Key 问题，了解故障转移原因
- **资源优化**：用户需要优化 API Key 配置，提高系统稳定性

**优先级**：P1

---

#### 4.2.9 后续行动系统（未来）

**功能描述**：
- 将对话中产生的想法转化为实际任务（如开发软件、创建项目、生成书籍等）
- 支持对话成果的后续发展（打印、导出、执行等）
- 提供实时反馈和进度跟踪
- 即使没有完整功能，也要提供实时反馈机制

**前置条件**：
- 工具调用能力
- 对话历史记录功能

**依赖关系**：
- 依赖工具调用能力来执行具体行动
- 可以增强对话的价值和实用性

**技术实现**：
- 想法提取和任务生成服务
- 任务执行引擎
- 进度跟踪和反馈系统
- 多种输出格式支持（软件、文档、书籍等）

**优先级**：P1

---

#### 4.2.5 事件总线架构

**功能描述**：
- 实现事件总线，统一管理所有事件
- 支持事件订阅和发布
- 支持事件的可视化和分析

**前置条件**：
- 事件记录系统（基础）
- Redis 缓存（用于消息队列）

**依赖关系**：
- NPC 互相对话功能依赖此功能
- 多 NPC 世界功能依赖此功能
- 可以增强现有的事件记录系统

**技术实现**：
- 事件总线服务（消息队列，如 Redis Streams）
- 事件订阅和发布机制
- 事件可视化界面

**优先级**：P1

---

## 5. 社交与分享功能规划

### 5.1 功能目标

增强用户社交体验，支持对话分享和精炼分享，提升内容的传播价值。

**前置条件**：对话系统、对话历史记录

### 5.2 功能列表

#### 5.2.1 对话分享功能（未来）

**功能描述**：
- 支持分享完整对话记录
- 支持分享对话的精炼版本
- 分享链接生成和管理
- 分享权限控制（公开、仅链接、密码保护）

**前置条件**：
- 对话历史记录功能
- 对话管理增强（用于生成精炼版本）

**依赖关系**：
- 对话精炼分享功能依赖此功能
- 可独立开发，不阻塞其他功能

**技术实现**：
- 分享链接生成服务
- 分享内容渲染（网页版）
- 分享权限管理
- 分享统计和追踪

**优先级**：P1

---

#### 5.2.2 对话精炼分享（未来）

**功能描述**：
- AI自动生成对话摘要和精炼版本
- 用户自定义分享内容范围
- 支持多种精炼策略（关键点提取、主题总结、亮点提取等）

**前置条件**：
- 对话分享功能
- 记忆系统（用于理解对话重点）

**依赖关系**：
- 依赖对话分享功能
- 可以复用记忆系统的摘要能力

**技术实现**：
- 对话精炼服务（使用LLM）
- 精炼策略配置
- 精炼内容预览和编辑
- 精炼质量评估

**优先级**：P2

---

#### 5.2.3 Agent分享功能（未来）

**功能描述**：
- 支持分享完整的Agent（NPC）配置
- **两种分享方式**：
  - **分享给朋友**：通过链接分享，朋友可以通过链接查看和导入Agent
  - **分享到社区**：将Agent发布到社区，其他用户可以浏览、查看和导入（需要社区功能支持）
- 用户可选择分享等级：
  - **完整分享**：模型、提示词、对话记录和重构记忆一起分享
  - **部分分享（不含记忆）**：不分享记忆，其他全部分享（模型、提示词、对话记录）
  - **自定义记忆分享**：用户主动选择记忆部分，其他全部分享
- 分享链接生成和管理
- 分享权限控制（公开、仅链接、密码保护、仅好友）

**前置条件**：
- NPC创建功能
- 对话历史记录功能
- 记忆系统（用于记忆分享选项）
- **分享到社区**：需要社区功能支持（见 5.2.4）

**依赖关系**：
- **分享给朋友**：可独立开发，不依赖社区功能
- **分享到社区**：依赖社区功能（5.2.4），如果要做分享到社区，必须先做社区功能
- 依赖对话分享功能的基础设施
- 需要记忆系统支持（用于记忆选择和分享）

**技术实现**：
- **分享给朋友**（简单版，可先实现）：
  - Agent分享服务（包含配置打包）
  - 分享链接生成（唯一ID）
  - 分享内容渲染（网页版，可导入）
  - 分享权限管理（公开、仅链接、密码保护）
  - 分享统计和追踪（访问次数、导入次数）
  
- **分享到社区**（需要社区功能）：
  - 社区Agent展示页面
  - Agent搜索和筛选功能
  - Agent详情页（包含创建者信息、使用统计等）
  - 社区Agent导入功能
  - 社区Agent评分和评论（可选）

**用户体验**：
- **分享给朋友**：
  - 用户在Agent详情页点击"分享"按钮
  - 选择分享方式（链接分享、二维码分享）
  - 选择分享等级（完整/部分/自定义）
  - 生成分享链接，用户可以复制链接或生成二维码
  - 朋友通过链接访问，可以查看Agent信息并导入
  
- **分享到社区**：
  - 用户在Agent详情页点击"分享到社区"按钮
  - 填写Agent介绍、标签等信息
  - 选择分享等级和权限设置
  - 提交后Agent出现在社区中
  - 其他用户可以浏览、搜索、查看和导入

**重要说明**：
- **分享给朋友**功能可以独立实现，不需要社区功能
- **分享到社区**功能需要完整的社区功能支持（见 5.2.4）
- 如果决定做分享到社区，需要先实现社区功能的基础设施

**优先级**：P1

---

#### 5.2.4 智能生命社区功能（未来）

**功能描述**：
- 建立一个开放的社区平台，用户可以分享自己的Agent，浏览和导入其他用户的Agent
- **社区核心功能**：
  - 社区首页：展示所有公开分享的Agent
  - Agent搜索和筛选：按标签、类型、创建者等筛选
  - Agent详情页：查看Agent信息、创建者信息、使用统计等
  - Agent导入功能：一键导入其他用户分享的Agent
  - Agent评分和评论（可选）：用户可以对Agent进行评分和评论
- **社区与分享的关系**：
  - Agent分享功能中的"分享到社区"需要社区功能支持
  - 如果要做分享到社区，必须先实现社区功能的基础设施
  - 社区功能可以独立开发，不依赖其他高级功能

**前置条件**：
- NPC创建功能
- Agent分享功能（分享给朋友的基础功能）
- 用户认证增强（用于用户身份识别）

**依赖关系**：
- Agent分享功能中的"分享到社区"依赖此功能
- 可以独立开发，不依赖记忆系统、多NPC世界等高级功能
- 后续可以扩展为更复杂的社区功能（如用户同位体、NPC互相对话等）

**技术实现**：
- **社区数据库设计**：
  - `shared_agents` 表：存储社区中分享的Agent信息
  - `agent_tags` 表：Agent标签管理
  - `agent_imports` 表：记录Agent导入次数和用户
  - `agent_ratings` 表：Agent评分和评论（可选）
  
- **社区功能实现**：
  - 社区首页：展示所有公开分享的Agent（分页、排序）
  - Agent搜索：支持关键词搜索、标签筛选、类型筛选
  - Agent详情页：显示Agent完整信息、创建者信息、使用统计
  - Agent导入：一键导入功能，将分享的Agent复制到用户自己的Agent列表
  - 分享管理：用户可以管理自己分享的Agent（编辑、下架、查看统计）

**用户体验**：
- 浏览社区：用户可以浏览社区中所有公开分享的Agent
- 搜索Agent：用户可以搜索和筛选感兴趣的Agent
- 查看详情：用户可以查看Agent的详细信息、创建者信息、使用统计
- 导入Agent：用户可以一键导入其他用户分享的Agent到自己的列表
- 分享Agent：用户可以将自己的Agent分享到社区

**优先级**：P1（如果要做分享到社区功能，必须先实现此功能）

---

#### 5.2.5 智能生命社区 - 用户同位体功能（未来）

**功能描述**：
- 用户可以创建自己的"同位体"（Avatar Agent），代表用户在社区中
- 同位体是基于用户自己创建的Agent，但专门用于社区交互
- 其他用户可以与该同位体对话，就像与用户本人对话一样
- 同位体可以继承用户的记忆、性格、对话风格等特征
- 用户可以选择哪些Agent作为自己的同位体，以及同位体的公开程度

**核心概念**：
- **同位体（Avatar Agent）**：用户在社区中的AI代表，基于用户创建的Agent
- **智能生命社区**：一个开放的社区平台，用户可以放置自己的同位体，与其他用户的同位体交互
- **社区交互**：用户可以与社区中其他用户的同位体对话，也可以让自己的同位体与其他用户的同位体对话

**前置条件**：
- NPC创建功能
- 对话历史记录功能
- 记忆系统（用于继承用户特征）
- Agent分享功能（用于社区展示）
- 智能生命社区功能（5.2.4，社区基础设施）
- 多NPC世界功能（用于社区场景）

**依赖关系**：
- 依赖智能生命社区功能（5.2.4）的基础设施
- 依赖Agent分享功能的基础设施
- 需要记忆系统支持（用于继承用户特征）
- 需要多NPC世界功能（用于社区场景和NPC互相对话）
- 可以增强社交与分享功能的体验

**技术实现**：
- **社区数据库设计**：
  - `community_avatars` 表：存储用户同位体信息
  - `avatar_interactions` 表：记录同位体之间的交互
  - `community_scenes` 表：社区场景管理
  
- **同位体创建和管理**：
  - 用户可以选择已有Agent作为同位体，或创建新的同位体
  - 同位体可以继承用户的记忆和对话风格
  - 用户可以为同位体设置公开程度（公开、仅好友、私密）
  
- **社区功能**：
  - 社区首页：展示所有公开的同位体
  - 同位体详情页：查看同位体信息、对话历史、创建者信息
  - 与同位体对话：用户可以与社区中其他用户的同位体对话
  - 同位体互相对话：用户的同位体可以与其他用户的同位体自动对话（AI驱动）
  
- **权限和隐私**：
  - 用户可以选择哪些Agent作为同位体
  - 用户可以选择同位体的公开程度
  - 用户可以选择是否允许其他用户与自己的同位体对话
  - 用户可以选择是否允许自己的同位体与其他用户的同位体自动对话

**用户体验**：
- 创建同位体：用户可以选择已有Agent或创建新的Agent作为同位体
- 社区浏览：用户可以浏览社区中所有公开的同位体
- 与同位体对话：用户可以点击任意同位体，开始对话
- 同位体管理：用户可以管理自己的同位体，设置公开程度、更新信息等
- 社区互动：用户的同位体可以与其他用户的同位体在社区中自动交互

**应用场景**：
- **个人品牌**：用户创建自己的同位体，代表自己在社区中
- **知识分享**：用户创建专业领域的同位体，分享知识和经验
- **社交互动**：用户与社区中其他用户的同位体对话，建立社交关系
- **AI社区**：多个同位体在社区中自动交互，形成活跃的AI社区生态

**优先级**：P1

---

#### 5.2.6 好友功能（未来）

**功能描述**：
- 用户可以添加其他用户为好友
- **用户可以添加Agent（AI）为好友**：用户可以将自己创建的Agent或其他用户分享的Agent添加为好友
- 支持好友列表管理（添加、删除、查看）
- 支持好友状态（在线、离线、最近活跃时间）
- 支持通过用户ID或用户名搜索和添加好友
- 支持通过Agent ID或Agent名称搜索和添加Agent为好友
- 支持好友请求和确认机制（双向确认，Agent无需确认）
- **好友列表中区分显示人类用户和AI Agent**：在好友列表中明确标识好友的身份类型（人类/AI）

**前置条件**：
- 用户认证功能
- 用户管理功能
- NPC创建功能（用于添加Agent为好友）

**依赖关系**：
- 可独立开发，不依赖其他功能
- 群功能（5.2.7）可以依赖好友功能（如"仅好友可见"的群）
- Agent分享功能可以依赖好友功能（如"仅好友"分享）

**技术实现**：
- **数据库设计**：
  - `friendships` 表：存储好友关系
    - `id`：关系ID
    - `user_id`：用户ID
    - `friend_id`：好友ID（用户ID或Agent ID）
    - `friend_type`：好友类型（user/agent）
    - `status`：关系状态（pending/accepted/blocked）
    - `created_at`：创建时间
    - `accepted_at`：确认时间（Agent无需确认，自动接受）
  
  - `friend_requests` 表：存储好友请求（可选）
    - `id`：请求ID
    - `from_user_id`：发起请求的用户ID
    - `to_id`：接收请求的ID（用户ID或Agent ID）
    - `to_type`：接收者类型（user/agent）
    - `status`：请求状态（pending/accepted/rejected）
    - `created_at`：创建时间
    - `accepted_at`：确认时间（Agent自动接受）
  
- **API设计**：
  - `POST /api/v1/friends/request` - 发送好友请求
    - 请求参数：`friendId`（用户ID或Agent ID）、`friendType`（user/agent）
    - Agent好友请求自动接受，无需确认
  - `POST /api/v1/friends/accept` - 接受好友请求（仅用于用户好友）
  - `POST /api/v1/friends/reject` - 拒绝好友请求（仅用于用户好友）
  - `GET /api/v1/friends` - 获取好友列表
    - 返回格式：包含好友类型（user/agent）、好友信息（用户信息或Agent信息）
    - 支持按类型筛选（只显示用户好友、只显示Agent好友、显示全部）
  - `DELETE /api/v1/friends/:friendId` - 删除好友
    - 支持删除用户好友和Agent好友
  - `GET /api/v1/friends/search` - 搜索用户或Agent（用于添加好友）
    - 支持搜索用户（按用户名或用户ID）
    - 支持搜索Agent（按Agent名称或Agent ID）
    - 返回结果中包含类型标识（user/agent）

- **前端实现**：
  - **好友列表UI**：
    - 显示所有好友（用户和Agent）
    - **身份标识**：在好友列表中明确标识好友身份
      - 用户好友：显示"人类"标识或用户图标
      - Agent好友：显示"AI"标识或Agent图标
    - 支持按类型筛选（只显示用户好友、只显示Agent好友、显示全部）
    - 支持按状态筛选（在线、离线）
  - **添加好友UI**：
    - 支持搜索用户和Agent
    - 搜索结果中显示类型标识（用户/AI）
    - 点击添加后，Agent自动添加成功，用户需要等待确认
  - **好友详情**：
    - 用户好友：显示用户信息、在线状态、最近活跃时间
    - Agent好友：显示Agent信息、头像、人设、最后对话时间

**用户体验**：
- **添加好友**：
  - 用户可以搜索其他用户，发送好友请求
  - 用户可以搜索Agent（自己创建的或其他用户分享的），添加为好友
  - Agent好友添加后立即生效，无需确认
  - 用户好友需要等待对方确认
- **好友列表**：
  - 用户可以查看自己的好友列表（包含用户和Agent）
  - **身份区分**：好友列表中明确标识每个好友的身份类型
    - 用户好友：显示"人类"标识、用户头像、用户名
    - Agent好友：显示"AI"标识、Agent头像、Agent名称
  - 支持按类型筛选（只显示用户好友、只显示Agent好友、显示全部）
  - 支持按状态筛选（在线、离线）
- **好友状态**：
  - 用户好友：显示在线状态和最近活跃时间
  - Agent好友：显示最后对话时间（Agent始终"在线"）
- **好友管理**：
  - 用户可以删除好友、屏蔽好友等
  - 支持删除用户好友和Agent好友

**应用场景**：
- **用户社交**：用户可以添加其他用户为好友，建立社交关系
- **AI陪伴**：用户可以添加Agent为好友，将常用的Agent加入好友列表，方便快速访问
- **混合好友列表**：用户的好友列表可以同时包含人类好友和AI好友，统一管理

**优先级**：P1

---

#### 5.2.7 群功能（未来）

**功能描述**：
- 用户可以创建群组
- **用户和Agent都可以加入群**：群成员可以是用户，也可以是Agent
- 支持群管理功能（创建、加入、退出、踢出成员）
- 支持群设置（群名称、群描述、群头像、权限设置）
- 支持群成员管理（查看成员列表、设置管理员、权限管理）

**前置条件**：
- 用户认证功能
- NPC创建功能（Agent可以加入群）
- 好友功能（可选，用于"仅好友"的群）

**依赖关系**：
- 群体会话功能（5.2.8）依赖此功能
- 可以依赖好友功能（如"仅好友可见"的群）
- 可以独立开发，不依赖记忆系统等高级功能

**技术实现**：
- **数据库设计**：
  - `groups` 表：存储群组信息
    - `id`：群组ID
    - `name`：群组名称
    - `description`：群组描述
    - `avatar_url`：群组头像
    - `creator_id`：创建者用户ID
    - `type`：群组类型（public/private/invite_only）
    - `max_members`：最大成员数
    - `created_at`：创建时间
    - `updated_at`：更新时间
  
  - `group_members` 表：存储群成员关系
    - `group_id`：群组ID
    - `member_id`：成员ID（用户ID或Agent ID）
    - `member_type`：成员类型（user/agent）
    - `role`：成员角色（owner/admin/member）
    - `joined_at`：加入时间
    - `left_at`：离开时间（如果已离开）
  
  - `group_invitations` 表：存储群邀请（可选）
    - `group_id`：群组ID
    - `inviter_id`：邀请者ID
    - `invitee_id`：被邀请者ID
    - `status`：邀请状态（pending/accepted/rejected）
    - `created_at`：创建时间

- **API设计**：
  - `POST /api/v1/groups` - 创建群组
  - `GET /api/v1/groups` - 获取用户的群组列表
  - `GET /api/v1/groups/:groupId` - 获取群组详情
  - `PUT /api/v1/groups/:groupId` - 更新群组信息
  - `DELETE /api/v1/groups/:groupId` - 解散群组
  - `POST /api/v1/groups/:groupId/members` - 加入群组
  - `DELETE /api/v1/groups/:groupId/members/:memberId` - 退出或踢出成员
  - `GET /api/v1/groups/:groupId/members` - 获取群成员列表
  - `PUT /api/v1/groups/:groupId/members/:memberId/role` - 设置成员角色

**用户体验**：
- 创建群组：用户可以创建群组，设置群名称、描述、权限等
- 加入群组：用户可以搜索和加入公开群组，或通过邀请加入私密群组
- 添加Agent到群：用户可以将自己的Agent添加到群中
- 群管理：群主和管理员可以管理群成员、设置权限等
- 群列表：用户可以查看自己加入的所有群组

**应用场景**：
- **学习小组**：用户创建学习群，添加学习相关的Agent
- **兴趣社区**：用户创建兴趣群，添加相关领域的Agent
- **协作项目**：用户创建项目群，添加助手Agent
- **社交聊天**：用户创建聊天群，添加陪伴Agent

**优先级**：P1

---

#### 5.2.8 群体会话功能（未来）

**功能描述**：
- 支持群组内的群体会话（多人对话）
- **参与者可变**：与固定会话不同，群体会话的参与者可能会变动（有人加入、有人退出）
- 支持用户和Agent在群组中发送消息
- 支持群组消息历史记录
- 支持@提及功能（@用户或@Agent）
- 支持消息通知（新消息提醒）

**核心区别**：
- **固定会话（当前实现）**：
  - 参与者固定（user + agent），参与者不变
  - Session ID 通过参与者列表匹配（JSON匹配）
  - 同一参与者组合只有一个Session
  
- **群体会话（新功能）**：
  - 参与者可变，可能有多个用户和多个Agent
  - Session ID 固定（绑定到群组ID），不随参与者变化
  - 参与者变动不影响Session ID
  - 需要记录参与者的加入和退出历史

**前置条件**：
- 群功能（5.2.7）
- 对话系统（基础）
- 事件记录系统（基础）

**依赖关系**：
- 依赖群功能（5.2.7）
- 可以独立开发，不依赖记忆系统等高级功能
- 后续可以扩展为更复杂的群组功能（如群组记忆、群组Agent等）

**技术实现**：
- **数据库设计**：
  - `group_sessions` 表：存储群组会话
    - `id`：会话ID（固定，绑定到群组）
    - `group_id`：群组ID（外键）
    - `created_at`：创建时间
    - `last_active_at`：最后活动时间
    - `message_count`：消息总数
  
  - `group_session_participants` 表：存储群体会话的参与者（动态）
    - `session_id`：会话ID
    - `participant_id`：参与者ID（用户ID或Agent ID）
    - `participant_type`：参与者类型（user/agent）
    - `joined_at`：加入时间
    - `left_at`：离开时间（如果已离开）
    - `is_active`：是否活跃（当前在群中）
  
  - `group_events` 表：存储群组消息事件（扩展events表或新建）
    - `id`：事件ID
    - `session_id`：会话ID（群组会话）
    - `from_id`：发送者ID（用户ID或Agent ID）
    - `from_type`：发送者类型（user/agent）
    - `content`：消息内容
    - `mentions`：@提及列表（JSON数组）
    - `timestamp`：时间戳

- **会话管理**：
  - 群组创建时自动创建群体会话（固定Session ID）
  - 成员加入时，在`group_session_participants`中添加记录
  - 成员退出时，更新`left_at`和`is_active`字段
  - 查询群组消息时，使用固定的Session ID查询

- **消息发送**：
  - 用户或Agent在群组中发送消息
  - 消息保存到`group_events`表，使用群组的固定Session ID
  - 支持@提及功能，解析消息中的@用户名或@Agent名
  - 发送消息后，更新群组会话的`last_active_at`

- **消息历史**：
  - 查询群组消息时，使用群组的固定Session ID
  - 支持分页查询（按时间倒序）
  - 支持搜索功能（搜索群组内的消息）

**与固定会话的区别**：

| 特性 | 固定会话（当前） | 群体会话（新功能） |
|------|----------------|------------------|
| 参与者 | 固定（user + agent） | 可变（多个user和agent） |
| Session ID | 通过参与者匹配 | 固定（绑定群组ID） |
| 参与者变动 | 不支持 | 支持（加入/退出） |
| 查询方式 | JSON匹配participants | 直接使用Session ID |
| 使用场景 | 一对一对话 | 群组对话 |

**用户体验**：
- 群组聊天：用户在群组中发送消息，所有成员都能看到
- 添加Agent：用户可以将Agent添加到群组，Agent可以参与对话
- 消息历史：用户可以查看群组的历史消息
- @提及：用户可以@其他成员或Agent
- 消息通知：新消息时通知群组成员

**应用场景**：
- **学习讨论**：学习群中，用户和Agent一起讨论问题
- **项目协作**：项目群中，用户和助手Agent协作完成任务
- **社交聊天**：聊天群中，用户和陪伴Agent一起聊天
- **知识分享**：知识群中，用户和专家Agent分享知识

**优先级**：P1

---

## 6. 知识管理功能规划

### 6.1 功能目标

建立AI技术知识库，供公司内部使用，帮助团队了解和学习AI相关技术。

**前置条件**：基础功能（可独立开发）

**说明**：此功能为**公司内部使用**，不面向用户。

### 6.2 功能列表

#### 6.2.1 AI技术知识库（未来，公司内部）

**功能描述**：
- 建立AI技术表格/文档管理系统（公司内部）
- 跟踪热门AI技术和趋势
- 提供技术实现原理说明
- 整理学习资源（教程、论文、代码示例等）
- 提供技术的通俗解释（降低学习门槛）

**前置条件**：
- 基础功能（可独立开发）

**依赖关系**：
- 可完全独立开发，不依赖其他功能
- 可以作为工具调用能力的知识来源（内部参考）

**技术实现**：
- 知识库数据库设计（内部系统）
- 技术文档管理系统
- 搜索和检索功能
- 内容更新和维护机制

**优先级**：P2（内部工具，优先级较低）

---

## 7. 内容审核功能规划

### 7.1 功能目标

确保平台内容安全，防止违规内容传播，保护用户和平台安全。

**前置条件**：对话系统、用户认证增强

### 7.2 功能列表

#### 7.2.1 内容审核系统（未来）

**功能描述**：
- 实现AI内容判定机制（自动检测违规内容）
- 用户封号功能（针对违规用户）
- 多国家/地区内容策略（根据法律法规调整）
- 内容认证和权限管理（针对允许内容的特殊认证）

**前置条件**：
- 对话系统（需要审核对话内容）
- 用户认证增强（用于用户管理和封号）

**依赖关系**：
- 可独立开发，不阻塞其他功能
- 建议在用户规模扩大前实现

**技术实现**：
- AI内容审核服务（使用LLM或专门的内容审核API）
- 违规内容检测规则引擎
- 用户封号和管理系统
- 多地区策略配置
- 内容认证和权限系统

**优先级**：P0（在用户规模扩大前）

---

## 8. 长期愿景

### 8.1 产品愿景

打造一个沉浸式的 AI NPC 交互平台，让用户能够与多个具有独特人设和记忆的 AI 角色进行深度对话，满足学习、陪伴、娱乐等多种需求。

### 8.2 技术愿景

- **可扩展架构**：支持水平扩展，支持大规模用户
- **智能化**：AI 能力不断增强，NPC 行为更加自然
- **可视化**：丰富的可视化界面，展示 NPC 的行为和思维过程
- **开放平台**：支持第三方插件和扩展

### 8.3 功能愿景

#### 8.3.1 记忆系统演进

- **短期记忆**：最近对话的上下文（规划中，依赖对话系统）
- **中期记忆**：重要事件的摘要和关联（规划中，依赖短期记忆）
- **长期记忆**：角色背景、关系网络、知识库（规划中，依赖中期记忆）
- **记忆可解释性**：记忆提取过程记录和对比（未来，依赖记忆系统）
- **记忆快速索引**：基于记忆的对话历史检索（未来，依赖中期/长期记忆）
- **记忆管理AI**：AI自动管理和优化记忆提取（未来，依赖记忆可解释性）
- **永久聊天**：通过记忆管理实现与AI的永久对话能力（未来，依赖记忆管理AI）

#### 8.3.2 交互方式演进

- **文本对话**：基础的文本对话（✅ 已实现）
- **对话管理增强**：选中文字开启新对话、对话分支管理（未来，依赖文本对话、记忆系统）
- **聊天历史优化**：微信式展示、记忆索引查询（未来，依赖文本对话、记忆系统）
- **多模态交互**：支持图片、语音、视频（未来，依赖文本对话）
- **动作系统**：NPC 可以执行动作和任务（未来，依赖工具调用能力）
- **后续行动**：想法转化为实际任务（未来，依赖工具调用能力）
- **情感系统**：NPC 具有情感状态和表达（未来，依赖记忆系统）

#### 8.3.3 世界系统演进

- **单人世界**：用户与 NPC 一对一对话（✅ 已实现）
- **多 NPC 世界**：用户与多个 NPC 共存在场景中（规划中，依赖单人世界）
- **NPC 社区**：NPC 之间形成社区和关系网络（未来，依赖多 NPC 世界、长期记忆）
- **世界规则**：世界具有物理规则、时间系统、事件系统（未来，依赖事件总线架构）

---

## 9. 技术演进方向

### 9.1 架构演进

- **当前**：单体架构，简单实现 ✅
- **演进路径 1**：引入缓存、消息队列（依赖：数据量增长、性能需求）
- **演进路径 2**：微服务架构，事件驱动（依赖：事件总线架构、多 NPC 世界）
- **未来**：分布式系统，支持大规模并发（依赖：微服务架构、监控系统）

### 9.2 技术栈演进

- **数据库**：MySQL（✅ 当前）→ 引入 Redis 缓存（依赖：性能需求）→ 引入 NoSQL（如 MongoDB）（依赖：复杂数据结构需求）
- **缓存**：无（✅ 当前）→ Redis 缓存（依赖：性能优化需求）→ Redis 集群（依赖：大规模并发）
- **消息队列**：无（✅ 当前）→ Redis Streams（依赖：事件总线架构）→ RabbitMQ / Kafka（依赖：大规模事件处理）
- **监控**：基础日志（✅ 当前）→ 错误日志和监控（✅ V1.5 简单版）→ 完整的监控和告警系统（依赖：系统稳定性需求）

### 9.3 AI 能力演进

- **LLM 模型**：OpenRouter 统一入口（✅ 当前）→ 支持更多提供商（依赖：用户需求）→ 用户自定义 API Key（依赖：权限系统）
- **Prompt 工程**：基础 system prompt（✅ 当前）→ Prompt 优化工具（依赖：用户需求）→ 智能 Prompt 优化（依赖：工具调用能力）
- **多模态**：文本对话（✅ 当前）→ 支持图片（依赖：LLM 模型支持）→ 支持语音、视频（依赖：基础设施）
- **Agent 框架**：基础实现（✅ 当前）→ 集成 LangChain（依赖：工具调用需求）→ 完整 Agent 框架（依赖：多 NPC 世界）

---

## 10. 用户反馈收集

### 10.1 反馈渠道 ✅ V1.5

- **应用内反馈**：在应用中提供反馈入口 ✅ V1.5
- **用户调研**：定期进行用户调研（未来）
- **数据分析**：分析用户行为数据（未来）
- **社区反馈**：建立用户社区（如 Discord、微信群）（未来）

**V1.5 实现**：
- 反馈提交功能（Bug、功能建议、使用问题）
- 反馈分类和状态管理
- 自动附加用户环境信息

**实现方案**：详见 [V1.5 版本规划 - 用户反馈](./v1.5/06-用户反馈实现方案.md)

### 10.2 反馈处理流程

```
收集反馈 ✅ V1.5
  ↓
分类和优先级评估（未来）
  ↓
产品规划（未来）
  ↓
开发实现（未来）
  ↓
用户通知（未来）
```

---

## 11. 竞品分析

### 11.1 竞品跟踪

- **Character.AI**：多角色对话平台
- **Replika**：AI 陪伴应用
- **ChatGPT**：通用对话助手

### 11.2 差异化策略

- **更灵活的 NPC 创建**：用户可以完全自定义 NPC 的人设和模型
- **事件驱动架构**：为未来扩展预留更多可能性
- **记忆系统**：实现分层的记忆系统，NPC 具有持续的记忆
- **多 NPC 世界**：支持多 NPC 共存和互相对话
- **数据永久保留**：承诺永久保留用户数据，除非用户主动删除
- **Agent 持续优化**：承诺随着技术发展，持续优化已有 Agent

---

## 12. 商业模式（未来考虑）

### 12.1 免费功能

- 基础 NPC 创建和对话
- 有限的对话次数
- 基础的记忆功能

### 12.2 付费功能（未来考虑）

- 无限对话次数
- 高级记忆系统
- 更多 LLM 模型选择
- 优先技术支持
- 数据导出和分析功能
- **会员用户数据保护**：会员用户的数据不会被用于模型训练（见 2.2.5）

---

## 13. 版本规划状态

### 13.1 V1.5 版本（当前规划）

**状态**：✅ 已规划并实现

**功能清单**：
- ✅ 密码功能（bcrypt 加密）
- ✅ JWT Token 认证
- ✅ API 限流（简单版）
- ✅ NPC 编辑和删除
- ✅ 对话搜索功能（不做筛选）
- ✅ 用户反馈功能
- ✅ 数据导入导出功能
- ✅ 错误日志和监控（简单版）
- ✅ 数据备份机制（简单版）

**详细文档**：请参考 [V1.5 版本规划](./v1.5/README.md)

### 13.2 未来版本

**数据管理增强**：
- 对话筛选、高级搜索
- 对话管理增强（选中文字开启新对话）
- 聊天历史展示优化（微信式展示、记忆索引）

**记忆系统**：
- 短期、中期、长期记忆
- 记忆可解释性系统
- 记忆快速索引系统
- 记忆管理AI系统（永久聊天核心）

**多 NPC 世界**：
- 场景管理、NPC 互相对话
- NPC 关系网络

**工具与扩展**：
- LLM Function Calling
- API 使用情况监控功能（API Key 状态监控、使用量统计、管理界面）
- 后续行动系统（想法转化为实际任务）
- 事件总线架构

**社交与分享**：
- 对话分享功能
- 对话精炼分享
- Agent分享功能（分享给朋友/分享到社区，完整分享/部分分享/自定义记忆分享）
- 智能生命社区功能（社区中分享Agent）
- 好友功能（添加好友、好友列表管理）
- 群功能（创建群组、用户和Agent都可以加入）
- 群体会话功能（参与者可变，固定Session ID）
- 智能生命社区 - 用户同位体功能（社区中放置用户自己的Agent）

**知识管理**：
- AI技术知识库（公司内部）

**安全与审核**：
- 内容审核系统（AI判定、封号功能）
- 会员用户数据保护功能（数据隔离、不用于模型训练）

---

## 14. 相关文档

- [V1 产品文档](./v1/README.md) - V1 版本完整产品文档
- [V1.5 版本规划](./v1.5/README.md) - V1.5 版本详细规划
- [V1 产品概述](./v1/01-产品概述.md) - V1 产品定义和目标
- [V1 功能需求](./v1/03-功能需求.md) - V1 功能需求详细说明

---

**文档维护**：后续规划变更时，需同步更新本文档和产品规划文档。

