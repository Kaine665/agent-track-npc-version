# 版本管理与并行部署策略

**文档版本**：v1.0  
**最后更新**：2025-01-XX  
**相关文档**：[V1 产品文档](../v1/README.md) | [V1.5 版本规划](../v1.5/README.md) | [部署指南](../../DEPLOYMENT.md)

---

## 1. 概述

### 1.1 目标

实现**版本并行开发、并行部署**，支持：
- 不同版本在同一域名下使用不同的 API 路径（如 `/api/v1` 和 `/api/v1.5`）
- **无觉察版本更新**：用户可以在不同版本间切换，无需感知底层变化
- **渐进式迁移**：逐步将用户从旧版本迁移到新版本
- **A/B 测试**：可以同时测试多个版本

### 1.2 核心原则

1. **URL 路径版本控制**：通过 URL 路径区分版本（`/api/v1`、`/api/v1.5`）
2. **向后兼容**：新版本保持向后兼容，不破坏现有 API
3. **数据共享**：不同版本可以共享同一数据库（通过版本标识区分）
4. **独立部署**：每个版本可以独立部署和更新
5. **平滑切换**：支持用户在不同版本间平滑切换

---

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                      用户浏览器                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  V1 前端     │  │  V1.5 前端   │  │  其他版本    │  │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │
└─────────┼──────────────────┼──────────────────┼─────────┘
          │                  │                  │
          └──────────────────┼──────────────────┘
                             │
                    ┌────────▼────────┐
                    │   Nginx 反向代理 │
                    │   (路由分发)     │
                    └────────┬────────┘
                             │
          ┌──────────────────┼──────────────────┐
          │                  │                  │
    ┌─────▼─────┐    ┌──────▼──────┐    ┌─────▼─────┐
    │ V1 后端   │    │ V1.5 后端    │    │ 其他版本  │
    │ :8000     │    │ :8001        │    │ 后端      │
    └─────┬─────┘    └──────┬───────┘    └─────┬─────┘
          │                  │                  │
          └──────────────────┼──────────────────┘
                             │
                    ┌────────▼────────┐
                    │   MySQL 数据库  │
                    │  (共享数据)     │
                    └─────────────────┘
```

### 2.2 版本路由策略

**方案A：URL 路径版本控制（推荐）**

```
域名：example.com

/api/v1/*      → V1 后端（端口 8000）
/api/v1.5/*    → V1.5 后端（端口 8001）
/api/v2/*      → V2 后端（端口 8002）

前端路由：
/v1/*          → V1 前端（容器 v1-frontend）
/v1.5/*        → V1.5 前端（容器 v1.5-frontend）
/              → 默认版本（可配置）
```

**方案B：子域名版本控制（可选）**

```
v1.example.com     → V1 版本（前端 + 后端）
v1.5.example.com   → V1.5 版本（前端 + 后端）
example.com        → 默认版本（可配置）
```

**推荐使用方案A**：更简单，不需要 DNS 配置，适合小规模部署。

---

## 3. 实现方案

### 3.1 Nginx 配置

**主 Nginx 配置**（`nginx/conf.d/default.conf`）：

```nginx
# 上游服务器：V1 后端
upstream backend-v1 {
    server backend-v1:8000;
    keepalive 32;
}

# 上游服务器：V1.5 后端
upstream backend-v1.5 {
    server backend-v1.5:8001;
    keepalive 32;
}

# 上游服务器：V1 前端
upstream frontend-v1 {
    server frontend-v1:80;
    keepalive 32;
}

# 上游服务器：V1.5 前端
upstream frontend-v1.5 {
    server frontend-v1.5:80;
    keepalive 32;
}

server {
    listen 80;
    server_name example.com;

    # ========== API 路由 ==========
    
    # V1 API
    location /api/v1/ {
        proxy_pass http://backend-v1;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-API-Version "v1";
    }

    # V1.5 API
    location /api/v1.5/ {
        proxy_pass http://backend-v1.5;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-API-Version "v1.5";
    }

    # ========== 前端路由 ==========
    
    # V1 前端
    location /v1/ {
        proxy_pass http://frontend-v1/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_no_cache $http_upgrade;
    }

    # V1.5 前端
    location /v1.5/ {
        proxy_pass http://frontend-v1.5/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_no_cache $http_upgrade;
    }

    # 默认路由（重定向到默认版本或版本选择页）
    location / {
        # 方案1：重定向到默认版本
        return 301 /v1.5/;
        
        # 方案2：显示版本选择页（可选）
        # proxy_pass http://frontend-default;
    }
}
```

### 3.2 Docker Compose 配置

**多版本 Docker Compose 配置**（`docker-compose.yml`）：

```yaml
version: '3.8'

services:
  # ==================== V1 版本 ====================
  
  backend-v1:
    build:
      context: ./npc-backend
      dockerfile: Dockerfile
    container_name: npc-backend-v1
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 8000
      API_VERSION: v1
      DB_HOST: mysql
      DB_PORT: 3306
      DB_USER: ${DB_USER:-root}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: ${DB_NAME:-npc_db}
      OPENROUTER_API_KEY: "${OPENROUTER_API_KEY:-}"
    ports:
      - "8000:8000"
    depends_on:
      mysql:
        condition: service_healthy
    networks:
      - npc-network

  frontend-v1:
    build:
      context: ./npc-frontend
      dockerfile: Dockerfile
      args:
        VITE_API_BASE_URL: /api/v1
        VITE_API_MODE: http
        VITE_APP_VERSION: v1
    container_name: npc-frontend-v1
    restart: unless-stopped
    ports:
      - "3000:80"
    depends_on:
      - backend-v1
    networks:
      - npc-network

  # ==================== V1.5 版本 ====================
  
  backend-v1.5:
    build:
      context: ./npc-backend
      dockerfile: Dockerfile
    container_name: npc-backend-v1.5
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 8001
      API_VERSION: v1.5
      DB_HOST: mysql
      DB_PORT: 3306
      DB_USER: ${DB_USER:-root}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: ${DB_NAME:-npc_db}
      OPENROUTER_API_KEY: "${OPENROUTER_API_KEY:-}"
    ports:
      - "8001:8001"
    depends_on:
      mysql:
        condition: service_healthy
    networks:
      - npc-network

  frontend-v1.5:
    build:
      context: ./npc-frontend
      dockerfile: Dockerfile
      args:
        VITE_API_BASE_URL: /api/v1.5
        VITE_API_MODE: http
        VITE_APP_VERSION: v1.5
    container_name: npc-frontend-v1.5
    restart: unless-stopped
    ports:
      - "3001:80"
    depends_on:
      - backend-v1.5
    networks:
      - npc-network

  # ==================== 共享服务 ====================
  
  mysql:
    image: mysql:8.0
    container_name: npc-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_DATABASE: ${DB_NAME:-npc_db}
    volumes:
      - mysql_data:/var/lib/mysql
    ports:
      - "${DB_PORT:-3306}:3306"
    networks:
      - npc-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${DB_PASSWORD}"]
      interval: 10s
      timeout: 5s
      retries: 5

  nginx:
    image: nginx:alpine
    container_name: npc-nginx
    restart: unless-stopped
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    depends_on:
      - frontend-v1
      - frontend-v1.5
      - backend-v1
      - backend-v1.5
    networks:
      - npc-network

networks:
  npc-network:
    driver: bridge

volumes:
  mysql_data:
    driver: local
```

### 3.3 后端路由配置

**V1 后端路由**（`npc-backend/server.js`）：

```javascript
// V1 版本路由
app.use("/api/v1/agents", require("./routes/v1/agents"));
app.use("/api/v1/messages", require("./routes/v1/messages"));
app.use("/api/v1/users", require("./routes/v1/users"));
// ... 其他 V1 路由
```

**V1.5 后端路由**（`npc-backend/server.js`）：

```javascript
// V1.5 版本路由
app.use("/api/v1.5/agents", require("./routes/v1.5/agents"));
app.use("/api/v1.5/messages", require("./routes/v1.5/messages"));
app.use("/api/v1.5/users", require("./routes/v1.5/users"));
// ... 其他 V1.5 路由

// V1.5 可以同时支持 V1 路由（向后兼容）
app.use("/api/v1/agents", require("./routes/v1/agents")); // 复用 V1 路由
```

**版本检测中间件**（可选）：

```javascript
// middleware/versionDetector.js
function detectVersion(req, res, next) {
  const apiVersion = req.headers['x-api-version'] || 
                     req.path.split('/')[2] || // 从路径提取版本
                     'v1'; // 默认版本
  
  req.apiVersion = apiVersion;
  next();
}
```

### 3.4 前端配置

**V1 前端配置**（`.env`）：

```env
VITE_API_BASE_URL=/api/v1
VITE_API_MODE=http
VITE_APP_VERSION=v1
```

**V1.5 前端配置**（`.env`）：

```env
VITE_API_BASE_URL=/api/v1.5
VITE_API_MODE=http
VITE_APP_VERSION=v1.5
```

**前端 API 适配层**（`npc-frontend/src/api/index.js`）：

```javascript
// 自动检测 API 版本
const API_VERSION = import.meta.env.VITE_APP_VERSION || 'v1';
const API_BASE_URL = `/api/${API_VERSION}`;

// 或者从 URL 路径检测版本
function getApiVersion() {
  const path = window.location.pathname;
  if (path.startsWith('/v1.5')) return 'v1.5';
  if (path.startsWith('/v1')) return 'v1';
  return 'v1'; // 默认
}

const API_BASE_URL = `/api/${getApiVersion()}`;
```

---

## 4. 无觉察版本更新策略

### 4.1 用户版本切换

**方案A：前端路由切换（推荐）**

用户访问不同路径，自动使用对应版本：
- `example.com/v1/*` → V1 版本
- `example.com/v1.5/*` → V1.5 版本

**方案B：用户设置切换**

用户可以在设置中选择使用的版本：
- 用户设置中保存 `preferredVersion: 'v1.5'`
- 前端根据用户设置自动切换 API 版本
- 用户无感知，体验一致

**方案C：渐进式迁移**

1. **灰度发布**：部分用户使用新版本，部分用户使用旧版本
2. **自动升级**：用户首次访问时，提示升级到新版本
3. **回退机制**：用户可以随时切换回旧版本

### 4.2 数据迁移策略

**方案A：共享数据库 + 版本标识**

所有版本共享同一数据库，通过版本标识区分：

```sql
-- agents 表添加版本字段
ALTER TABLE agents ADD COLUMN api_version VARCHAR(10) DEFAULT 'v1';

-- 查询时过滤版本
SELECT * FROM agents WHERE user_id = ? AND api_version = 'v1.5';
```

**方案B：独立数据库**

每个版本使用独立的数据库：
- `npc_db_v1`：V1 版本数据
- `npc_db_v1.5`：V1.5 版本数据
- 需要数据迁移工具同步数据

**推荐使用方案A**：更简单，数据共享，迁移成本低。

### 4.3 平滑切换流程

```
用户访问 example.com/v1.5/
  ↓
前端检测到版本 v1.5
  ↓
前端使用 /api/v1.5/* API
  ↓
Nginx 路由到 backend-v1.5
  ↓
后端处理请求，返回数据
  ↓
前端渲染，用户无感知
```

---

## 5. 部署流程

### 5.1 并行部署流程

```bash
# 1. 启动 V1 版本
docker-compose up -d backend-v1 frontend-v1

# 2. 启动 V1.5 版本（并行）
docker-compose up -d backend-v1.5 frontend-v1.5

# 3. 启动 Nginx（路由分发）
docker-compose up -d nginx

# 4. 验证部署
curl http://localhost/api/v1/health
curl http://localhost/api/v1.5/health
```

### 5.2 版本更新流程

**无停机更新**：

```bash
# 1. 构建新版本镜像
docker-compose build backend-v1.5 frontend-v1.5

# 2. 滚动更新（先更新后端，再更新前端）
docker-compose up -d --no-deps backend-v1.5
# 等待健康检查通过
docker-compose up -d --no-deps frontend-v1.5

# 3. 验证更新
curl http://localhost/api/v1.5/health

# 4. 如果出现问题，快速回退
docker-compose up -d --no-deps backend-v1.5:previous-tag
```

### 5.3 回退流程

```bash
# 快速回退到上一个版本
docker-compose up -d --no-deps backend-v1.5:previous-tag frontend-v1.5:previous-tag

# 或者切换到 V1 版本
# 修改 Nginx 配置，将默认路由指向 V1
```

---

## 6. 优势与挑战

### 6.1 优势

1. **并行开发**：不同版本可以同时开发和测试
2. **独立部署**：每个版本可以独立部署和更新
3. **无停机更新**：更新一个版本不影响其他版本
4. **渐进式迁移**：可以逐步将用户迁移到新版本
5. **A/B 测试**：可以同时测试多个版本
6. **快速回退**：出现问题可以快速切换回旧版本

### 6.2 挑战

1. **资源消耗**：需要运行多个版本的容器
2. **数据一致性**：需要确保不同版本的数据一致性
3. **配置管理**：需要管理多个版本的配置
4. **测试复杂度**：需要测试多个版本的兼容性
5. **维护成本**：需要同时维护多个版本

### 6.3 最佳实践

1. **版本生命周期管理**：
   - 明确每个版本的生命周期
   - 定期清理不再使用的版本
   - 保持最多 2-3 个活跃版本

2. **数据迁移策略**：
   - 使用共享数据库 + 版本标识
   - 提供数据迁移工具
   - 确保数据向后兼容

3. **监控和告警**：
   - 监控每个版本的健康状态
   - 设置版本级别的告警
   - 记录版本切换日志

4. **文档管理**：
   - 为每个版本维护独立的 API 文档
   - 记录版本间的差异和迁移指南
   - 提供版本选择建议

---

## 7. 实现建议

### 7.1 阶段一：基础版本路由（1-2周）

1. 修改 Nginx 配置，支持多版本路由
2. 修改 Docker Compose，支持多版本容器
3. 修改后端路由，支持版本路径
4. 修改前端配置，支持版本切换
5. 测试基础路由功能

### 7.2 阶段二：数据共享（1周）

1. 数据库添加版本标识字段
2. 修改 Repository 层，支持版本过滤
3. 实现数据迁移工具
4. 测试数据一致性

### 7.3 阶段三：用户切换（1周）

1. 实现用户版本选择功能
2. 实现前端自动版本检测
3. 实现版本切换 UI
4. 测试用户体验

### 7.4 阶段四：监控和优化（持续）

1. 添加版本级别的监控
2. 优化资源使用
3. 完善文档和工具
4. 持续优化部署流程

---

## 8. 示例配置

### 8.1 环境变量配置

**`.env`**：

```env
# 数据库配置（共享）
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=npc_db

# V1 版本配置
V1_BACKEND_PORT=8000
V1_FRONTEND_PORT=3000

# V1.5 版本配置
V1.5_BACKEND_PORT=8001
V1.5_FRONTEND_PORT=3001

# Nginx 配置
NGINX_HTTP_PORT=80
NGINX_HTTPS_PORT=443

# LLM 配置（共享）
OPENROUTER_API_KEY=your_api_key
```

### 8.2 部署脚本

**`deploy-version.sh`**：

```bash
#!/bin/bash

VERSION=$1  # v1 或 v1.5

if [ -z "$VERSION" ]; then
    echo "Usage: ./deploy-version.sh <version>"
    exit 1
fi

echo "Deploying version $VERSION..."

# 构建镜像
docker-compose build backend-$VERSION frontend-$VERSION

# 启动服务
docker-compose up -d backend-$VERSION frontend-$VERSION

# 等待健康检查
echo "Waiting for health check..."
sleep 10

# 验证部署
curl -f http://localhost/api/$VERSION/health || exit 1

echo "Version $VERSION deployed successfully!"
```

---

## 9. 总结

### 9.1 可行性

✅ **完全可行**：通过 URL 路径版本控制和 Nginx 路由分发，可以实现：
- 不同版本并行开发和部署
- 一个域名下使用不同的 API 路径
- 无觉察版本更新
- 平滑版本切换

### 9.2 推荐方案

1. **URL 路径版本控制**：`/api/v1` 和 `/api/v1.5`
2. **共享数据库 + 版本标识**：数据共享，通过版本字段区分
3. **独立容器部署**：每个版本独立容器，互不影响
4. **Nginx 路由分发**：统一入口，自动路由到对应版本

### 9.3 注意事项

1. **资源管理**：注意控制同时运行的版本数量
2. **数据一致性**：确保不同版本的数据一致性
3. **版本生命周期**：及时清理不再使用的版本
4. **监控告警**：监控每个版本的运行状态

---

**相关文档**：
- [V1 API 设计](../v1/04-API设计.md)
- [V1.5 版本规划](../v1.5/README.md)
- [部署指南](../../DEPLOYMENT.md)
- [系统架构](../v1/06-系统架构.md)

