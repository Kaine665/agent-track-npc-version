# 线上更新方案

> **文档版本**：v1.0  
> **最后更新**：2025-01-XX  
> **相关文档**：[部署指南](./DEPLOYMENT.md) | [版本管理与并行部署策略](./产品文档/其他/11-版本管理与并行部署策略.md)

---

## 📋 目录

1. [方案概览](#方案概览)
2. [⚠️ 重要：预部署检查](#重要预部署检查)
3. [方案一：简单更新（当前方式）](#方案一简单更新当前方式)
4. [方案二：零停机更新（蓝绿部署）](#方案二零停机更新蓝绿部署)
5. [方案三：滚动更新](#方案三滚动更新)
6. [方案四：版本并行部署](#方案四版本并行部署)
7. [方案对比](#方案对比)
8. [推荐方案](#推荐方案)

---

## 方案概览

根据你的项目架构（Docker Compose + Nginx + 前后端分离），以下是几种可行的线上更新方案：

| 方案 | 停机时间 | 复杂度 | 适用场景 | 资源消耗 |
|------|---------|--------|---------|---------|
| 方案一：简单更新 | 有（30秒-2分钟） | ⭐ 低 | 小规模、非关键业务 | 低 |
| 方案二：蓝绿部署 | 无 | ⭐⭐⭐ 中 | 生产环境、高可用 | 高（2倍资源） |
| 方案三：滚动更新 | 无（几乎） | ⭐⭐ 中低 | 生产环境、中等规模 | 中 |
| 方案四：版本并行 | 无 | ⭐⭐⭐⭐ 高 | 多版本管理、A/B测试 | 高（多版本） |

---

## ⚠️ 重要：预部署检查

### 📝 为什么需要预部署检查？

在部署更新之前，**必须确保代码没有问题**，否则可能导致：
- ❌ 线上服务崩溃
- ❌ 用户体验受损
- ❌ 数据丢失风险
- ❌ 回退困难

### ✅ 预部署检查包含什么？

我们的预部署检查脚本 (`scripts/pre-deploy-check.sh`) 会自动检查：

1. **Git 状态检查**
   - 是否有未提交的更改
   - 当前分支是否正确

2. **环境变量检查**
   - `.env` 文件是否存在
   - 关键配置是否已设置（数据库密码、API Key 等）

3. **后端代码检查**
   - 运行所有单元测试 (`npm test`)
   - 确保测试通过

4. **前端代码检查**
   - ESLint 代码检查 (`npm run lint`)
   - 构建测试 (`npm run build`)
   - 确保代码能正常构建

5. **Docker 环境检查**
   - Docker 是否运行
   - Docker Compose 是否可用

6. **配置文件检查**
   - 必要的配置文件是否存在

### 🚀 使用方法

**单独运行预部署检查**：
```bash
# Linux/Mac
chmod +x scripts/pre-deploy-check.sh
./scripts/pre-deploy-check.sh

# Windows
.\scripts\pre-deploy-check.ps1
```

**更新脚本会自动运行预部署检查**：
- `update-simple.sh` 和 `update-rolling.sh` 都会在部署前自动运行检查
- 如果检查失败，更新会被中止

### 💡 最佳实践

1. **本地先运行检查**：在提交代码前，先在本地运行预部署检查
2. **CI/CD 集成**：如果使用 CI/CD，可以在流水线中加入预部署检查
3. **不要跳过检查**：除非紧急情况，否则不要跳过预部署检查

---

## 方案一：简单更新（当前方式）

### 📝 方案说明

这是当前 `DEPLOYMENT.md` 中提到的更新方式，适合小规模部署和非关键业务场景。

### ✅ 优点

- **简单直接**：操作步骤少，容易理解
- **资源消耗低**：不需要额外的容器资源
- **适合小规模**：对于用户量不大的应用完全够用

### ❌ 缺点

- **有停机时间**：更新过程中服务会短暂中断（30秒-2分钟）
- **风险较高**：如果新版本有问题，需要手动回退

### 🔧 实现步骤

**推荐方式（使用脚本，包含预部署检查）**：
```bash
chmod +x scripts/update-simple.sh
./scripts/update-simple.sh
```

**手动方式（不推荐，缺少检查）**：
```bash
# 1. 先运行预部署检查（重要！）
./scripts/pre-deploy-check.sh

# 2. 拉取最新代码
git pull origin main

# 3. 重新构建镜像（如果需要代码更新）
docker-compose build --no-cache

# 4. 重启服务（会短暂停机）
docker-compose restart

# 或者使用 up 命令（推荐，会自动重建容器）
docker-compose up -d --build
```

### 📋 更新脚本

已创建 `scripts/update-simple.sh`（**已集成预部署检查**）：

```bash
#!/bin/bash

set -e

echo "🚀 开始简单更新..."

# 拉取最新代码
echo "📥 拉取最新代码..."
git pull origin main

# 重新构建并启动
echo "🏗️  重新构建镜像..."
docker-compose build --no-cache

echo "🔄 重启服务（会有短暂停机）..."
docker-compose up -d

# 等待服务启动
echo "⏳ 等待服务启动..."
sleep 10

# 检查服务状态
echo "📊 检查服务状态..."
docker-compose ps

# 健康检查
echo "🧪 健康检查..."
if curl -f http://localhost:8000/api/v1/health &> /dev/null; then
    echo "✅ 更新成功！"
else
    echo "❌ 更新失败，请检查日志: docker-compose logs"
    exit 1
fi
```

### 🎯 适用场景

- 开发/测试环境
- 用户量较小的生产环境
- 可以接受短暂停机的场景

---

## 方案二：零停机更新（蓝绿部署）

### 📝 方案说明

通过运行两套完全相同的环境（蓝色和绿色），在更新时先更新备用环境，然后切换流量，实现零停机更新。

### ✅ 优点

- **零停机时间**：用户无感知更新
- **快速回退**：如果新版本有问题，可以立即切回旧版本
- **高可用性**：适合生产环境

### ❌ 缺点

- **资源消耗高**：需要运行两套环境（2倍资源）
- **配置复杂**：需要修改 Docker Compose 和 Nginx 配置
- **数据一致性**：需要确保两套环境使用同一数据库

### 🔧 实现步骤

#### 1. 修改 `docker-compose.yml`

添加蓝绿部署配置：

```yaml
services:
  # ==================== 蓝色环境（当前生产）====================
  backend-blue:
    build:
      context: ./npc-backend
      dockerfile: Dockerfile
    container_name: npc-backend-blue
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 8000
      DB_HOST: mysql
      DB_PORT: 3306
      DB_USER: ${DB_USER:-root}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: ${DB_NAME:-npc_db}
      OPENROUTER_API_KEY: "${OPENROUTER_API_KEY:-}"
    ports:
      - "8000:8000"  # 蓝色后端端口
    depends_on:
      mysql:
        condition: service_healthy
    networks:
      - npc-network
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:8000/api/v1/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
      interval: 30s
      timeout: 10s
      retries: 3

  frontend-blue:
    build:
      context: ./npc-frontend
      dockerfile: Dockerfile
      args:
        VITE_API_BASE_URL: /api
        VITE_API_MODE: http
    container_name: npc-frontend-blue
    restart: unless-stopped
    ports:
      - "3000:80"  # 蓝色前端端口
    depends_on:
      - backend-blue
    networks:
      - npc-network

  # ==================== 绿色环境（备用/新版本）====================
  backend-green:
    build:
      context: ./npc-backend
      dockerfile: Dockerfile
    container_name: npc-backend-green
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 8001
      DB_HOST: mysql
      DB_PORT: 3306
      DB_USER: ${DB_USER:-root}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: ${DB_NAME:-npc_db}
      OPENROUTER_API_KEY: "${OPENROUTER_API_KEY:-}"
    ports:
      - "8001:8001"  # 绿色后端端口
    depends_on:
      mysql:
        condition: service_healthy
    networks:
      - npc-network
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:8001/api/v1/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
      interval: 30s
      timeout: 10s
      retries: 3

  frontend-green:
    build:
      context: ./npc-frontend
      dockerfile: Dockerfile
      args:
        VITE_API_BASE_URL: /api
        VITE_API_MODE: http
    container_name: npc-frontend-green
    restart: unless-stopped
    ports:
      - "3001:80"  # 绿色前端端口
    depends_on:
      - backend-green
    networks:
      - npc-network

  # ==================== Nginx（支持蓝绿切换）====================
  nginx:
    image: nginx:alpine
    container_name: npc-nginx
    restart: unless-stopped
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
    depends_on:
      - backend-blue
      - backend-green
      - frontend-blue
      - frontend-green
    networks:
      - npc-network

  # MySQL（共享）
  mysql:
    # ... 保持原有配置
```

#### 2. 修改 Nginx 配置支持蓝绿切换

创建 `nginx/conf.d/blue-green.conf`：

```nginx
# 上游服务器：蓝色环境
upstream backend-blue {
    server backend-blue:8000;
    keepalive 32;
}

upstream frontend-blue {
    server frontend-blue:80;
    keepalive 32;
}

# 上游服务器：绿色环境
upstream backend-green {
    server backend-green:8001;
    keepalive 32;
}

upstream frontend-green {
    server frontend-green:80;
    keepalive 32;
}

# 当前生产环境（通过环境变量或配置文件控制）
# 默认使用蓝色环境
map $cookie_env $backend_upstream {
    default backend-blue;
    green backend-green;
}

map $cookie_env $frontend_upstream {
    default frontend-blue;
    green frontend-green;
}

server {
    listen 80;
    server_name _;

    # API 请求
    location /api/ {
        proxy_pass http://$backend_upstream;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # 前端请求
    location / {
        proxy_pass http://$frontend_upstream;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

#### 3. 创建蓝绿切换脚本

创建 `scripts/blue-green-switch.sh`：

```bash
#!/bin/bash

# 蓝绿环境切换脚本
# 使用方法：./blue-green-switch.sh [blue|green]

set -e

TARGET_ENV=${1:-green}  # 默认切换到绿色

if [ "$TARGET_ENV" != "blue" ] && [ "$TARGET_ENV" != "green" ]; then
    echo "❌ 错误：环境参数必须是 'blue' 或 'green'"
    exit 1
fi

echo "🔄 切换到 $TARGET_ENV 环境..."

# 修改 Nginx 配置（这里简化处理，实际可以使用更优雅的方式）
# 方案1：使用符号链接切换配置文件
# 方案2：使用环境变量（需要修改 Nginx 配置支持）
# 方案3：直接修改配置文件（简单但不够优雅）

# 这里使用方案3：直接修改配置文件
if [ "$TARGET_ENV" == "green" ]; then
    # 切换到绿色环境
    sed -i 's/backend-blue/backend-green/g' nginx/conf.d/blue-green.conf
    sed -i 's/frontend-blue/frontend-green/g' nginx/conf.d/blue-green.conf
else
    # 切换到蓝色环境
    sed -i 's/backend-green/backend-blue/g' nginx/conf.d/blue-green.conf
    sed -i 's/frontend-green/frontend-blue/g' nginx/conf.d/blue-green.conf
fi

# 重新加载 Nginx
docker exec npc-nginx nginx -s reload

echo "✅ 已切换到 $TARGET_ENV 环境"
```

#### 4. 创建蓝绿更新脚本

创建 `scripts/update-blue-green.sh`：

```bash
#!/bin/bash

set -e

echo "🚀 开始蓝绿部署更新..."

# 1. 拉取最新代码
echo "📥 拉取最新代码..."
git pull origin main

# 2. 确定当前生产环境
CURRENT_ENV=$(docker ps --format "{{.Names}}" | grep -E "backend-(blue|green)" | head -1 | sed 's/npc-backend-//')
if [ -z "$CURRENT_ENV" ]; then
    CURRENT_ENV="blue"
fi

# 3. 确定目标环境（备用环境）
if [ "$CURRENT_ENV" == "blue" ]; then
    TARGET_ENV="green"
else
    TARGET_ENV="blue"
fi

echo "📊 当前生产环境: $CURRENT_ENV"
echo "🎯 目标更新环境: $TARGET_ENV"

# 4. 构建目标环境
echo "🏗️  构建 $TARGET_ENV 环境..."
docker-compose build backend-$TARGET_ENV frontend-$TARGET_ENV

# 5. 启动目标环境
echo "🚀 启动 $TARGET_ENV 环境..."
docker-compose up -d backend-$TARGET_ENV frontend-$TARGET_ENV

# 6. 等待健康检查
echo "⏳ 等待 $TARGET_ENV 环境健康检查..."
sleep 15

# 7. 验证目标环境
echo "🧪 验证 $TARGET_ENV 环境..."
TARGET_PORT=$([ "$TARGET_ENV" == "blue" ] && echo "8000" || echo "8001")
if curl -f http://localhost:$TARGET_PORT/api/v1/health &> /dev/null; then
    echo "✅ $TARGET_ENV 环境健康检查通过"
else
    echo "❌ $TARGET_ENV 环境健康检查失败，取消切换"
    exit 1
fi

# 8. 切换到目标环境
echo "🔄 切换到 $TARGET_ENV 环境..."
./scripts/blue-green-switch.sh $TARGET_ENV

# 9. 等待一段时间，观察新环境是否正常
echo "⏳ 观察新环境运行情况（30秒）..."
sleep 30

# 10. 再次健康检查
if curl -f http://localhost/api/v1/health &> /dev/null; then
    echo "✅ 更新成功！当前生产环境: $TARGET_ENV"
    echo "💡 如需回退，运行: ./scripts/blue-green-switch.sh $CURRENT_ENV"
else
    echo "❌ 新环境出现问题，正在回退..."
    ./scripts/blue-green-switch.sh $CURRENT_ENV
    exit 1
fi
```

### 🎯 适用场景

- 生产环境
- 高可用性要求
- 可以接受资源消耗增加

---

## 方案三：滚动更新

### 📝 方案说明

使用 Docker Compose 的滚动更新功能，逐个更新容器，确保始终有服务可用。

### ✅ 优点

- **几乎零停机**：更新过程中始终有服务可用
- **资源消耗适中**：只需要少量额外资源
- **配置简单**：基于 Docker Compose 原生功能

### ❌ 缺点

- **更新速度较慢**：需要逐个更新容器
- **版本混合**：更新过程中可能存在新旧版本同时运行的情况

### 🔧 实现步骤

**注意**：所有更新脚本都会自动运行预部署检查，确保代码质量。

#### 1. 修改 `docker-compose.yml` 支持多实例

```yaml
services:
  backend:
    # ... 保持原有配置
    deploy:
      replicas: 2  # 运行 2 个实例
      update_config:
        parallelism: 1  # 每次更新 1 个实例
        delay: 10s  # 更新间隔
        failure_action: rollback  # 失败时回退
      restart_policy:
        condition: on-failure

  frontend:
    # ... 保持原有配置
    deploy:
      replicas: 2
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
```

**注意**：Docker Compose v2 的 `deploy` 配置主要用于 Docker Swarm 模式。对于单机部署，我们需要手动实现滚动更新。

#### 2. 创建滚动更新脚本

已创建 `scripts/update-rolling.sh`（**已集成预部署检查**）：

```bash
#!/bin/bash

set -e

echo "🚀 开始滚动更新..."

# 1. 拉取最新代码
echo "📥 拉取最新代码..."
git pull origin main

# 2. 构建新镜像
echo "🏗️  构建新镜像..."
docker-compose build --no-cache backend frontend

# 3. 更新后端（先更新一个实例，如果有多个）
echo "🔄 更新后端服务..."
docker-compose up -d --no-deps backend

# 4. 等待健康检查
echo "⏳ 等待后端健康检查..."
sleep 10

# 5. 验证后端
if curl -f http://localhost:8000/api/v1/health &> /dev/null; then
    echo "✅ 后端更新成功"
else
    echo "❌ 后端更新失败，请检查日志"
    exit 1
fi

# 6. 更新前端
echo "🔄 更新前端服务..."
docker-compose up -d --no-deps frontend

# 7. 等待前端启动
echo "⏳ 等待前端启动..."
sleep 5

# 8. 最终验证
echo "🧪 最终验证..."
if curl -f http://localhost/api/v1/health &> /dev/null; then
    echo "✅ 滚动更新成功！"
else
    echo "❌ 更新后验证失败"
    exit 1
fi
```

### 🎯 适用场景

- 生产环境
- 中等规模部署
- 需要平衡资源消耗和可用性

---

## 方案四：版本并行部署

### 📝 方案说明

这是你文档中提到的方案，支持多个版本并行运行，通过 URL 路径区分版本。

### ✅ 优点

- **完全零停机**：新版本和旧版本可以同时运行
- **快速回退**：可以立即切回旧版本
- **A/B 测试**：可以同时测试多个版本
- **渐进式迁移**：可以逐步将用户迁移到新版本

### ❌ 缺点

- **配置复杂**：需要修改大量配置文件
- **资源消耗高**：需要运行多个版本的容器
- **维护成本高**：需要同时维护多个版本

### 🔧 实现步骤

详细实现方案请参考：[版本管理与并行部署策略](./产品文档/其他/11-版本管理与并行部署策略.md)

### 🎯 适用场景

- 需要支持多版本并行
- A/B 测试需求
- 渐进式迁移需求

---

## 方案对比

| 特性 | 方案一：简单更新 | 方案二：蓝绿部署 | 方案三：滚动更新 | 方案四：版本并行 |
|------|----------------|----------------|----------------|----------------|
| **停机时间** | 30秒-2分钟 | 0秒 | 几乎0秒 | 0秒 |
| **实现复杂度** | ⭐ 低 | ⭐⭐⭐ 中 | ⭐⭐ 中低 | ⭐⭐⭐⭐ 高 |
| **资源消耗** | 低 | 高（2倍） | 中 | 高（多版本） |
| **回退速度** | 慢（需重新构建） | 快（秒级） | 中 | 快（秒级） |
| **适用规模** | 小 | 中-大 | 中 | 大 |
| **A/B 测试** | ❌ | ❌ | ❌ | ✅ |
| **版本管理** | ❌ | ❌ | ❌ | ✅ |

---

## 推荐方案

### 🎯 根据场景选择

1. **开发/测试环境** → **方案一：简单更新**
   - 简单直接，够用

2. **小规模生产环境** → **方案一或方案三**
   - 用户量不大：方案一
   - 需要高可用：方案三

3. **中大规模生产环境** → **方案二：蓝绿部署**
   - 零停机要求
   - 快速回退需求

4. **多版本管理需求** → **方案四：版本并行**
   - A/B 测试
   - 渐进式迁移

### 📋 我的建议

对于你的项目，我建议：

1. **当前阶段**：使用 **方案一（简单更新）** + **方案三（滚动更新）** 的组合
   - 开发环境用方案一
   - 生产环境用方案三

2. **未来扩展**：如果用户量增长，再考虑 **方案二（蓝绿部署）**

3. **特殊需求**：如果需要多版本管理，再实现 **方案四（版本并行）**

---

## 📚 相关文档

- [部署指南](./DEPLOYMENT.md)
- [版本管理与并行部署策略](./产品文档/其他/11-版本管理与并行部署策略.md)
- [Docker Compose 文档](https://docs.docker.com/compose/)

---

## 🔧 快速开始

### ⚠️ 重要：先运行预部署检查

**Linux/Mac**：
```bash
# 单独运行预部署检查（推荐）
chmod +x scripts/pre-deploy-check.sh
./scripts/pre-deploy-check.sh
```

**Windows**：
```powershell
# 单独运行预部署检查（推荐）
.\scripts\pre-deploy-check.ps1
```

### 使用方案一（简单更新）

**Linux/Mac**：
```bash
# 给脚本权限
chmod +x scripts/update-simple.sh

# 运行更新（会自动运行预部署检查）
./scripts/update-simple.sh
```

**Windows**：
```powershell
# 运行更新（会自动运行预部署检查）
.\scripts\update-simple.ps1
```

### 使用方案三（滚动更新）

**Linux/Mac**：
```bash
# 给脚本权限
chmod +x scripts/update-rolling.sh

# 运行更新（会自动运行预部署检查）
./scripts/update-rolling.sh
```

**Windows**：
```powershell
# 运行更新（会自动运行预部署检查）
.\scripts\update-rolling.ps1
```

### 💡 更新流程说明

所有更新脚本都会按以下流程执行：

1. **🔍 预部署检查**（自动）
   - Git 状态检查
   - 环境变量检查
   - 后端测试运行
   - 前端代码检查
   - Docker 环境检查

2. **📥 拉取代码并构建**
   - Git pull
   - Docker 镜像构建

3. **🔄 部署服务**
   - 重启容器
   - 健康检查验证

---

**需要帮助？** 查看项目根目录的 `README.md` 或提交 Issue。

