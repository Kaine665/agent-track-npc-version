# 实现问题记录

> 本文档用于记录开发过程中遇到的问题、解决方案，以及是否需要更新产品文档。
> 每次发现问题时，请及时记录，方便追踪和避免重复错误。

问题速记
（已清空，问题已记录为 PROB-002 和 PROB-003）

---

## 📋 问题分类

- **代码错误**：语法错误、逻辑错误、API 调用错误等
- **文档错误**：产品文档中的需求不合理、有矛盾、遗漏等
- **实现与文档不一致**：代码实现和文档不一致，需要统一标准
- **性能问题**：性能不符合预期，需要优化
- **技术决策**：重要的架构选择、技术方案选择等
- **其他问题**：其他类型的问题

---

## 🔍 问题记录模板

### 问题编号：PROB-001

**发现时间**：2024-12-19  
**发现人**：开发者  
**问题类型**：代码错误 / 文档错误 / 实现与文档不一致 / 性能问题 / 其他

**问题描述**：

- 具体描述问题是什么
- 在哪个文件/功能中发现的
- 错误信息或异常行为

**问题影响**：

- 影响范围（功能、模块、系统）
- 严重程度（严重 / 中等 / 轻微）

**解决方案**：

- 如何修复的
- 修复代码（如果是代码问题）
- 修复后的验证结果

**是否需要更新文档**：

- [ ] 是 - 需要更新哪个文档：[文档名称]
- [ ] 否

**文档更新内容**（如果需要）：

- 更新了什么内容
- 为什么需要更新

**相关文件**：

- 问题文件：[文件路径]
- 修复文件：[文件路径]
- 文档文件：[文件路径]

**备注**：

- 其他需要说明的内容

---

## 📝 问题记录

### PROB-001：Agent 内存存储结构选择（方案 C）

**发现时间**：2025-11-20  
**发现人**：开发者  
**问题类型**：技术决策

**问题描述**：
在实现阶段 1（创建 NPC API）时，需要选择 Agent 数据的内存存储结构。经过讨论，提出了三种方案：

- **方案 A**：`Map<agentId, Agent>`（全局存储）
- **方案 B**：`{ [userId]: Agent[] }`（按用户分组）
- **方案 C**：独立存储 + 用户关系索引（混合方案）

**问题影响**：

- 影响范围：数据访问层（repositories/AgentRepository.js）
- 严重程度：中等（架构决策，影响后续开发）

**方案对比**：

| 操作                 | 方案 A（Map） | 方案 B（按用户分组） | 方案 C（混合） |
| -------------------- | ------------- | -------------------- | -------------- |
| 通过 agentId 查询    | O(1)          | O(m) 或 O(n)         | O(1)           |
| 获取用户的所有 Agent | O(n)          | O(1)                 | O(1)           |
| 检查名称唯一性       | O(n)          | O(m)                 | O(1)           |
| 支持多用户共享 Agent | 需要额外处理  | 需要额外处理         | ✅ 天然支持    |
| 支持 Agent 独立身份  | 需要调整      | 需要调整             | ✅ 天然支持    |

**决策过程**：

1. 考虑未来需求：同一个 Agent 可能同时与两个用户交互
2. 考虑未来需求：Agent 可能迁移成独立身份，与其他角色交互
3. 分析主要查询场景：按用户获取列表是主要操作
4. 分析性能需求：需要兼顾查询 Agent 和查询用户列表的性能

**解决方案**：
选择**方案 C：独立存储 + 用户关系索引**

**实现细节**：

```javascript
// 1. 全局 Agent 存储
const agentsMap = new Map(); // Map<agentId, Agent>

// 2. 用户关系索引（快速查询用户列表）
const agentsByUser = {}; // { [userId]: agentId[] }

// 3. 用户名称索引（快速检查名称唯一性）
const userNameIndex = {}; // { [userId]: { [name]: agentId } }
```

**优点**：

- ✅ 支持多用户共享 Agent（独立存储）
- ✅ 支持 Agent 独立身份（未来扩展）
- ✅ 查询用户列表快（O(1)，通过 agentsByUser 索引）
- ✅ 查询 Agent 快（O(1)，通过 agentsMap）
- ✅ 名称唯一性检查快（O(1)，通过 userNameIndex）
- ✅ 未来无需重构（数据结构已支持扩展）

**缺点**：

- ⚠️ 需要维护三个数据结构（代码复杂度稍高）
- ⚠️ 创建/删除时需要同步更新三个索引

**决策原因**：

1. **未来扩展性**：方案 C 天然支持多用户共享和 Agent 独立身份，无需重构
2. **性能平衡**：兼顾了所有查询场景的性能需求
3. **业务逻辑**：Agent 是独立实体，用户关系是关联关系，符合业务逻辑
4. **迁移成本**：当前实现稍复杂，但未来扩展成本低

**是否需要更新文档**：

- [x] 是 - 需要更新哪个文档：开发进度.md（已更新实现细节）
- [ ] 否

**文档更新内容**：

- 在开发进度.md 中记录了方案 C 的实现细节
- 在实现问题记录.md 中记录决策过程（本文档）

**相关文件**：

- 问题文件：repositories/AgentRepository.js
- 文档文件：开发进度.md、实现问题记录.md

**备注**：

- 此决策考虑了未来可能的需求（多用户共享、Agent 独立身份）
- 虽然当前实现复杂度稍高，但为未来扩展打下了良好基础
- 如果未来需求变化，可以基于此结构进行扩展，无需重构

---

### PROB-002：API 路由设计 - 同一路径使用不同 HTTP 方法

**发现时间**：2025-11-20  
**发现人**：开发者  
**问题类型**：技术决策

**问题描述**：

在实现阶段 1（创建 NPC API）时，发现创建 NPC 和获取 NPC 列表使用了同一个路径 `/api/v1/agents`，但使用不同的 HTTP 方法（POST 和 GET）。需要确认这种设计是否合理。

**具体场景**：

- `POST /api/v1/agents` - 创建 NPC
- `GET /api/v1/agents` - 获取 NPC 列表

**问题影响**：

- 影响范围：API 路由设计（routes/agents.js）
- 严重程度：轻微（设计确认，不影响功能）

**分析过程**：

1. **RESTful 规范检查**：

   - 这是标准的 RESTful API 设计模式
   - 路径表示资源（`/agents`），HTTP 方法表示操作（POST 创建，GET 查询）
   - 符合 HTTP 标准语义

2. **业界实践对比**：

   - GitHub API: `POST /repos` 创建仓库，`GET /repos` 获取仓库列表
   - Twitter API: `POST /tweets` 创建推文，`GET /tweets` 获取推文列表
   - 这是业界通用的最佳实践

3. **产品文档验证**：
   - 产品文档（04-API 设计.md）明确说明遵循 RESTful 风格
   - 当前实现与文档一致

**解决方案**：

**确认当前设计合理，无需修改**

**设计优势**：

- ✅ **语义清晰**：路径表示资源，方法表示操作，符合 RESTful 规范
- ✅ **易于理解**：符合 HTTP 标准语义，开发者容易理解
- ✅ **扩展性好**：后续可以轻松添加：
  - `GET /api/v1/agents/:id` - 获取单个 NPC 详情
  - `PUT /api/v1/agents/:id` - 更新 NPC
  - `DELETE /api/v1/agents/:id` - 删除 NPC
- ✅ **符合规范**：与产品文档中的 RESTful 设计原则一致

**是否需要更新文档**：

- [ ] 是 - 需要更新哪个文档：[文档名称]
- [x] 否

**相关文件**：

- 问题文件：routes/agents.js
- 文档文件：产品文档/04-API 设计.md

**备注**：

- 这是标准的 RESTful API 设计，完全符合业界最佳实践
- 当前实现无需修改，可以继续使用
- 后续扩展其他操作（GET /:id、PUT /:id、DELETE /:id）时，也应遵循相同的设计原则

---

### PROB-003：Agent 与 Model 分离设计确认

**发现时间**：2025-11-20  
**发现人**：开发者  
**问题类型**：技术决策

**问题描述**：

在实现阶段 1（创建 NPC API）时，发现创建 Agent 时只保存了 `model` 字段（如 "gpt-4.1"），但没有实际调用 LLM API。需要确认这是否是 Agent 与 Model 分离的设计，以及这种设计是否合理。

**具体场景**：

- 创建 Agent 时：只保存配置信息（包括 `model` 字段），不调用 LLM
- 实际调用 LLM：将在阶段 4（发送消息）时进行

**问题影响**：

- 影响范围：业务逻辑层设计（services/AgentService.js、未来 MessageService.js）
- 严重程度：中等（架构决策，影响后续开发）

**设计分析**：

1. **当前实现**：

   - Agent 创建时只保存配置信息（元数据）
   - `model` 字段表示"这个 Agent 使用哪个 LLM 模型"
   - 此时不调用 LLM API

2. **后续流程**（阶段 4）：

   - 发送消息时，根据 Agent 的 `model` 字段选择对应的 LLM 服务
   - MessageService 负责实际调用 LLM

3. **设计模式**：
   - Agent = 配置/元数据（包含 model 选择）
   - Model = LLM 服务（实际调用）
   - 两者是配置关系，不是调用关系

**解决方案**：

**确认当前设计合理，这是正确的架构分离**

**设计优势**：

- ✅ **职责清晰**：
  - AgentService：管理 Agent 配置和元数据
  - MessageService：负责调用 LLM 进行对话
  - LLMService：封装 LLM API 调用
- ✅ **性能优化**：创建 Agent 不需要等待 LLM 响应，响应速度快
- ✅ **灵活性**：可以更换模型而不影响已有 Agent 的配置
- ✅ **符合阶段化开发**：先完成 Agent 管理，再实现对话功能
- ✅ **解耦合**：Agent 配置与 LLM 调用分离，便于测试和维护

**设计流程**：

```
阶段 1：创建 Agent
  └─> 保存 Agent 配置（包括 model 字段）
      └─> 不调用 LLM

阶段 4：发送消息
  └─> 获取 Agent（包含 model 配置）
      └─> 根据 Agent.model 调用对应的 LLM
          └─> LLMService.call(agent.model, {...})
```

**未来实现示例**（阶段 4）：

```javascript
// MessageService 会这样工作：
function sendMessage(agentId, message) {
  // 1. 获取 Agent（包含 model 配置）
  const agent = agentService.getAgentById(agentId);

  // 2. 根据 Agent 的 model 字段调用对应的 LLM
  const response = llmService.call(agent.model, {
    systemPrompt: agent.systemPrompt,
    messages: [...history, message],
  });

  // 3. 保存对话记录
  return response;
}
```

**是否需要更新文档**：

- [ ] 是 - 需要更新哪个文档：[文档名称]
- [x] 否

**相关文件**：

- 问题文件：services/AgentService.js
- 未来文件：services/MessageService.js、services/LLMService.js
- 文档文件：项目结构演进指南.md（阶段 4 说明）

**备注**：

- Agent 与 Model 分离是正确的架构选择
- 这种设计符合单一职责原则和关注点分离
- 为后续阶段（阶段 4：对话功能）的实现打下了良好基础
- 当前实现无需修改，可以继续按此设计推进

---

### PROB-004：Session 和 Event 存储结构设计

**发现时间**：2025-11-20  
**发现人**：开发者  
**问题类型**：技术决策

**问题描述**：

在实现阶段 4（对话功能）时，需要设计 Session（会话）和 Event（事件）的存储结构。经过讨论，确定了以下设计决策：

1. **Session 设计**：

   - 使用独立生成的 sessionId（不依赖参与者）
   - 使用 participants 列表（支持任意参与者）
   - 不设置会话类型（通过 participants 推断）
   - 单会话模式：同一参与者组合只有一个会话

2. **存储结构**：

   - 中心化存储（单一数据源）：sessionsMap、eventsMap
   - 参与者索引（性能优化）：sessionsByUser、sessionsByAgent、eventsBySession
   - 双向索引：每个参与者维护自己参与的会话列表

3. **排序问题**：

   - participants 需要排序存储，保证顺序一致
   - 排序规则：先按 type（user < agent），再按 id（字母序）

4. **多会话问题**：
   - 当前阶段：单会话模式（同一参与者组合只有一个会话）
   - 未来扩展：可以通过事件筛选实现主题区分

**问题影响**：

- 影响范围：数据访问层（repositories/EventRepository.js）
- 严重程度：中等（架构决策，影响后续开发）

**设计决策**：

**1. Session ID 生成**

- **方案**：独立生成 sessionId（`session_${timestamp}_${random}`）
- **原因**：不依赖参与者，支持未来扩展（Agent-to-Agent、多人会话）

**2. Participants 设计**

- **方案**：使用 participants 列表，不设置 type 字段
- **原因**：通过 participants 动态推断会话类型，扩展性强

**3. 存储结构**

- **方案**：中心化存储 + 参与者索引（双向索引）
- **原因**：
  - 单一数据源保证一致性
  - 双向索引提供"参与者视角"的查询
  - 性能优化（O(min(m, n)) 查询）

**4. 排序标准化**

- **方案**：`normalizeParticipants()` 函数排序存储
- **原因**：
  - 保证顺序一致
  - 避免重复创建会话
  - 索引查询一致性

**5. 单会话模式**

- **方案**：同一参与者组合只有一个会话
- **原因**：
  - 简化当前实现
  - 符合常见使用场景
  - 主题区分后续通过事件筛选实现

**实现细节**：

```javascript
// 1. 中心化存储（单一数据源）
const sessionsMap = new Map();  // Map<sessionId, Session>
const eventsMap = new Map();    // Map<eventId, Event>

// 2. 参与者索引（性能优化）
const sessionsByUser = {};   // { [userId]: sessionId[] }
const sessionsByAgent = {};  // { [agentId]: sessionId[] }
const eventsBySession = {};  // { [sessionId]: eventId[] }

// 3. 核心函数
normalizeParticipants(participants) → participants[]  // 排序
getOrCreateSession(participants) → Session           // 单会话模式
findSessionByParticipants(participants) → Session | null
createEvent(eventData) → Event
getEventsBySession(sessionId) → Event[]
getRecentEvents(sessionId, limit) → Event[]
```

**未来功能（已实现但未使用）**：

以下功能已实现但当前阶段不使用，标注为"未来功能"：

1. **`getEventsBySessionWithOptions()`**：

   - 功能：支持主题筛选、分页等高级查询
   - 状态：已实现但未使用
   - 原因：当前阶段不需要主题筛选，后续通过算法实现

2. **`filterEventsByTopic()`**：
   - 功能：按主题筛选事件
   - 状态：已实现但未使用
   - 原因：主题识别算法待实现

**优点**：

- ✅ **扩展性强**：支持一对一、Agent-to-Agent、多人会话（未来）
- ✅ **性能优化**：双向索引提供快速查询（O(min(m, n))）
- ✅ **一致性保证**：中心化存储作为单一数据源
- ✅ **设计清晰**：符合"参与者视角"的设计理念
- ✅ **未来友好**：预留主题筛选接口，不影响当前实现

**缺点**：

- ⚠️ 需要维护多个索引的一致性
- ⚠️ 创建/删除时需要同步更新多个索引
- ⚠️ 代码复杂度稍高

**决策原因**：

1. **未来扩展性**：设计支持所有未来场景，无需重构
2. **性能平衡**：兼顾查询性能和存储一致性
3. **业务逻辑**：符合"参与者视角"的业务逻辑
4. **渐进式开发**：当前单会话模式，未来可扩展多会话

**是否需要更新文档**：

- [x] 是 - 需要更新哪个文档：实现问题记录.md（本文档）、EventRepository.js（代码注释）
- [ ] 否

**文档更新内容**：

- 在 EventRepository.js 中标注了"未来功能"的函数
- 在实现问题记录.md 中记录了设计决策（本文档）

**相关文件**：

- 问题文件：repositories/EventRepository.js
- 文档文件：实现问题记录.md

**备注**：

- 此决策考虑了未来可能的需求（Agent-to-Agent、多人会话、主题筛选）
- 虽然当前实现复杂度稍高，但为未来扩展打下了良好基础
- 未来功能已实现但未使用，避免后续重构成本
- 主题区分后续通过事件筛选算法实现，不影响当前设计

---

### PROB-005：Session 和 Event 存储分离重构

**发现时间**：2025-11-20  
**发现人**：开发者  
**问题类型**：技术决策

**问题描述**：

在实现阶段 4（对话功能）时，发现 EventRepository.js 同时管理 Session 和 Event 两种实体，EventService.js 也同时处理 Session 和 Event 的业务逻辑。经过讨论，决定将 Session 和 Event 的存储和业务逻辑分离。

**问题影响**：

- 影响范围：数据访问层（repositories）、业务逻辑层（services）
- 严重程度：中等（架构重构，影响代码组织）

**设计决策**：

**1. Repository 层分离**

- **方案**：创建独立的 SessionRepository.js 和 EventRepository.js
- **原因**：
  - 符合单一职责原则（每个 Repository 只负责一种实体）
  - 与 AgentRepository 风格一致
  - 代码组织更清晰
  - 未来扩展性更好（Session 和 Event 可独立演进）

**2. Service 层分离**

- **方案**：创建独立的 SessionService.js 和 EventService.js
- **原因**：
  - 与 Repository 分离保持一致
  - 符合单一职责原则
  - 代码组织更清晰
  - 便于独立演进

**3. 依赖关系**

- **EventService** → **SessionService**（用于更新会话活动时间）
- **EventService** → **EventRepository**（用于事件操作）
- **SessionService** → **SessionRepository**（用于会话操作）

**实现细节**：

```javascript
// 分离后的结构
repositories/
├── SessionRepository.js  # Session 数据访问
└── EventRepository.js    # Event 数据访问

services/
├── SessionService.js     # Session 业务逻辑
└── EventService.js       # Event 业务逻辑（依赖 SessionService）

// EventService.createEvent() 中调用 SessionService.updateActivity()
function createEvent(eventData) {
  const event = eventRepository.createEvent(eventData);
  sessionService.updateSessionActivity(event.sessionId); // 更新活动时间
  return event;
}
```

**优点**：

- ✅ **单一职责**：每个 Repository 和 Service 只负责一种实体
- ✅ **架构一致性**：与 AgentRepository/AgentService 风格一致
- ✅ **代码清晰**：文件更小，职责更明确
- ✅ **独立演进**：Session 和 Event 可以独立扩展功能
- ✅ **易于维护**：修改 Session 不影响 Event，反之亦然

**缺点**：

- ⚠️ 文件数量增加（从 2 个增加到 4 个）
- ⚠️ EventService 需要依赖 SessionService（但这是合理的依赖关系）

**决策原因**：

1. **单一职责原则**：每个模块只负责一种实体，职责清晰
2. **架构一致性**：与现有的 AgentRepository/AgentService 风格保持一致
3. **未来扩展性**：Session 和 Event 可以独立演进，互不影响
4. **代码质量**：更符合 SOLID 原则，提高代码可维护性

**是否需要更新文档**：

- [x] 是 - 需要更新哪个文档：实现问题记录.md（本文档）、开发进度.md
- [ ] 否

**文档更新内容**：

- 在实现问题记录.md 中记录了设计决策（本文档）
- 在开发进度.md 中更新了任务描述

**相关文件**：

- 问题文件：repositories/EventRepository.js、services/EventService.js
- 新建文件：repositories/SessionRepository.js、services/SessionService.js
- 重构文件：repositories/EventRepository.js、services/EventService.js

**备注**：

- 此重构符合单一职责原则和 SOLID 原则
- 虽然文件数量增加，但代码组织更清晰，职责更明确
- 为未来扩展（Session 状态管理、Event 主题筛选等）打下了良好基础
- 与现有的 AgentRepository/AgentService 架构保持一致

---

### PROB-006：LLM 模型列表数据维护问题

**发现时间**：2025-11-20  
**发现人**：开发者  
**问题类型**：技术决策

**问题描述**：

在实现 LLMService 和模型配置管理时，发现 LLM 提供商（OpenAI、DeepSeek、OpenRouter）支持的模型列表和模型名称会频繁更新：

1. **模型发布频繁**：各提供商定期发布新模型（如 GPT-4o、Claude 4.5 Sonnet、DeepSeek-V3.1 等）
2. **模型名称变化**：同一模型可能有多个版本名称（如 `gpt-4-turbo`、`gpt-4o`、`gpt-4o-mini`）
3. **模型格式差异**：不同提供商的模型命名格式不同（OpenAI/DeepSeek 直接使用模型名，OpenRouter 使用 `provider/model-name` 格式）
4. **模型可用性变化**：某些模型可能被弃用或替换（如 GPT-3.5-turbo 的多个版本）

**问题影响**：

- 影响范围：`config/models.js`、`docs/LLM_MODELS.md`、`test-llm.js`、`README.md`
- 严重程度：中等（影响用户体验和功能可用性）

**设计决策**：

**1. 当前方案：文档 + 代码注释**

- **方案**：在 `docs/LLM_MODELS.md` 中维护模型列表，在代码中添加注释说明
- **优点**：
  - 简单直接，易于理解
  - 文档集中管理，便于查阅
  - 代码注释提供快速参考
- **缺点**：
  - ⚠️ **需要人工维护**：模型更新时需要手动更新文档和代码
  - ⚠️ **容易过时**：文档可能滞后于实际可用模型
  - ⚠️ **维护成本**：需要定期检查和更新

**2. 未来可选方案：动态获取模型列表**

- **方案 A**：调用各提供商的 API 动态获取可用模型列表
  - OpenAI: `GET /v1/models`
  - OpenRouter: `GET /api/v1/models`
  - DeepSeek: 可能不支持动态获取
- **优点**：
  - ✅ 自动获取最新模型列表
  - ✅ 无需人工维护
  - ✅ 始终与提供商同步
- **缺点**：

  - ⚠️ 需要额外的 API 调用（可能影响启动时间）
  - ⚠️ 网络依赖（启动时需要网络连接）
  - ⚠️ 不同提供商 API 格式不同，需要适配
  - ⚠️ DeepSeek 可能不支持动态获取

- **方案 B**：定期自动更新文档（通过脚本）
  - 定期运行脚本调用 API 获取模型列表
  - 自动更新 `docs/LLM_MODELS.md`
- **优点**：
  - ✅ 文档自动更新
  - ✅ 不影响运行时性能
- **缺点**：
  - ⚠️ 需要定期运行脚本
  - ⚠️ 仍然需要人工检查

**3. 当前决策：采用文档 + 代码注释方案**

**决策原因**：

1. **开发阶段**：当前处于开发阶段，模型列表变化不频繁，人工维护成本可接受
2. **灵活性**：文档方式更灵活，可以添加说明、注意事项、推荐用法等
3. **简单性**：避免引入复杂的动态获取逻辑，降低系统复杂度
4. **未来扩展**：如果未来需要，可以在此基础上添加动态获取功能

**实现细节**：

```javascript
// config/models.js
// 当前：使用环境变量配置预设模型
// MODELS=gpt-4o:openai,deepseek-chat:deepseek,anthropic/claude-4.5-sonnet:openrouter

// 文档：docs/LLM_MODELS.md
// - 记录各提供商的模型列表
// - 记录模型发布时间和更新信息
// - 提供配置示例和使用建议

// 代码注释：
// - 在 config/models.js 中添加模型格式说明
// - 在 LLMService.js 中添加模型使用说明
```

**维护策略**：

1. **定期检查**：每月检查一次各提供商的模型更新
2. **更新文档**：发现新模型或模型变化时，及时更新 `docs/LLM_MODELS.md`
3. **更新代码注释**：同步更新代码中的相关注释
4. **测试验证**：更新后通过 `test-llm.js` 验证模型可用性

**未来优化方向**：

- 如果模型更新频率增加，考虑实现动态获取功能
- 可以考虑添加模型可用性检查功能（启动时或定期检查）
- 可以考虑添加模型推荐功能（根据用途推荐合适的模型）

**是否需要更新文档**：

- [x] 是 - 需要更新哪个文档：实现问题记录.md（本文档）、docs/LLM_MODELS.md
- [ ] 否

**文档更新内容**：

- 在实现问题记录.md 中记录了模型维护问题和决策（本文档）
- 在 docs/LLM_MODELS.md 中记录了模型列表和维护说明
- 在 README.md 中添加了模型配置说明

**相关文件**：

- `config/models.js`：模型配置管理
- `docs/LLM_MODELS.md`：模型列表文档（需要定期维护）
- `services/LLMService.js`：LLM 服务实现
- `test-llm.js`：模型测试脚本
- `README.md`：配置说明文档

**备注**：

- 当前采用文档维护方式，简单直接，适合开发阶段
- 未来如果模型更新频繁，可以考虑实现动态获取功能
- 建议定期（每月）检查一次模型更新情况
- 文档中已标注"最后更新"时间，便于追踪

---

## 📊 问题统计

### 按类型统计

| 问题类型         | 数量  | 占比     |
| ---------------- | ----- | -------- |
| 代码错误         | 0     | 0%       |
| 文档错误         | 0     | 0%       |
| 实现与文档不一致 | 0     | 0%       |
| 性能问题         | 0     | 0%       |
| 技术决策         | 6     | 100%     |
| 其他问题         | 0     | 0%       |
| **总计**         | **6** | **100%** |

### 按阶段统计

| 开发阶段              | 问题数量 |
| --------------------- | -------- |
| 阶段 0 - 项目准备     | 0        |
| 阶段 1 - 创建 NPC API | 3        |
| 阶段 4 - 对话功能     | 1        |
| 阶段 2 - 核心功能     | 0        |
| 阶段 3 - 完善和优化   | 0        |

### 按严重程度统计

| 严重程度 | 数量 |
| -------- | ---- |
| 严重     | 0    |
| 中等     | 0    |
| 轻微     | 0    |

---

## 🔄 问题处理流程

### 1. 发现问题

- 记录问题编号、时间、类型、描述
- 评估问题影响和严重程度

### 2. 分析问题

- 确定问题原因
- 判断是否需要更新文档
- 制定解决方案

### 3. 解决问题

- 实施解决方案
- 验证修复结果
- 更新相关文档（如果需要）

### 4. 记录和总结

- 完善问题记录
- 更新问题统计
- 总结经验教训

---

## 💡 常见问题处理指南

### 代码错误

**处理方式**：

1. 直接修复代码
2. 不需要更新产品文档
3. 记录问题和解决方案

**示例**：

```
问题：数据库查询语句语法错误
解决：修复 SQL 语句，更正字段名
文档：不需要更新
```

### 文档错误

**处理方式**：

1. 先修复代码（按实际需求实现）
2. 更新产品文档（记录正确的需求）
3. 记录变更原因

**示例**：

```
问题：文档说消息长度5000字符，实际应该2000字符
解决：代码按2000字符实现，更新产品文档
文档：需要更新 03-功能需求.md
```

### 实现与文档不一致

**处理方式**：

1. 判断哪个更合理
2. 统一标准（修复代码或更新文档）
3. 记录决策原因

**示例**：

```
问题：文档说返回所有历史记录，但应该分页
解决：实现分页功能，更新文档说明V1支持分页
文档：需要更新 03-功能需求.md 和 04-API设计.md
```

### 技术决策

**处理方式**：

1. 记录决策背景和需求
2. 列出所有可选方案
3. 对比各方案的优缺点
4. 记录决策原因和实现细节
5. 更新相关文档（如开发进度.md）

**示例**：

```
问题：Agent 内存存储结构选择
方案：方案 A（Map）、方案 B（按用户分组）、方案 C（混合）
决策：选择方案 C（独立存储 + 用户关系索引）
原因：支持未来扩展（多用户共享、Agent 独立身份），性能平衡
文档：已更新开发进度.md 和实现问题记录.md
```

---

## 📌 重要提示

1. **及时记录**：发现问题立即记录，不要拖延
2. **详细描述**：问题描述要详细，包含错误信息、复现步骤等
3. **追踪解决**：记录解决方案和验证结果
4. **文档同步**：如果需要更新文档，及时更新并记录
5. **定期回顾**：定期回顾问题记录，总结经验教训

---

## 🔗 相关文档

- [快速开始指南](./产品文档/00-快速开始指南.md) - 开发执行指南
- [开发进度](./开发进度.md) - 开发进度记录
- [产品文档](./产品文档/README.md) - 产品文档索引

---

## 更新日志

| 日期       | 更新内容                                        |
| ---------- | ----------------------------------------------- |
| 2024-12-19 | 创建问题记录文档模板                            |
| 2025-11-20 | 添加问题分类：技术决策                          |
| 2025-11-20 | 记录 PROB-001：Agent 内存存储结构选择（方案 C） |
| 2025-11-20 | 记录 PROB-002：API 路由设计确认（RESTful 规范） |
| 2025-11-20 | 记录 PROB-003：Agent 与 Model 分离设计确认      |
| 2025-11-20 | 记录 PROB-004：Session 和 Event 存储结构设计    |
| 2025-11-20 | 记录 PROB-005：Session 和 Event 存储分离重构    |
| 2025-11-20 | 记录 PROB-006：LLM 模型列表数据维护问题         |
